{"ast":null,"code":"import _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { Observable, interval, throwError } from 'rxjs';\nimport { map, startWith, switchMap, catchError } from 'rxjs/operators';\nimport { GlobalService } from './global.service';\nimport { ElectronService } from 'ngx-electron';\nimport { MatSnackBar } from '@angular/material/snack-bar';\nimport { ApplicationStateService } from './application-state.service';\nimport { ChainService } from './chain.service';\nimport { Logger } from './logger.service';\nimport { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';\nimport { NotificationService } from './notification.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./global.service\";\nimport * as i3 from \"./application-state.service\";\nimport * as i4 from \"./logger.service\";\nimport * as i5 from \"./chain.service\";\nimport * as i6 from \"ngx-electron\";\nimport * as i7 from \"./notification.service\";\nimport * as i8 from \"@angular/material/snack-bar\";\n/**\r\n * For information on the API specification have a look at our swagger files located at http://localhost:5000/swagger/ when running the daemon\r\n */\n\nexport var ApiService = /*#__PURE__*/(function () {\n  var ApiService = /*#__PURE__*/function () {\n    function ApiService(http, globalService, appState, log, chains, electronService, notifications, snackBar) {\n      _classCallCheck(this, ApiService);\n\n      this.http = http;\n      this.globalService = globalService;\n      this.appState = appState;\n      this.log = log;\n      this.chains = chains;\n      this.electronService = electronService;\n      this.notifications = notifications;\n      this.snackBar = snackBar;\n      this.headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      this.pollingInterval = 5000;\n      this.longPollingInterval = 10000;\n      this.apiVersion = 'v2.0-dev'; // This will change into \"v1.0-city\" in a future update to the City Chain daemon.\n\n      if (!ApiService.singletonInstance) {\n        ApiService.singletonInstance = this;\n      }\n\n      return ApiService.singletonInstance;\n    }\n    /** Initialized the daemon running in the background, by sending configuration that has been picked by user, including chain, network and mode. */\n\n\n    _createClass(ApiService, [{\n      key: \"initialize\",\n      value: function initialize() {\n        // Get the current network (main, regtest, testnet), current blockchain (city, stratis, bitcoin) and the mode (full, light, mobile)\n        var chain = this.chains.getChain(this.appState.daemon.network); // Get the correct name of the chain that was found.\n\n        this.appState.chain = chain.chain.toLowerCase(); // Make sure we copy some of the state information to the chain instance supplied to launch the daemon by the main process.\n\n        chain.mode = this.appState.daemon.mode;\n        chain.path = this.appState.daemon.path;\n        chain.datafolder = this.appState.daemon.datafolder;\n        this.genesisDate = chain.genesisDate;\n        this.log.info('Api Service, Chain: ', chain); // For mobile mode, we won't launch any daemons.\n\n        if (chain.mode === 'simple') {} else {\n          if (this.electronService.ipcRenderer) {\n            this.daemon = this.electronService.ipcRenderer.sendSync('start-daemon', chain);\n\n            if (this.daemon !== 'OK') {\n              this.notifications.add({\n                title: 'Blockcore node background error',\n                hint: 'Messages from the background process received in Blockcore Hub',\n                message: this.daemon,\n                icon: 'warning' // icon: (this.daemon.indexOf('Blockcore Hub was started in development mode') > -1) ? 'build' : 'warning'\n\n              }); // this.snackBar.open(this.daemon, null, { duration: 7000 });\n            }\n\n            this.log.info('Daemon result: ', this.daemon);\n            this.setApiPort(chain.apiPort);\n          }\n        }\n      }\n      /** Set the API port to connect with full node API. This will differ depending on coin and network. */\n\n    }, {\n      key: \"setApiPort\",\n      value: function setApiPort(port) {\n        this.apiPort = port;\n        this.apiUrl = 'http://localhost:' + port + '/api';\n      }\n    }, {\n      key: \"getNodeStatus\",\n      value: function getNodeStatus() {\n        var self = this;\n        return this.http.get(self.apiUrl + '/node/status').pipe(catchError(this.handleInitialError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n    }, {\n      key: \"getNodeStatusInterval\",\n      value: function getNodeStatusInterval() {\n        var _this = this;\n\n        var self = this;\n        return interval(this.pollingInterval).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this.http.get(self.apiUrl + '/node/status', {\n            headers: self.headers\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n    }, {\n      key: \"getNodeStatusCustomInterval\",\n      value: function getNodeStatusCustomInterval(milliseconds) {\n        var _this2 = this;\n\n        var self = this;\n        return interval(milliseconds).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this2.http.get(self.apiUrl + '/node/status', {\n            headers: self.headers\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n    }, {\n      key: \"getBannedNodesCustomInterval\",\n      value: function getBannedNodesCustomInterval(milliseconds) {\n        var _this3 = this;\n\n        var self = this;\n        return interval(milliseconds).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this3.http.get(self.apiUrl + '/Network/getbans', {\n            headers: self.headers\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      } // getAddressBookAddresses(): Observable<any> {\n      //     return Observable\n      //         .interval(this.pollingInterval)\n      //         .startWith(0)\n      //         .switchMap(() => this.http.get(this.apiUrl + '/AddressBook'))\n      //         .map((response: Response) => response);\n      // }\n      // addAddressBookAddress(data: AddressLabel): Observable<any> {\n      //     return this.http\n      //         .post(this.apiUrl + '/AddressBook/address', JSON.stringify(data), { headers: this.headers })\n      //         .map((response: Response) => response);\n      // }\n      // removeAddressBookAddress(label: string): Observable<any> {\n      //     const params: URLSearchParams = new URLSearchParams();\n      //     params.set('label', label);\n      //     return this.http\n      //         .delete(this.apiUrl + '/AddressBook/address', new RequestOptions({ headers: this.headers, params: params }))\n      //         .map((response: Response) => response);\n      // }\n\n      /**\r\n       * Gets available wallets at the default path\r\n       */\n\n    }, {\n      key: \"getWalletFiles\",\n      value: function getWalletFiles() {\n        return this.http.get(this.apiUrl + '/wallet/files').pipe(catchError(this.handleInitialError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /** Gets the extended public key from a certain wallet */\n\n    }, {\n      key: \"getExtPubkey\",\n      value: function getExtPubkey(data) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/extpubkey', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get a new mnemonic\r\n       */\n\n    }, {\n      key: \"getNewMnemonic\",\n      value: function getNewMnemonic() {\n        var search = new HttpParams({\n          fromObject: {\n            language: 'English',\n            wordCount: '12'\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/mnemonic', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Create a new wallet.\r\n       */\n\n    }, {\n      key: \"createWallet\",\n      value: function createWallet(data) {\n        return this.http.post(this.apiUrl + '/wallet/create/', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Recover a wallet.\r\n       */\n\n    }, {\n      key: \"recoverWallet\",\n      value: function recoverWallet(data) {\n        return this.http.post(this.apiUrl + '/wallet/recover/', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Load a wallet.\r\n       */\n\n    }, {\n      key: \"loadWallet\",\n      value: function loadWallet(data) {\n        return this.http.post(this.apiUrl + '/wallet/load/', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get wallet statistics info from the API.\r\n       */\n\n    }, {\n      key: \"getWalletStatistics\",\n      value: function getWalletStatistics(data) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/wallet-stats', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get wallet status info from the API.\r\n       */\n\n    }, {\n      key: \"getWalletStatus\",\n      value: function getWalletStatus() {\n        return this.http.get(this.apiUrl + '/wallet/status').pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Split UTXOs in the wallet.\r\n       */\n\n    }, {\n      key: \"splitCoins\",\n      value: function splitCoins(data) {\n        return this.http.post(this.apiUrl + '/wallet/splitcoins/', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /** Remove wallet history and perform a new sync. */\n\n    }, {\n      key: \"removeHistory\",\n      value: function removeHistory(walletName) {\n        return this.http.delete(this.apiUrl + '/wallet/remove-transactions/?all=true&reSync=true&walletName=' + walletName, {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get general wallet info from the API once.\r\n       */\n\n    }, {\n      key: \"getGeneralInfoOnce\",\n      value: function getGeneralInfoOnce(data) {\n        var search = new HttpParams({\n          fromObject: {\n            Name: data.walletName\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/general-info', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get general wallet info from the API once.\r\n       */\n\n    }, {\n      key: \"getGeneralInfoOnceTyped\",\n      value: function getGeneralInfoOnceTyped(data) {\n        var search = new HttpParams({\n          fromObject: {\n            Name: data.walletName\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/general-info', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get general wallet info from the API.\r\n       */\n\n    }, {\n      key: \"getGeneralInfo\",\n      value: function getGeneralInfo(data) {\n        var _this4 = this;\n\n        var search = new HttpParams({\n          fromObject: {\n            Name: data.walletName\n          }\n        });\n        return interval(this.pollingInterval).pipe(startWith(0)) // .pipe(switchMap)\n        // .startWith(0)\n        .pipe(switchMap(function () {\n          return _this4.http.get(_this4.apiUrl + '/wallet/general-info', {\n            headers: _this4.headers,\n            params: search\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get general wallet info from the API.\r\n       */\n\n    }, {\n      key: \"getGeneralInfoTyped\",\n      value: function getGeneralInfoTyped(data) {\n        var _this5 = this;\n\n        var pollingInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.pollingInterval;\n        var search = new HttpParams({\n          fromObject: {\n            Name: data.walletName\n          }\n        });\n        return interval(pollingInterval).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this5.http.get(_this5.apiUrl + '/wallet/general-info', {\n            headers: _this5.headers,\n            params: search\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get wallet balance info from the API.\r\n       */\n\n    }, {\n      key: \"getWalletBalance\",\n      value: function getWalletBalance(data) {\n        var _this6 = this;\n\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName\n          }\n        });\n        return interval(this.pollingInterval).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this6.http.get(_this6.apiUrl + '/wallet/balance', {\n            headers: _this6.headers,\n            params: search\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get the maximum sendable amount for a given fee from the API\r\n       */\n\n    }, {\n      key: \"getMaximumBalance\",\n      value: function getMaximumBalance(data) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accontName,\n            feeType: data.feeType,\n            allowUnconfirmed: 'true'\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/maxbalance', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get a wallets transaction history info from the API.\r\n       */\n\n    }, {\n      key: \"getWalletHistory\",\n      value: function getWalletHistory(data) {\n        var _this7 = this;\n\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName\n          }\n        });\n        return interval(this.longPollingInterval).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this7.http.get(_this7.apiUrl + '/wallet/history', {\n            headers: _this7.headers,\n            params: search\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get an unused receive address for a certain wallet from the API.\r\n       */\n\n    }, {\n      key: \"getUnusedReceiveAddress\",\n      value: function getUnusedReceiveAddress(data, addressType) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName,\n            segwit: (addressType === 'Segwit').toString()\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/unusedaddress', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get an unused receive address for a certain wallet from the API.\r\n       */\n\n    }, {\n      key: \"getFirstReceiveAddress\",\n      value: function getFirstReceiveAddress(data, addressType) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName,\n            segwit: (addressType === 'Segwit').toString()\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/firstaddress', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get multiple unused receive addresses for a certain wallet from the API.\r\n       */\n\n    }, {\n      key: \"getUnusedReceiveAddresses\",\n      value: function getUnusedReceiveAddresses(data, count, addressType) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName,\n            count: count,\n            segwit: (addressType === 'Segwit').toString()\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/unusedaddresses', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get get all addresses for an account of a wallet from the API.\r\n       */\n\n    }, {\n      key: \"getAllAddresses\",\n      value: function getAllAddresses(data, addressType) {\n        var search = new HttpParams({\n          fromObject: {\n            walletName: data.walletName,\n            accountName: data.accountName,\n            segwit: (addressType === 'Segwit').toString()\n          }\n        });\n        return this.http.get(this.apiUrl + '/wallet/addresses', {\n          headers: this.headers,\n          params: search\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Estimate the fee of a transaction\r\n       */\n\n    }, {\n      key: \"estimateFee\",\n      value: function estimateFee(data) {\n        // const search = new HttpParams()\n        //     .set('walletName', data.walletName)\n        //     .set('accountName', data.accountName)\n        //     .set('recipients[0].destinationAddress', data.recipients[0].destinationAddress)\n        //     .set('recipients[0].amount', data.recipients[0].amount)\n        //     .set('feeType', data.feeType)\n        //     .set('allowUnconfirmed', 'true');\n        return this.http.post(this.apiUrl + '/wallet/estimate-txfee', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Build a transaction\r\n       */\n\n    }, {\n      key: \"buildTransaction\",\n      value: function buildTransaction(data) {\n        return this.http.post(this.apiUrl + '/wallet/build-transaction', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Send transaction\r\n       */\n\n    }, {\n      key: \"sendTransaction\",\n      value: function sendTransaction(data) {\n        return this.http.post(this.apiUrl + '/wallet/send-transaction', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Start staking\r\n       */\n\n    }, {\n      key: \"startStaking\",\n      value: function startStaking(data) {\n        return this.http.post(this.apiUrl + '/staking/startstaking', JSON.stringify(data), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Stop staking\r\n       */\n\n    }, {\n      key: \"stopStaking\",\n      value: function stopStaking() {\n        return this.http.post(this.apiUrl + '/staking/stopstaking', 'true', {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get staking info\r\n       */\n\n    }, {\n      key: \"getStakingInfo\",\n      value: function getStakingInfo() {\n        var _this8 = this;\n\n        return interval(this.pollingInterval).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this8.http.get(_this8.apiUrl + '/staking/getstakinginfo');\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get cold staking address (for Cold or Hot addresses)\r\n       */\n\n    }, {\n      key: \"getColdStakingAddress\",\n      value: function getColdStakingAddress(walletName, isColdWallet, segwit) {\n        var params = new HttpParams({\n          fromObject: {\n            walletName: walletName,\n            IsColdWalletAddress: isColdWallet.toString(),\n            Segwit: segwit.toString()\n          }\n        });\n        return this.http.get(this.apiUrl + '/ColdStaking/cold-staking-address', {\n          headers: this.headers,\n          params: params\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Get cold staking info\r\n       */\n\n    }, {\n      key: \"getColdStakingInfo\",\n      value: function getColdStakingInfo(walletName) {\n        var _this9 = this;\n\n        var params = new HttpParams({\n          fromObject: {\n            walletName: walletName\n          }\n        });\n        return interval(this.pollingInterval).pipe(startWith(0)).pipe(switchMap(function () {\n          return _this9.http.get(_this9.apiUrl + '/ColdStaking/cold-staking-info', {\n            headers: _this9.headers,\n            params: params\n          });\n        })).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Active the offline cold staking\r\n       */\n\n    }, {\n      key: \"setupOfflineColdStaking\",\n      value: function setupOfflineColdStaking(wallet, password, walletAccount, coldWalletAddress, hotWalletAddress, amount, fees, segwitChangeAddress, payToScript) {\n        var body = {\n          \"coldWalletAddress\": coldWalletAddress,\n          \"hotWalletAddress\": hotWalletAddress,\n          \"walletName\": wallet,\n          \"walletPassword\": password,\n          \"walletAccount\": walletAccount,\n          \"amount\": amount,\n          \"fees\": fees,\n          \"segwitChangeAddress\": segwitChangeAddress,\n          \"payToScript\": payToScript\n        };\n        console.log(body);\n        return this.http.post(this.apiUrl + '/ColdStaking/setup-offline-staking', body, {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Enable delegated staking\r\n       */\n\n    }, {\n      key: \"enableColdStaking\",\n      value: function enableColdStaking(wallet, password, isColdWalletAccount) {\n        return this.http.post(this.apiUrl + '/ColdStaking/cold-staking-account', {\n          \"walletName\": wallet,\n          \"walletPassword\": password,\n          \"isColdWalletAccount\": isColdWalletAccount\n        }, {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Sign a message\r\n       */\n\n    }, {\n      key: \"signMessage\",\n      value: function signMessage(wallet, password, account, address, message) {\n        return this.http.post(this.apiUrl + '/Wallet/signmessage', {\n          \"walletName\": wallet,\n          \"password\": password,\n          \"accountName\": account,\n          \"externalAddress\": address,\n          \"message\": message\n        }, {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Verify a message\r\n       */\n\n    }, {\n      key: \"verifyMessage\",\n      value: function verifyMessage(address, message, signature) {\n        return this.http.post(this.apiUrl + '/Wallet/verifymessage', {\n          \"signature\": signature,\n          \"externalAddress\": address,\n          \"message\": message\n        }, {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Send shutdown signal to the daemon\r\n       */\n\n    }, {\n      key: \"shutdownNode\",\n      value: function shutdownNode() {\n        return this.http.post(this.apiUrl + '/node/shutdown', 'true', {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Add node\r\n       */\n\n    }, {\n      key: \"addNode\",\n      value: function addNode(ip) {\n        var params = new HttpParams({\n          fromObject: {\n            command: 'add',\n            endpoint: ip\n          }\n        });\n        console.log(params);\n        return this.http.get(this.apiUrl + '/ConnectionManager/addnode', {\n          headers: this.headers,\n          params: params\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Remove node\r\n       */\n\n    }, {\n      key: \"removeNode\",\n      value: function removeNode(ip) {\n        var params = new HttpParams({\n          fromObject: {\n            command: 'remove',\n            endpoint: ip\n          }\n        });\n        return this.http.get(this.apiUrl + '/ConnectionManager/addnode', {\n          headers: this.headers,\n          params: params\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Ban node\r\n       */\n\n    }, {\n      key: \"banNode\",\n      value: function banNode(ip, banDurationSeconds) {\n        var cmd = {\n          banCommand: 'add',\n          banDurationSeconds: banDurationSeconds,\n          peerAddress: ip\n        };\n        return this.http.post(this.apiUrl + '/Network/setban/', JSON.stringify(cmd), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Unban node\r\n       */\n\n    }, {\n      key: \"unbanNode\",\n      value: function unbanNode(ip) {\n        var cmd = {\n          banCommand: 'remove',\n          peerAddress: ip\n        };\n        return this.http.post(this.apiUrl + '/Network/setban/', JSON.stringify(cmd), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /**\r\n       * Remove all bans\r\n       */\n\n    }, {\n      key: \"removeBans\",\n      value: function removeBans() {\n        var cmd = {\n          true: 'true'\n        };\n        return this.http.post(this.apiUrl + '/Network/clearbanned/', JSON.stringify(cmd), {\n          headers: this.headers\n        }).pipe(catchError(this.handleError.bind(this))).pipe(map(function (response) {\n          return response;\n        }));\n      }\n      /** Use this to handle error in the initial startup (wallet/files) of Blockcore Hub. */\n\n    }, {\n      key: \"handleInitialError\",\n      value: function handleInitialError(error) {\n        // Only show snackbar errors when we have connected. Initially we will receive some errors due to aggresive\n        // attempts at connecting to the node.\n        if (this.appState.connected) {\n          this.handleException(error);\n        }\n\n        return throwError(error);\n      }\n      /** Use this to handle error (exceptions) that happens in RXJS pipes. This handler will rethrow the error. */\n\n    }, {\n      key: \"handleError\",\n      value: function handleError(error) {\n        this.handleException(error);\n        return throwError(error);\n      }\n      /** Use this to handle errors (exceptions) that happens outside of an RXJS pipe. See the \"handleError\" for pipeline error handling. */\n\n    }, {\n      key: \"handleException\",\n      value: function handleException(error) {\n        var _a, _b, _c;\n\n        var errorMessage = '';\n\n        if (error.error instanceof ErrorEvent) {\n          errorMessage = 'An error occurred:' + error.error.message; // A client-side or network error occurred. Handle it accordingly.\n        } else if ((_a = error.error) === null || _a === void 0 ? void 0 : _a.errors) {\n          if (Array.isArray(error.error.errors)) {\n            errorMessage = \"\".concat(error.error.errors[0].message, \" (Code: \").concat(error.error.errors[0].status, \")\");\n          } else {\n            for (var property in (_b = error.error) === null || _b === void 0 ? void 0 : _b.errors) {\n              if ((_c = error.error) === null || _c === void 0 ? void 0 : _c.errors.hasOwnProperty(property)) {\n                console.log(property);\n                errorMessage += \"\".concat(property, \": \").concat(error.error.errors[property]);\n              }\n            }\n          }\n        } else if (error.name === 'HttpErrorResponse') {\n          errorMessage = \"Unable to connect with background daemon: \".concat(error.message, \" (\").concat(error.status, \")\"); // if (error.error.target.__zone_symbol__xhrURL.indexOf('api/wallet/files') > -1) {\n          // }\n        } else {\n          errorMessage = \"Error: \".concat(error.message, \" (\").concat(error.status, \")\");\n        }\n\n        this.log.error(errorMessage);\n        this.notifications.add({\n          title: 'Communication error',\n          hint: 'These types of errors are not uncommon, happens when there is issues communicating between Blockcore Hub and Blockcore Node background process',\n          message: errorMessage,\n          icon: 'warning'\n        }); // if (errorMessage.indexOf('Http failure response for') === -1) {\n        // this.snackBar.open(errorMessage, null, { duration: 5000, panelClass: 'error-snackbar' });\n        // }\n      }\n    }]);\n\n    return ApiService;\n  }();\n\n  /** @nocollapse */\n  ApiService.ɵfac = function ApiService_Factory(t) {\n    return new (t || ApiService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.GlobalService), i0.ɵɵinject(i3.ApplicationStateService), i0.ɵɵinject(i4.Logger), i0.ɵɵinject(i5.ChainService), i0.ɵɵinject(i6.ElectronService), i0.ɵɵinject(i7.NotificationService), i0.ɵɵinject(i8.MatSnackBar));\n  };\n  /** @nocollapse */\n\n\n  ApiService.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: ApiService,\n    factory: ApiService.ɵfac,\n    providedIn: 'root'\n  });\n  return ApiService;\n})();","map":null,"metadata":{},"sourceType":"module"}