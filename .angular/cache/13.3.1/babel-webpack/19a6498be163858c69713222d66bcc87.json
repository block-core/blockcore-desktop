{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/* eslint-disable */\n\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013-2014 Cryptocoinjs contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\nhttps://github.com/bitcoinjs/bip38\r\n\r\nCommit: 890cd7b75815453e17f25ed4e7b2dc6e3d07c488\r\n*/\nconst aes = require('browserify-aes');\n\nconst assert = require('assert'); // const Buff = require('safe-buffer').Buffer;\n\n\nconst bs58check = require('bs58check');\n\nconst createHash = require('create-hash');\n\nconst scrypt = require('scryptsy');\n\nconst xor = require('buffer-xor/inplace');\n\nconst ecurve = require('ecurve');\n\nconst curve = ecurve.getCurveByName('secp256k1'); // eslint-disable-next-line @typescript-eslint/naming-convention\n\nconst BigInteger = require('bigi'); // constants\n\n\nconst SCRYPT_PARAMS = {\n  N: 16384,\n  r: 8,\n  p: 8\n};\nconst NETWORK_PARAMS = {\n  private: 0x80,\n  public: 0x00\n};\nconst NULL = Buffer.alloc(0);\n\nfunction hash160(buffer) {\n  let hash;\n\n  try {\n    hash = createHash('rmd160');\n  } catch (e) {\n    hash = createHash('ripemd160');\n  }\n\n  return hash.update(createHash('sha256').update(buffer).digest()).digest();\n}\n\nfunction hash256(buffer) {\n  return createHash('sha256').update(createHash('sha256').update(buffer).digest()).digest();\n}\n\nfunction getAddress(d, compressed, networkParams) {\n  const Q = curve.G.multiply(d).getEncoded(compressed);\n  const hash = hash160(Q);\n  const payload = Buffer.allocUnsafe(21); // payload.writeUInt8(0x00, 0); // XXX TODO FIXME bitcoin only??? damn you BIP38\n\n  payload.writeUInt8(networkParams.public, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\n\nfunction prepareEncryptRaw(buffer, compressed, passphrase, scryptParams, networkParams) {\n  if (buffer.length !== 32) {\n    throw new Error('Invalid private key length');\n  }\n\n  const d = BigInteger.fromBuffer(buffer);\n  const address = getAddress(d, compressed, networkParams);\n  const secret = Buffer.from(passphrase.normalize('NFC'), 'utf8');\n  const salt = hash256(address).slice(0, 4);\n  const N = scryptParams.N;\n  const r = scryptParams.r;\n  const p = scryptParams.p;\n  return {\n    secret,\n    salt,\n    N,\n    r,\n    p\n  };\n}\n\nfunction finishEncryptRaw(buffer, compressed, salt, scryptBuf) {\n  const derivedHalf1 = scryptBuf.slice(0, 32);\n  const derivedHalf2 = scryptBuf.slice(32, 64);\n  const xorBuf = xor(derivedHalf1, buffer);\n  const cipher = aes.createCipheriv('aes-256-ecb', derivedHalf2, NULL);\n  cipher.setAutoPadding(false);\n  cipher.end(xorBuf);\n  const cipherText = cipher.read(); // 0x01 | 0x42 | flagByte | salt (4) | cipherText (32)\n\n  const result = Buffer.allocUnsafe(7 + 32);\n  result.writeUInt8(0x01, 0);\n  result.writeUInt8(0x42, 1);\n  result.writeUInt8(compressed ? 0xe0 : 0xc0, 2);\n  salt.copy(result, 3);\n  cipherText.copy(result, 7);\n  return result;\n}\n\nexport function encryptRawAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n  return _encryptRawAsync.apply(this, arguments);\n}\n\nfunction _encryptRawAsync() {\n  _encryptRawAsync = _asyncToGenerator(function* (buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n    scryptParams = scryptParams || SCRYPT_PARAMS;\n    networkParams = networkParams || NETWORK_PARAMS;\n    const {\n      secret,\n      salt,\n      N,\n      r,\n      p\n    } = prepareEncryptRaw(buffer, compressed, passphrase, scryptParams, networkParams);\n    const scryptBuf = yield scrypt.async(secret, salt, N, r, p, 64, progressCallback, promiseInterval);\n    return finishEncryptRaw(buffer, compressed, salt, scryptBuf);\n  });\n  return _encryptRawAsync.apply(this, arguments);\n}\n\nexport function encryptRaw(buffer, compressed, passphrase, progressCallback, scryptParams, networkParams) {\n  scryptParams = scryptParams || SCRYPT_PARAMS;\n  networkParams = networkParams || NETWORK_PARAMS;\n  const {\n    secret,\n    salt,\n    N,\n    r,\n    p\n  } = prepareEncryptRaw(buffer, compressed, passphrase, scryptParams, networkParams);\n  const scryptBuf = scrypt(secret, salt, N, r, p, 64, progressCallback);\n  return finishEncryptRaw(buffer, compressed, salt, scryptBuf);\n}\nexport function encryptAsync(_x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n  return _encryptAsync.apply(this, arguments);\n}\n\nfunction _encryptAsync() {\n  _encryptAsync = _asyncToGenerator(function* (buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n    return bs58check.encode(yield encryptRawAsync(buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval, networkParams));\n  });\n  return _encryptAsync.apply(this, arguments);\n}\n\nexport function encrypt(buffer, compressed, passphrase, progressCallback, scryptParams, networkParams) {\n  return bs58check.encode(encryptRaw(buffer, compressed, passphrase, progressCallback, scryptParams, networkParams));\n}\n\nfunction prepareDecryptRaw(buffer, progressCallback, scryptParams) {\n  // 39 bytes: 2 bytes prefix, 37 bytes payload\n  if (buffer.length !== 39) {\n    throw new Error('Invalid BIP38 data length');\n  }\n\n  if (buffer.readUInt8(0) !== 0x01) {\n    throw new Error('Invalid BIP38 prefix');\n  } // check if BIP38 EC multiply\n\n\n  const type = buffer.readUInt8(1);\n\n  if (type === 0x43) {\n    return {\n      decryptEC: true\n    };\n  }\n\n  if (type !== 0x42) {\n    throw new Error('Invalid BIP38 type');\n  }\n\n  const flagByte = buffer.readUInt8(2);\n  const compressed = flagByte === 0xe0;\n\n  if (!compressed && flagByte !== 0xc0) {\n    throw new Error('Invalid BIP38 compression flag');\n  }\n\n  const N = scryptParams.N;\n  const r = scryptParams.r;\n  const p = scryptParams.p;\n  const salt = buffer.slice(3, 7);\n  return {\n    salt,\n    compressed,\n    N,\n    r,\n    p\n  };\n}\n\nfunction finishDecryptRaw(buffer, salt, compressed, scryptBuf, networkParams) {\n  const derivedHalf1 = scryptBuf.slice(0, 32);\n  const derivedHalf2 = scryptBuf.slice(32, 64);\n  const privKeyBuf = buffer.slice(7, 7 + 32);\n  const decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, NULL);\n  decipher.setAutoPadding(false);\n  decipher.end(privKeyBuf);\n  const plainText = decipher.read();\n  const privateKey = xor(derivedHalf1, plainText); // verify salt matches address\n\n  const d = BigInteger.fromBuffer(privateKey);\n  const address = getAddress(d, compressed, networkParams);\n  const checksum = hash256(address).slice(0, 4); // The underlaying buffer will be different, we only compare the initial 4 values.\n\n  assert.strictEqual(true, salt.every((value, index) => value === checksum[index])); // assert.deepStrictEqual(salt, checksum);\n\n  return {\n    privateKey,\n    compressed\n  };\n}\n\nexport function decryptRawAsync(_x15, _x16, _x17, _x18, _x19, _x20) {\n  return _decryptRawAsync.apply(this, arguments);\n} // some of the techniques borrowed from: https://github.com/pointbiz/bitaddress.org\n\nfunction _decryptRawAsync() {\n  _decryptRawAsync = _asyncToGenerator(function* (buffer, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n    scryptParams = scryptParams || SCRYPT_PARAMS;\n    networkParams = networkParams || NETWORK_PARAMS;\n    const {\n      salt,\n      compressed,\n      N,\n      r,\n      p,\n      decryptEC\n    } = prepareDecryptRaw(buffer, progressCallback, scryptParams);\n\n    if (decryptEC === true) {\n      return decryptECMultAsync(buffer, passphrase, progressCallback, scryptParams, promiseInterval);\n    }\n\n    const scryptBuf = yield scrypt.async(passphrase.normalize('NFC'), salt, N, r, p, 64, progressCallback, promiseInterval);\n    return finishDecryptRaw(buffer, salt, compressed, scryptBuf, networkParams);\n  });\n  return _decryptRawAsync.apply(this, arguments);\n}\n\nexport function decryptRaw(buffer, passphrase, progressCallback, scryptParams, networkParams) {\n  scryptParams = scryptParams || SCRYPT_PARAMS;\n  networkParams = networkParams || NETWORK_PARAMS;\n  const {\n    salt,\n    compressed,\n    N,\n    r,\n    p,\n    decryptEC\n  } = prepareDecryptRaw(buffer, progressCallback, scryptParams);\n\n  if (decryptEC === true) {\n    return decryptECMult(buffer, passphrase, progressCallback, scryptParams);\n  }\n\n  const scryptBuf = scrypt(passphrase.normalize('NFC'), salt, N, r, p, 64, progressCallback);\n  return finishDecryptRaw(buffer, salt, compressed, scryptBuf, networkParams);\n}\nexport function decryptAsync(_x21, _x22, _x23, _x24, _x25, _x26) {\n  return _decryptAsync.apply(this, arguments);\n}\n\nfunction _decryptAsync() {\n  _decryptAsync = _asyncToGenerator(function* (text, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n    return decryptRawAsync(bs58check.decode(text), passphrase, progressCallback, scryptParams, promiseInterval, networkParams);\n  });\n  return _decryptAsync.apply(this, arguments);\n}\n\nexport function decrypt(text, passphrase, progressCallback, scryptParams, networkParams) {\n  return decryptRaw(bs58check.decode(text), passphrase, progressCallback, scryptParams, networkParams);\n}\n\nfunction prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams) {\n  const flag = buffer.readUInt8(1); // eslint-disable-next-line no-bitwise\n\n  const compressed = (flag & 0x20) !== 0; // eslint-disable-next-line no-bitwise\n\n  const hasLotSeq = (flag & 0x04) !== 0; // eslint-disable-next-line no-bitwise\n\n  assert.strictEqual(flag & 0x24, flag, 'Invalid private key.');\n  const addressHash = buffer.slice(2, 6);\n  const ownerEntropy = buffer.slice(6, 14);\n  let ownerSalt; // 4 bytes ownerSalt if 4 bytes lot/sequence\n\n  if (hasLotSeq) {\n    ownerSalt = ownerEntropy.slice(0, 4); // else, 8 bytes ownerSalt\n  } else {\n    ownerSalt = ownerEntropy;\n  }\n\n  const encryptedPart1 = buffer.slice(14, 22); // First 8 bytes\n\n  const encryptedPart2 = buffer.slice(22, 38); // 16 bytes\n\n  const N = scryptParams.N;\n  const r = scryptParams.r;\n  const p = scryptParams.p;\n  return {\n    addressHash,\n    encryptedPart1,\n    encryptedPart2,\n    ownerEntropy,\n    ownerSalt,\n    hasLotSeq,\n    compressed,\n    N,\n    r,\n    p\n  };\n}\n\nfunction getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq) {\n  let passFactor;\n\n  if (hasLotSeq) {\n    const hashTarget = Buffer.concat([preFactor, ownerEntropy]);\n    passFactor = hash256(hashTarget);\n  } else {\n    passFactor = preFactor;\n  }\n\n  const passInt = BigInteger.fromBuffer(passFactor);\n  return {\n    passInt,\n    passPoint: curve.G.multiply(passInt).getEncoded(true)\n  };\n}\n\nfunction finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed) {\n  const derivedHalf1 = seedBPass.slice(0, 32);\n  const derivedHalf2 = seedBPass.slice(32, 64);\n  const decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, Buffer.alloc(0));\n  decipher.setAutoPadding(false);\n  decipher.end(encryptedPart2);\n  const decryptedPart2 = decipher.read();\n  const tmp = xor(decryptedPart2, derivedHalf1.slice(16, 32));\n  const seedBPart2 = tmp.slice(8, 16);\n  const decipher2 = aes.createDecipheriv('aes-256-ecb', derivedHalf2, Buffer.alloc(0));\n  decipher2.setAutoPadding(false);\n  decipher2.write(encryptedPart1); // first 8 bytes\n\n  decipher2.end(tmp.slice(0, 8)); // last 8 bytes\n\n  const seedBPart1 = xor(decipher2.read(), derivedHalf1.slice(0, 16));\n  const seedB = Buffer.concat([seedBPart1, seedBPart2], 24);\n  const factorB = BigInteger.fromBuffer(hash256(seedB)); // d = passFactor * factorB (mod n)\n\n  const d = passInt.multiply(factorB).mod(curve.n);\n  return {\n    privateKey: d.toBuffer(32),\n    compressed\n  };\n}\n\nexport function decryptECMultAsync(_x27, _x28, _x29, _x30, _x31) {\n  return _decryptECMultAsync.apply(this, arguments);\n}\n\nfunction _decryptECMultAsync() {\n  _decryptECMultAsync = _asyncToGenerator(function* (buffer, passphrase, progressCallback, scryptParams, promiseInterval) {\n    buffer = buffer.slice(1); // FIXME: we can avoid this\n\n    passphrase = Buffer.from(passphrase.normalize('NFC'), 'utf8');\n    scryptParams = scryptParams || SCRYPT_PARAMS;\n    const {\n      addressHash,\n      encryptedPart1,\n      encryptedPart2,\n      ownerEntropy,\n      ownerSalt,\n      hasLotSeq,\n      compressed,\n      N,\n      r,\n      p\n    } = prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams);\n    const preFactor = yield scrypt.async(passphrase, ownerSalt, N, r, p, 32, progressCallback, promiseInterval);\n    const {\n      passInt,\n      passPoint\n    } = getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq);\n    const seedBPass = yield scrypt.async(passPoint, Buffer.concat([addressHash, ownerEntropy]), 1024, 1, 1, 64, undefined, promiseInterval);\n    return finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed);\n  });\n  return _decryptECMultAsync.apply(this, arguments);\n}\n\nexport function decryptECMult(buffer, passphrase, progressCallback, scryptParams) {\n  buffer = buffer.slice(1); // FIXME: we can avoid this\n\n  passphrase = Buffer.from(passphrase.normalize('NFC'), 'utf8');\n  scryptParams = scryptParams || SCRYPT_PARAMS;\n  const {\n    addressHash,\n    encryptedPart1,\n    encryptedPart2,\n    ownerEntropy,\n    ownerSalt,\n    hasLotSeq,\n    compressed,\n    N,\n    r,\n    p\n  } = prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams);\n  const preFactor = scrypt(passphrase, ownerSalt, N, r, p, 32, progressCallback);\n  const {\n    passInt,\n    passPoint\n  } = getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq);\n  const seedBPass = scrypt(passPoint, Buffer.concat([addressHash, ownerEntropy]), 1024, 1, 1, 64);\n  return finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed);\n}\nexport function verify(text) {\n  const decoded = bs58check.decodeUnsafe(text);\n\n  if (!decoded) {\n    return false;\n  }\n\n  if (decoded.length !== 39) {\n    return false;\n  }\n\n  if (decoded.readUInt8(0) !== 0x01) {\n    return false;\n  }\n\n  const type = decoded.readUInt8(1);\n  const flag = decoded.readUInt8(2); // encrypted WIF\n\n  if (type === 0x42) {\n    if (flag !== 0xc0 && flag !== 0xe0) {\n      return false;\n    } // EC mult\n\n  } else if (type === 0x43) {\n    // eslint-disable-next-line no-bitwise\n    if (flag & ~0x24) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n} // module.exports = {\n//     decrypt,\n//     decryptECMult,\n//     decryptRaw,\n//     encrypt,\n//     encryptRaw,\n//     decryptAsync,\n//     decryptECMultAsync,\n//     decryptRawAsync,\n//     encryptAsync,\n//     encryptRawAsync,\n//     verify\n// };","map":null,"metadata":{},"sourceType":"module"}