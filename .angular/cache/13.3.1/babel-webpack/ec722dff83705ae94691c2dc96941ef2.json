{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bs58check = require('bs58check');\n\nvar crypto = require('./crypto');\n\nvar ecc = require('tiny-secp256k1');\n\nvar typeforce = require('typeforce');\n\nvar wif = require('wif');\n\nvar UINT256_TYPE = typeforce.BufferN(32);\nvar NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n});\nvar BITCOIN = {\n  wif: 0x80,\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  }\n};\n\nfunction BIP32(d, Q, chainCode, network) {\n  typeforce(NETWORK_TYPE, network);\n  this.__d = d || null;\n  this.__Q = Q || null;\n  this.chainCode = chainCode;\n  this.depth = 0;\n  this.index = 0;\n  this.network = network;\n  this.parentFingerprint = 0x00000000;\n}\n\nObject.defineProperty(BIP32.prototype, 'identifier', {\n  get: function get() {\n    return crypto.hash160(this.publicKey);\n  }\n});\nObject.defineProperty(BIP32.prototype, 'fingerprint', {\n  get: function get() {\n    return this.identifier.slice(0, 4);\n  }\n});\nObject.defineProperty(BIP32.prototype, 'privateKey', {\n  enumerable: false,\n  get: function get() {\n    return this.__d;\n  }\n});\nObject.defineProperty(BIP32.prototype, 'publicKey', {\n  get: function get() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__d, this.compressed);\n    return this.__Q;\n  }\n}); // Private === not neutered\n// Public === neutered\n\nBIP32.prototype.isNeutered = function () {\n  return this.__d === null;\n};\n\nBIP32.prototype.neutered = function () {\n  var neutered = fromPublicKey(this.publicKey, this.chainCode, this.network);\n  neutered.depth = this.depth;\n  neutered.index = this.index;\n  neutered.parentFingerprint = this.parentFingerprint;\n  return neutered;\n};\n\nBIP32.prototype.toBase58 = function () {\n  var network = this.network;\n  var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n  var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n  buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n  buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n  this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45);\n    this.privateKey.copy(buffer, 46); // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.publicKey.copy(buffer, 45);\n  }\n\n  return bs58check.encode(buffer);\n};\n\nBIP32.prototype.toWIF = function () {\n  if (!this.privateKey) throw new TypeError('Missing private key');\n  return wif.encode(this.network.wif, this.privateKey, true);\n};\n\nvar HIGHEST_BIT = 0x80000000; // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\nBIP32.prototype.derive = function (index) {\n  typeforce(typeforce.UInt32, index);\n  var isHardened = index >= HIGHEST_BIT;\n  var data = Buffer.allocUnsafe(37); // Hardened child\n\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data[0] = 0x00;\n    this.privateKey.copy(data, 1);\n    data.writeUInt32BE(index, 33); // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.publicKey.copy(data, 0);\n    data.writeUInt32BE(index, 33);\n  }\n\n  var I = crypto.hmacSHA512(this.chainCode, data);\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32); // if parse256(IL) >= n, proceed with the next value for i\n\n  if (!ecc.isPrivate(IL)) return this.derive(index + 1); // Private parent key -> private child key\n\n  var hd;\n\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = ecc.privateAdd(this.privateKey, IL); // In case ki == 0, proceed with the next value for i\n\n    if (ki == null) return this.derive(index + 1);\n    hd = fromPrivateKey(ki, IR, this.network); // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var Ki = ecc.pointAddScalar(this.publicKey, IL, true); // In case Ki is the point at infinity, proceed with the next value for i\n\n    if (Ki === null) return this.derive(index + 1);\n    hd = fromPublicKey(Ki, IR, this.network);\n  }\n\n  hd.depth = this.depth + 1;\n  hd.index = index;\n  hd.parentFingerprint = this.fingerprint.readUInt32BE(0);\n  return hd;\n};\n\nvar UINT31_MAX = Math.pow(2, 31) - 1;\n\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\n\nBIP32.prototype.deriveHardened = function (index) {\n  typeforce(UInt31, index); // Only derives hardened private keys by default\n\n  return this.derive(index + HIGHEST_BIT);\n};\n\nfunction BIP32Path(value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\n\nBIP32.prototype.derivePath = function (path) {\n  typeforce(BIP32Path, path);\n  var splitPath = path.split('/');\n\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) throw new TypeError('Expected master, got child');\n    splitPath = splitPath.slice(1);\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index;\n\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10);\n      return prevHd.deriveHardened(index);\n    } else {\n      index = parseInt(indexStr, 10);\n      return prevHd.derive(index);\n    }\n  }, this);\n};\n\nBIP32.prototype.sign = function (hash) {\n  return ecc.sign(hash, this.privateKey);\n};\n\nBIP32.prototype.verify = function (hash, signature) {\n  return ecc.verify(hash, this.publicKey, signature);\n};\n\nfunction fromBase58(string, network) {\n  var buffer = bs58check.decode(string);\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length');\n  network = network || BITCOIN; // 4 bytes: version bytes\n\n  var version = buffer.readUInt32BE(0);\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  var parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index'); // 32 bytes: the chain code\n\n  var chainCode = buffer.slice(13, 45);\n  var hd; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key');\n    var k = buffer.slice(46, 78);\n    hd = fromPrivateKey(k, chainCode, network); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var X = buffer.slice(45, 78);\n    hd = fromPublicKey(X, chainCode, network);\n  }\n\n  hd.depth = depth;\n  hd.index = index;\n  hd.parentFingerprint = parentFingerprint;\n  return hd;\n}\n\nfunction fromPrivateKey(privateKey, chainCode, network) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, {\n    privateKey: privateKey,\n    chainCode: chainCode\n  });\n  network = network || BITCOIN;\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');\n  return new BIP32(privateKey, null, chainCode, network);\n}\n\nfunction fromPublicKey(publicKey, chainCode, network) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, {\n    publicKey: publicKey,\n    chainCode: chainCode\n  });\n  network = network || BITCOIN; // verify the X coordinate is a point on the curve\n\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');\n  return new BIP32(null, publicKey, chainCode, network);\n}\n\nfunction fromSeed(seed, network) {\n  typeforce(typeforce.Buffer, seed);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  network = network || BITCOIN;\n  var I = crypto.hmacSHA512('Bitcoin seed', seed);\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  return fromPrivateKey(IL, IR, network);\n}\n\nmodule.exports = {\n  fromBase58: fromBase58,\n  fromPrivateKey: fromPrivateKey,\n  fromPublicKey: fromPublicKey,\n  fromSeed: fromSeed\n};","map":null,"metadata":{},"sourceType":"script"}