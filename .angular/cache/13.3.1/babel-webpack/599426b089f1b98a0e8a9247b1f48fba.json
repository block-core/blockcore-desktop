{"ast":null,"code":"const lazy = require('./lazy');\n\nconst typef = require('typeforce');\n\nconst OPS = require('bitcoin-ops');\n\nconst bcrypto = require('../crypto');\n\nconst bscript = require('../script');\n\nconst BITCOIN_NETWORK = require('../networks').bitcoin;\n\nconst bs58check = require('bs58check');\n\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every(function (x, i) {\n    return x.equals(b[i]);\n  });\n} // input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n\n\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) throw new TypeError('Not enough data');\n  opts = Object.assign({\n    validate: true\n  }, opts || {});\n  typef({\n    network: typef.maybe(typef.Object),\n    address: typef.maybe(typef.String),\n    hash: typef.maybe(typef.BufferN(20)),\n    output: typef.maybe(typef.BufferN(23)),\n    redeem: typef.maybe({\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      input: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer))\n    }),\n    input: typef.maybe(typef.Buffer),\n    witness: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a);\n  let network = a.network;\n\n  if (!network) {\n    network = a.redeem && a.redeem.network || BITCOIN_NETWORK;\n  }\n\n  const o = {\n    network\n  };\n\n  const _address = lazy.value(function () {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return {\n      version,\n      hash\n    };\n  });\n\n  const _chunks = lazy.value(function () {\n    return bscript.decompile(a.input);\n  });\n\n  const _redeem = lazy.value(function () {\n    const chunks = _chunks();\n\n    return {\n      network,\n      output: chunks[chunks.length - 1],\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || []\n    };\n  }); // output dependents\n\n\n  lazy.prop(o, 'address', function () {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', function () {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', function () {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  }); // input dependents\n\n  lazy.prop(o, 'redeem', function () {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', function () {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile([].concat(bscript.decompile(a.redeem.input), a.redeem.output));\n  });\n  lazy.prop(o, 'witness', function () {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n\n  if (opts.validate) {\n    let hash;\n\n    if (a.address) {\n      if (_address().version !== network.scriptHash) throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n\n    if (a.hash) {\n      if (hash && !hash.equals(a.hash)) throw new TypeError('Hash mismatch');else hash = a.hash;\n    }\n\n    if (a.output) {\n      if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 0x14 || a.output[22] !== OPS.OP_EQUAL) throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch');else hash = hash2;\n    } // inlined to prevent 'no-inner-declarations' failing\n\n\n    const checkRedeem = function (redeem) {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1) throw new TypeError('Redeem.output too short'); // match hash against other sources\n\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash && !hash.equals(hash2)) throw new TypeError('Hash mismatch');else hash = hash2;\n      }\n\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness) throw new TypeError('Input and witness provided');\n\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks)) throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n\n    if (a.input) {\n      const chunks = _chunks();\n\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output)) throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network) throw new TypeError('Network mismatch');\n\n      if (a.input) {\n        const redeem = _redeem();\n\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output)) throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input)) throw new TypeError('Redeem.input mismatch');\n      }\n\n      checkRedeem(a.redeem);\n    }\n\n    if (a.witness) {\n      if (a.redeem && a.redeem.witness && !stacksEqual(a.redeem.witness, a.witness)) throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n\n  return Object.assign(o, a);\n}\n\nmodule.exports = p2sh;","map":null,"metadata":{},"sourceType":"script"}