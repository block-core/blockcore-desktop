{"ast":null,"code":"const BN = require('bn.js');\n\nconst EC = require('elliptic').ec;\n\nconst secp256k1 = new EC('secp256k1');\n\nconst deterministicGenerateK = require('./rfc6979');\n\nconst ZERO32 = Buffer.alloc(32, 0);\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');\nconst n = secp256k1.curve.n;\nconst nDiv2 = n.shrn(1);\nconst G = secp256k1.curve.g;\nconst THROW_BAD_PRIVATE = 'Expected Private';\nconst THROW_BAD_POINT = 'Expected Point';\nconst THROW_BAD_TWEAK = 'Expected Tweak';\nconst THROW_BAD_HASH = 'Expected Hash';\nconst THROW_BAD_SIGNATURE = 'Expected Signature';\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';\n\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isOrderScalar(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isPoint(p) {\n  if (!Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try {\n      decodeFrom(p);\n    } catch (e) {\n      return false;\n    } // TODO: temporary\n\n\n    return true;\n  }\n\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\n\nfunction __isPointCompressed(p) {\n  return p[0] !== 0x04;\n}\n\nfunction isPointCompressed(p) {\n  if (!isPoint(p)) return false;\n  return __isPointCompressed(p);\n}\n\nfunction isPrivate(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(ZERO32) > 0 && // > 0\n  x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isSignature(value) {\n  const r = value.slice(0, 32);\n  const s = value.slice(32, 64);\n  return Buffer.isBuffer(value) && value.length === 64 && r.compare(EC_GROUP_ORDER) < 0 && s.compare(EC_GROUP_ORDER) < 0;\n}\n\nfunction assumeCompression(value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey);\n  if (value === undefined) return true;\n  return value;\n}\n\nfunction fromBuffer(d) {\n  return new BN(d);\n}\n\nfunction toBuffer(d) {\n  return d.toArrayLike(Buffer, 'be', 32);\n}\n\nfunction decodeFrom(P) {\n  return secp256k1.curve.decodePoint(P);\n}\n\nfunction getEncoded(P, compressed) {\n  return Buffer.from(P._encode(compressed));\n}\n\nfunction pointAdd(pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);\n  const a = decodeFrom(pA);\n  const b = decodeFrom(pB);\n  const pp = a.add(b);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed, pA);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointAddScalar(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed);\n  const tt = fromBuffer(tweak);\n  const qq = G.mul(tt);\n  const uu = pp.add(qq);\n  if (uu.isInfinity()) return null;\n  return getEncoded(uu, compressed);\n}\n\nfunction pointCompress(p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  const pp = decodeFrom(p);\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);\n  const compressed = assumeCompression(__compressed, p);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointFromScalar(d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  const dd = fromBuffer(d);\n  const pp = G.mul(dd);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointMultiply(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  const tt = fromBuffer(tweak);\n  const qq = pp.mul(tt);\n  if (qq.isInfinity()) return null;\n  return getEncoded(qq, compressed);\n}\n\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.add(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\n\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.sub(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\n\nfunction sign(hash, x) {\n  return __sign(hash, x);\n}\n\nfunction signWithEntropy(hash, x, addData) {\n  return __sign(hash, x, addData);\n}\n\nfunction __sign(hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);\n  const d = fromBuffer(x);\n  const e = fromBuffer(hash);\n  let r, s;\n\n  const checkSig = function (k) {\n    const kI = fromBuffer(k);\n    const Q = G.mul(kI);\n    if (Q.isInfinity()) return false;\n    r = Q.x.umod(n);\n    if (r.isZero() === 0) return false;\n    s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);\n    if (s.isZero() === 0) return false;\n    return true;\n  };\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s);\n  }\n\n  const buffer = Buffer.allocUnsafe(64);\n  toBuffer(r).copy(buffer, 0);\n  toBuffer(s).copy(buffer, 32);\n  return buffer;\n}\n\nfunction verify(hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT); // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);\n  const Q = decodeFrom(q);\n  const r = fromBuffer(signature.slice(0, 32));\n  const s = fromBuffer(signature.slice(32, 64));\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false;\n  } // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n\n\n  if (r.gtn(0) <= 0\n  /* || r.compareTo(n) >= 0 */\n  ) return false;\n  if (s.gtn(0) <= 0\n  /* || s.compareTo(n) >= 0 */\n  ) return false; // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n\n  const e = fromBuffer(hash); // Compute s^-1\n\n  const sInv = s.invm(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  const u1 = e.mul(sInv).umod(n);\n  const u2 = r.mul(sInv).umod(n); // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n\n  const R = G.mulAdd(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (R.isInfinity()) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  const xR = R.x; // 1.4.7 Set v = xR mod n\n\n  const v = xR.umod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.eq(r);\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n};","map":null,"metadata":{},"sourceType":"script"}