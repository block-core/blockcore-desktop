{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\n/* eslint-disable */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013-2014 Cryptocoinjs contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\nhttps://github.com/bitcoinjs/bip38\r\n\r\nCommit: 890cd7b75815453e17f25ed4e7b2dc6e3d07c488\r\n*/\n\n\nvar aes = require('browserify-aes');\n\nvar assert = require('assert'); // const Buff = require('safe-buffer').Buffer;\n\n\nvar bs58check = require('bs58check');\n\nvar createHash = require('create-hash');\n\nvar scrypt = require('scryptsy');\n\nvar xor = require('buffer-xor/inplace');\n\nvar ecurve = require('ecurve');\n\nvar curve = ecurve.getCurveByName('secp256k1'); // eslint-disable-next-line @typescript-eslint/naming-convention\n\nvar BigInteger = require('bigi'); // constants\n\n\nvar SCRYPT_PARAMS = {\n  N: 16384,\n  r: 8,\n  p: 8\n};\nvar NETWORK_PARAMS = {\n  private: 0x80,\n  public: 0x00\n};\nvar NULL = Buffer.alloc(0);\n\nfunction hash160(buffer) {\n  var hash;\n\n  try {\n    hash = createHash('rmd160');\n  } catch (e) {\n    hash = createHash('ripemd160');\n  }\n\n  return hash.update(createHash('sha256').update(buffer).digest()).digest();\n}\n\nfunction hash256(buffer) {\n  return createHash('sha256').update(createHash('sha256').update(buffer).digest()).digest();\n}\n\nfunction getAddress(d, compressed, networkParams) {\n  var Q = curve.G.multiply(d).getEncoded(compressed);\n  var hash = hash160(Q);\n  var payload = Buffer.allocUnsafe(21); // payload.writeUInt8(0x00, 0); // XXX TODO FIXME bitcoin only??? damn you BIP38\n\n  payload.writeUInt8(networkParams.public, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\n\nfunction prepareEncryptRaw(buffer, compressed, passphrase, scryptParams, networkParams) {\n  if (buffer.length !== 32) {\n    throw new Error('Invalid private key length');\n  }\n\n  var d = BigInteger.fromBuffer(buffer);\n  var address = getAddress(d, compressed, networkParams);\n  var secret = Buffer.from(passphrase.normalize('NFC'), 'utf8');\n  var salt = hash256(address).slice(0, 4);\n  var N = scryptParams.N;\n  var r = scryptParams.r;\n  var p = scryptParams.p;\n  return {\n    secret: secret,\n    salt: salt,\n    N: N,\n    r: r,\n    p: p\n  };\n}\n\nfunction finishEncryptRaw(buffer, compressed, salt, scryptBuf) {\n  var derivedHalf1 = scryptBuf.slice(0, 32);\n  var derivedHalf2 = scryptBuf.slice(32, 64);\n  var xorBuf = xor(derivedHalf1, buffer);\n  var cipher = aes.createCipheriv('aes-256-ecb', derivedHalf2, NULL);\n  cipher.setAutoPadding(false);\n  cipher.end(xorBuf);\n  var cipherText = cipher.read(); // 0x01 | 0x42 | flagByte | salt (4) | cipherText (32)\n\n  var result = Buffer.allocUnsafe(7 + 32);\n  result.writeUInt8(0x01, 0);\n  result.writeUInt8(0x42, 1);\n  result.writeUInt8(compressed ? 0xe0 : 0xc0, 2);\n  salt.copy(result, 3);\n  cipherText.copy(result, 7);\n  return result;\n}\n\nexport function encryptRawAsync(buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var _prepareEncryptRaw, secret, salt, N, r, p, scryptBuf;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            scryptParams = scryptParams || SCRYPT_PARAMS;\n            networkParams = networkParams || NETWORK_PARAMS;\n            _prepareEncryptRaw = prepareEncryptRaw(buffer, compressed, passphrase, scryptParams, networkParams), secret = _prepareEncryptRaw.secret, salt = _prepareEncryptRaw.salt, N = _prepareEncryptRaw.N, r = _prepareEncryptRaw.r, p = _prepareEncryptRaw.p;\n            _context.next = 5;\n            return scrypt.async(secret, salt, N, r, p, 64, progressCallback, promiseInterval);\n\n          case 5:\n            scryptBuf = _context.sent;\n            return _context.abrupt(\"return\", finishEncryptRaw(buffer, compressed, salt, scryptBuf));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexport function encryptRaw(buffer, compressed, passphrase, progressCallback, scryptParams, networkParams) {\n  scryptParams = scryptParams || SCRYPT_PARAMS;\n  networkParams = networkParams || NETWORK_PARAMS;\n\n  var _prepareEncryptRaw2 = prepareEncryptRaw(buffer, compressed, passphrase, scryptParams, networkParams),\n      secret = _prepareEncryptRaw2.secret,\n      salt = _prepareEncryptRaw2.salt,\n      N = _prepareEncryptRaw2.N,\n      r = _prepareEncryptRaw2.r,\n      p = _prepareEncryptRaw2.p;\n\n  var scryptBuf = scrypt(secret, salt, N, r, p, 64, progressCallback);\n  return finishEncryptRaw(buffer, compressed, salt, scryptBuf);\n}\nexport function encryptAsync(buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = bs58check;\n            _context2.next = 3;\n            return encryptRawAsync(buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval, networkParams);\n\n          case 3:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", _context2.t0.encode.call(_context2.t0, _context2.t1));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\nexport function encrypt(buffer, compressed, passphrase, progressCallback, scryptParams, networkParams) {\n  return bs58check.encode(encryptRaw(buffer, compressed, passphrase, progressCallback, scryptParams, networkParams));\n}\n\nfunction prepareDecryptRaw(buffer, progressCallback, scryptParams) {\n  // 39 bytes: 2 bytes prefix, 37 bytes payload\n  if (buffer.length !== 39) {\n    throw new Error('Invalid BIP38 data length');\n  }\n\n  if (buffer.readUInt8(0) !== 0x01) {\n    throw new Error('Invalid BIP38 prefix');\n  } // check if BIP38 EC multiply\n\n\n  var type = buffer.readUInt8(1);\n\n  if (type === 0x43) {\n    return {\n      decryptEC: true\n    };\n  }\n\n  if (type !== 0x42) {\n    throw new Error('Invalid BIP38 type');\n  }\n\n  var flagByte = buffer.readUInt8(2);\n  var compressed = flagByte === 0xe0;\n\n  if (!compressed && flagByte !== 0xc0) {\n    throw new Error('Invalid BIP38 compression flag');\n  }\n\n  var N = scryptParams.N;\n  var r = scryptParams.r;\n  var p = scryptParams.p;\n  var salt = buffer.slice(3, 7);\n  return {\n    salt: salt,\n    compressed: compressed,\n    N: N,\n    r: r,\n    p: p\n  };\n}\n\nfunction finishDecryptRaw(buffer, salt, compressed, scryptBuf, networkParams) {\n  var derivedHalf1 = scryptBuf.slice(0, 32);\n  var derivedHalf2 = scryptBuf.slice(32, 64);\n  var privKeyBuf = buffer.slice(7, 7 + 32);\n  var decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, NULL);\n  decipher.setAutoPadding(false);\n  decipher.end(privKeyBuf);\n  var plainText = decipher.read();\n  var privateKey = xor(derivedHalf1, plainText); // verify salt matches address\n\n  var d = BigInteger.fromBuffer(privateKey);\n  var address = getAddress(d, compressed, networkParams);\n  var checksum = hash256(address).slice(0, 4); // The underlaying buffer will be different, we only compare the initial 4 values.\n\n  assert.strictEqual(true, salt.every(function (value, index) {\n    return value === checksum[index];\n  })); // assert.deepStrictEqual(salt, checksum);\n\n  return {\n    privateKey: privateKey,\n    compressed: compressed\n  };\n}\n\nexport function decryptRawAsync(buffer, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var _prepareDecryptRaw, salt, compressed, N, r, p, decryptEC, scryptBuf;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            scryptParams = scryptParams || SCRYPT_PARAMS;\n            networkParams = networkParams || NETWORK_PARAMS;\n            _prepareDecryptRaw = prepareDecryptRaw(buffer, progressCallback, scryptParams), salt = _prepareDecryptRaw.salt, compressed = _prepareDecryptRaw.compressed, N = _prepareDecryptRaw.N, r = _prepareDecryptRaw.r, p = _prepareDecryptRaw.p, decryptEC = _prepareDecryptRaw.decryptEC;\n\n            if (!(decryptEC === true)) {\n              _context3.next = 5;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", decryptECMultAsync(buffer, passphrase, progressCallback, scryptParams, promiseInterval));\n\n          case 5:\n            _context3.next = 7;\n            return scrypt.async(passphrase.normalize('NFC'), salt, N, r, p, 64, progressCallback, promiseInterval);\n\n          case 7:\n            scryptBuf = _context3.sent;\n            return _context3.abrupt(\"return\", finishDecryptRaw(buffer, salt, compressed, scryptBuf, networkParams));\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n} // some of the techniques borrowed from: https://github.com/pointbiz/bitaddress.org\n\nexport function decryptRaw(buffer, passphrase, progressCallback, scryptParams, networkParams) {\n  scryptParams = scryptParams || SCRYPT_PARAMS;\n  networkParams = networkParams || NETWORK_PARAMS;\n\n  var _prepareDecryptRaw2 = prepareDecryptRaw(buffer, progressCallback, scryptParams),\n      salt = _prepareDecryptRaw2.salt,\n      compressed = _prepareDecryptRaw2.compressed,\n      N = _prepareDecryptRaw2.N,\n      r = _prepareDecryptRaw2.r,\n      p = _prepareDecryptRaw2.p,\n      decryptEC = _prepareDecryptRaw2.decryptEC;\n\n  if (decryptEC === true) {\n    return decryptECMult(buffer, passphrase, progressCallback, scryptParams);\n  }\n\n  var scryptBuf = scrypt(passphrase.normalize('NFC'), salt, N, r, p, 64, progressCallback);\n  return finishDecryptRaw(buffer, salt, compressed, scryptBuf, networkParams);\n}\nexport function decryptAsync(text, passphrase, progressCallback, scryptParams, promiseInterval, networkParams) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", decryptRawAsync(bs58check.decode(text), passphrase, progressCallback, scryptParams, promiseInterval, networkParams));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\nexport function decrypt(text, passphrase, progressCallback, scryptParams, networkParams) {\n  return decryptRaw(bs58check.decode(text), passphrase, progressCallback, scryptParams, networkParams);\n}\n\nfunction prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams) {\n  var flag = buffer.readUInt8(1); // eslint-disable-next-line no-bitwise\n\n  var compressed = (flag & 0x20) !== 0; // eslint-disable-next-line no-bitwise\n\n  var hasLotSeq = (flag & 0x04) !== 0; // eslint-disable-next-line no-bitwise\n\n  assert.strictEqual(flag & 0x24, flag, 'Invalid private key.');\n  var addressHash = buffer.slice(2, 6);\n  var ownerEntropy = buffer.slice(6, 14);\n  var ownerSalt; // 4 bytes ownerSalt if 4 bytes lot/sequence\n\n  if (hasLotSeq) {\n    ownerSalt = ownerEntropy.slice(0, 4); // else, 8 bytes ownerSalt\n  } else {\n    ownerSalt = ownerEntropy;\n  }\n\n  var encryptedPart1 = buffer.slice(14, 22); // First 8 bytes\n\n  var encryptedPart2 = buffer.slice(22, 38); // 16 bytes\n\n  var N = scryptParams.N;\n  var r = scryptParams.r;\n  var p = scryptParams.p;\n  return {\n    addressHash: addressHash,\n    encryptedPart1: encryptedPart1,\n    encryptedPart2: encryptedPart2,\n    ownerEntropy: ownerEntropy,\n    ownerSalt: ownerSalt,\n    hasLotSeq: hasLotSeq,\n    compressed: compressed,\n    N: N,\n    r: r,\n    p: p\n  };\n}\n\nfunction getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq) {\n  var passFactor;\n\n  if (hasLotSeq) {\n    var hashTarget = Buffer.concat([preFactor, ownerEntropy]);\n    passFactor = hash256(hashTarget);\n  } else {\n    passFactor = preFactor;\n  }\n\n  var passInt = BigInteger.fromBuffer(passFactor);\n  return {\n    passInt: passInt,\n    passPoint: curve.G.multiply(passInt).getEncoded(true)\n  };\n}\n\nfunction finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed) {\n  var derivedHalf1 = seedBPass.slice(0, 32);\n  var derivedHalf2 = seedBPass.slice(32, 64);\n  var decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, Buffer.alloc(0));\n  decipher.setAutoPadding(false);\n  decipher.end(encryptedPart2);\n  var decryptedPart2 = decipher.read();\n  var tmp = xor(decryptedPart2, derivedHalf1.slice(16, 32));\n  var seedBPart2 = tmp.slice(8, 16);\n  var decipher2 = aes.createDecipheriv('aes-256-ecb', derivedHalf2, Buffer.alloc(0));\n  decipher2.setAutoPadding(false);\n  decipher2.write(encryptedPart1); // first 8 bytes\n\n  decipher2.end(tmp.slice(0, 8)); // last 8 bytes\n\n  var seedBPart1 = xor(decipher2.read(), derivedHalf1.slice(0, 16));\n  var seedB = Buffer.concat([seedBPart1, seedBPart2], 24);\n  var factorB = BigInteger.fromBuffer(hash256(seedB)); // d = passFactor * factorB (mod n)\n\n  var d = passInt.multiply(factorB).mod(curve.n);\n  return {\n    privateKey: d.toBuffer(32),\n    compressed: compressed\n  };\n}\n\nexport function decryptECMultAsync(buffer, passphrase, progressCallback, scryptParams, promiseInterval) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var _prepareDecryptECMult, addressHash, encryptedPart1, encryptedPart2, ownerEntropy, ownerSalt, hasLotSeq, compressed, N, r, p, preFactor, _getPassIntAndPoint, passInt, passPoint, seedBPass;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            buffer = buffer.slice(1); // FIXME: we can avoid this\n\n            passphrase = Buffer.from(passphrase.normalize('NFC'), 'utf8');\n            scryptParams = scryptParams || SCRYPT_PARAMS;\n            _prepareDecryptECMult = prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams), addressHash = _prepareDecryptECMult.addressHash, encryptedPart1 = _prepareDecryptECMult.encryptedPart1, encryptedPart2 = _prepareDecryptECMult.encryptedPart2, ownerEntropy = _prepareDecryptECMult.ownerEntropy, ownerSalt = _prepareDecryptECMult.ownerSalt, hasLotSeq = _prepareDecryptECMult.hasLotSeq, compressed = _prepareDecryptECMult.compressed, N = _prepareDecryptECMult.N, r = _prepareDecryptECMult.r, p = _prepareDecryptECMult.p;\n            _context5.next = 6;\n            return scrypt.async(passphrase, ownerSalt, N, r, p, 32, progressCallback, promiseInterval);\n\n          case 6:\n            preFactor = _context5.sent;\n            _getPassIntAndPoint = getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq), passInt = _getPassIntAndPoint.passInt, passPoint = _getPassIntAndPoint.passPoint;\n            _context5.next = 10;\n            return scrypt.async(passPoint, Buffer.concat([addressHash, ownerEntropy]), 1024, 1, 1, 64, undefined, promiseInterval);\n\n          case 10:\n            seedBPass = _context5.sent;\n            return _context5.abrupt(\"return\", finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed));\n\n          case 12:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\nexport function decryptECMult(buffer, passphrase, progressCallback, scryptParams) {\n  buffer = buffer.slice(1); // FIXME: we can avoid this\n\n  passphrase = Buffer.from(passphrase.normalize('NFC'), 'utf8');\n  scryptParams = scryptParams || SCRYPT_PARAMS;\n\n  var _prepareDecryptECMult2 = prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams),\n      addressHash = _prepareDecryptECMult2.addressHash,\n      encryptedPart1 = _prepareDecryptECMult2.encryptedPart1,\n      encryptedPart2 = _prepareDecryptECMult2.encryptedPart2,\n      ownerEntropy = _prepareDecryptECMult2.ownerEntropy,\n      ownerSalt = _prepareDecryptECMult2.ownerSalt,\n      hasLotSeq = _prepareDecryptECMult2.hasLotSeq,\n      compressed = _prepareDecryptECMult2.compressed,\n      N = _prepareDecryptECMult2.N,\n      r = _prepareDecryptECMult2.r,\n      p = _prepareDecryptECMult2.p;\n\n  var preFactor = scrypt(passphrase, ownerSalt, N, r, p, 32, progressCallback);\n\n  var _getPassIntAndPoint2 = getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq),\n      passInt = _getPassIntAndPoint2.passInt,\n      passPoint = _getPassIntAndPoint2.passPoint;\n\n  var seedBPass = scrypt(passPoint, Buffer.concat([addressHash, ownerEntropy]), 1024, 1, 1, 64);\n  return finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed);\n}\nexport function verify(text) {\n  var decoded = bs58check.decodeUnsafe(text);\n\n  if (!decoded) {\n    return false;\n  }\n\n  if (decoded.length !== 39) {\n    return false;\n  }\n\n  if (decoded.readUInt8(0) !== 0x01) {\n    return false;\n  }\n\n  var type = decoded.readUInt8(1);\n  var flag = decoded.readUInt8(2); // encrypted WIF\n\n  if (type === 0x42) {\n    if (flag !== 0xc0 && flag !== 0xe0) {\n      return false;\n    } // EC mult\n\n  } else if (type === 0x43) {\n    // eslint-disable-next-line no-bitwise\n    if (flag & ~0x24) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n} // module.exports = {\n//     decrypt,\n//     decryptECMult,\n//     decryptRaw,\n//     encrypt,\n//     encryptRaw,\n//     decryptAsync,\n//     decryptECMultAsync,\n//     decryptRawAsync,\n//     encryptAsync,\n//     encryptRawAsync,\n//     verify\n// };","map":null,"metadata":{},"sourceType":"module"}