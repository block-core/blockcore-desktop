{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { Identity, IdentityContainer } from '@models/identity';\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as bip32 from 'bip32';\nimport * as bip38 from '../../libs/bip38';\nimport * as city from 'city-lib';\nimport { Jws } from '../shared/jose';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./application-state.service\";\nimport * as i2 from \"./hub.service\";\nimport * as i3 from \"./authentication.service\";\nimport * as i4 from \"ngx-electron\";\nimport * as i5 from \"./storage.service\";\nexport class IdentityService {\n  appState;\n  hubService;\n  authentication;\n  electronService;\n  storage; // Initialize the BehaviorSubject with data from the localStorage. The subject holds the internal state of the identities.\n\n  identitiesSubject = new BehaviorSubject([]);\n  identitySubject = new BehaviorSubject(null);\n\n  get identityIndex() {\n    return this.storage.getNumber('Identity:Index', -1, true);\n  }\n\n  set identityIndex(value) {\n    this.storage.setValue('Identity:Index', value.toString(), true);\n  }\n\n  identityRoot;\n  identityExtPubKey;\n  seed;\n  identityNetwork = {\n    pubKeyHash: 55,\n    scriptHash: 117\n  };\n\n  constructor(appState, hubService, authentication, electronService, storage) {\n    this.appState = appState;\n    this.hubService = hubService;\n    this.authentication = authentication;\n    this.electronService = electronService;\n    this.storage = storage;\n    console.log('IdentityService created.');\n  }\n\n  identity$ = this.identitySubject.asObservable();\n  identities$ = this.identitiesSubject.asObservable();\n  lockedIdentities$ = this.identities$.pipe(map(items => items.filter(item => item.locked)));\n  publishedIdentities$ = this.identities$.pipe(map(items => items.filter(item => item.published)));\n\n  get identities() {\n    return this.identitiesSubject.getValue();\n  }\n\n  set identities(val) {\n    this.identitiesSubject.next(val);\n  }\n\n  get identity() {\n    return this.identitySubject.getValue();\n  }\n\n  set identity(val) {\n    this.identitySubject.next(val); // Persist the set identity as active identity.\n\n    this.storage.setValue('Identity', val.content.identifier, true);\n  }\n\n  refresh() {\n    this.identitiesSubject.next(this.identities);\n  }\n\n  load() {\n    this.identities = this.loadIdentities();\n    this.identitySubject.next(this.loadIdentity()); // Make sure we set the current identity index, and simply use the current length if value is missing from before.\n    // this.identityIndex = this.storage.getNumber('Identity:Index', this.identities.length, true);\n  }\n\n  ngOnDestroy() {\n    console.log('IdentityService instance destroyed.');\n  }\n\n  toBuffer(ab) {\n    const buf = Buffer.alloc(ab.byteLength);\n    const view = new Uint8Array(ab);\n\n    for (let i = 0; i < buf.length; ++i) {\n      buf[i] = view[i];\n    }\n\n    return buf;\n  }\n\n  verifyPassword(password) {\n    const decryptedKey = bip38.decrypt(this.seed.encryptedSeed, password, null, null, this.appState.networkParams);\n    console.log(decryptedKey);\n  }\n\n  unlock(path, password) {\n    // Read the seed from the file on disk.\n    const seed = this.electronService.ipcRenderer.sendSync('get-wallet-seed', path); // Keep a copy of the encrypted seed. For mobile mode, this will be available in the local storage / indexeddb.\n\n    this.seed = seed; // Descrypt the seed with the password provided on unlock (login).\n    // bip38.decryptAsync(seed.encryptedSeed, password, (decryptedKey) => {\n    // }, null, this.appState.networkParams);\n\n    const decryptedKey = bip38.decrypt(seed.encryptedSeed, password, null, null, this.appState.networkParams);\n    const chainCode = Buffer.from(seed.chainCode, 'base64'); // Dispose of this object, we don't want to keep the root extkey after initial login.\n\n    const masterNode = bip32.fromPrivateKey(decryptedKey.privateKey, chainCode, this.appState.networkDefinition); // eslint-disable-next-line @typescript-eslint/quotes\n\n    const identityRoot = masterNode.derivePath(\"m/302'\"); // Persist the identity node that we need to generate identities and keys for them.\n\n    this.identityRoot = identityRoot;\n    this.identityExtPubKey = identityRoot.neutered(); // Load identities after unlocking.\n\n    this.load();\n  }\n\n  getIdentityNode(index) {\n    return this.identityRoot.deriveHardened(index);\n  }\n\n  getKey(index) {\n    return this.identityRoot.deriveHardened(index);\n  }\n\n  sign(document, index) {\n    const identity = this.getIdentityNode(index);\n    const jwt = Jws.encode(document, identity);\n    return jwt;\n  }\n\n  create() {\n    // Get the next identity in line, based on what we have queries so far;\n    const identityNode = this.getIdentityNode(this.identityIndex + 1);\n    const identityId = this.getAddress(identityNode, this.identityNetwork);\n    const identity = new Identity();\n    identity.identifier = 'did:is:' + identityId;\n    identity.iat = Date.now();\n    const container = new IdentityContainer(identity);\n    container.header = null;\n    container.payload = null;\n    container.signature = null;\n    container.published = false;\n    container.publish = true;\n    container.index = this.identityIndex + 1; // We should not persist this new index until after we actually save it.\n\n    return container;\n  }\n  /** Add the identity locally and publish if both publish parameter is specified, and .publish on the identity. */\n\n\n  add(identity, publish = true) {\n    const index = this.identities.findIndex(t => t.content.identifier === identity.content.identifier); // Upgrade the version to what we currently support.\n\n    identity.version = 3;\n\n    if (index === -1) {\n      // Ensure we create a new array and don't modify existing.\n      this.identities = [...this.identities, identity]; // Increase the spent identity index.\n      // this.identityIndex++;\n    } else {\n      this.identities[index] = identity;\n    } // Now that we have added this new identity to the identities locally, make sure we register that the index is spent.\n\n\n    this.identityIndex = identity.index; // If publish is turned on, ensure we send our updated identity to one of the platform hubs.\n\n    if (publish && identity.publish) {\n      // Get the signature for the entity.\n      const jwt = this.sign(identity.content, identity.index);\n      const jwtValues = jwt.split('.');\n      identity.header = jwtValues[0];\n      identity.payload = jwtValues[1];\n      identity.signature = jwtValues[2];\n      const message = {\n        version: 4,\n        content: jwt\n      };\n      this.hubService.put(message, 'identity');\n    } // try {\n    //     const todo = await this.todosService\n    //         .create({ title, isCompleted: false })\n    //         .toPromise();\n    //     // we swap the local tmp record with the record from the server (id must be updated)\n    //     const index = this.todos.indexOf(this.todos.find(t => t.id === tmpId));\n    //     this.todos[index] = {\n    //         ...todo\n    //     }\n    //     this.todos = [...this.todos];\n    // } catch (e) {\n    //     // is server sends back an error, we revert the changes\n    //     console.error(e);\n    //     this.removeTodo(tmpId, false);\n    // }\n\n\n    this.saveIdentities();\n  }\n\n  remove(id) {\n    const identity = this.identities.find(t => t.content.identifier === id);\n    this.identities = this.identities.filter(i => i.content.identifier !== id);\n\n    if (identity.published) {\n      // Save to service, then update again.\n      try {\n        // Reset the identity to an empty entity.\n        identity.content = new Identity();\n        identity.content.identifier = id;\n        identity.content.iat = Date.now();\n        identity.content['@state'] = 999; // Get the signature for the entity.\n\n        const jwt = this.sign(identity.content, identity.index);\n        const jwtValues = jwt.split('.');\n        identity.header = jwtValues[0];\n        identity.payload = jwtValues[1];\n        identity.signature = jwtValues[2];\n        const message = {\n          version: 4,\n          content: jwt\n        };\n        this.hubService.put(message, 'identity');\n      } catch (e) {\n        console.error(e); // Add the identity back to the collection again, we did not successfully delete it.\n\n        this.identities = [...this.identities, identity];\n      }\n    }\n\n    this.saveIdentities();\n  }\n\n  get(id) {\n    const identity = this.identities.find(t => t.content.identifier === id);\n    return identity;\n  }\n\n  getImage(image) {\n    if (!image) {\n      image = 'data:image/png;base64,iVBORw0KGg' + 'oAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAU' + 'AAarVyFEAAAAASUVORK5CYII=';\n    }\n\n    return image;\n  }\n\n  find(id) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // const identityApiUrl = 'https://identity.city-chain.org/api/identity/' + id;\n      const baseUrl = _this.hubService.getHub().content.url;\n\n      console.log('baseUrl', baseUrl);\n      const identityApiUrl = baseUrl + '/api/identity/' + id;\n      console.log('identityApiUrl', identityApiUrl); // const identityApiUrl = 'https://identity.city-chain.org/api/identity/' + id;\n      // const identityApiUrl = 'http://localhost:4335/api/identity/' + id;\n\n      return yield _this.api(identityApiUrl);\n    })();\n  }\n  /** Get identities from localStorage. Only called during object creation. */\n\n\n  loadIdentities() {\n    // If there are no identities, populate with mock data.\n    let identities = this.storage.getJSON('Identities', '[]', true);\n\n    if (identities.length === 0) {\n      identities = this.initialize();\n    } // Return JSON serialized identities from localStorage.\n\n\n    return identities;\n  }\n  /** Get identity from localStorage. Only called during object creation. */\n\n\n  loadIdentity(id) {\n    const identityId = id || this.storage.getValue('Identity', null, true);\n    console.log('LOADING IDENTITY', identityId);\n    return this.identitiesSubject.getValue().find(i => i.content.identifier === identityId);\n  }\n\n  saveIdentities() {\n    // Save the latest value from the subject into local storage.\n    this.storage.setJSON('Identities', this.identities, true);\n  } // setIdentity(id: string) {\n  //     this.settings.identity = id;\n  //     const identity = this.getIdentity(id);\n  //     this.identitySubject.next(identity);\n  // }\n  // setIdentities(identities: Identity[]) {\n  //     // Persist the identities.\n  //     this.settings.identities = identities;\n  //     // Call all subscribers with updated identities.\n  //     this.identitiesSubject.next(identities);\n  // }\n\n\n  api(url) {\n    return fetch(url).then(response => {\n      if (!response.ok) {\n        throw new Error(response.statusText);\n      }\n\n      return response.json();\n    });\n  }\n\n  getAddress(node, network) {\n    return city.payments.p2pkh({\n      pubkey: node.publicKey,\n      network\n    }).address;\n  }\n\n  getId(index) {\n    const identity = this.getIdentityNode(index);\n    const address = this.getAddress(identity, this.identityNetwork);\n    return address;\n  }\n  /** Performs a query to find identity based on index number */\n\n\n  findByIndex(index) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let identity = null;\n\n      const identityNode = _this2.getIdentityNode(index);\n\n      const identityId = _this2.getAddress(identityNode, _this2.identityNetwork);\n\n      try {\n        identity = yield _this2.find(identityId);\n\n        if (identity) {\n          // Update local state fo the container.\n          identity.published = true;\n          identity.publish = true;\n          identity.index = index;\n\n          _this2.add(identity, false);\n        } // If the last found index is higher than previously known index height, make sure we save it.\n\n\n        if (index > _this2.identityIndex) {\n          _this2.identityIndex = index;\n        }\n      } catch (err) {// console.log('Identity find result: ', err);\n      }\n\n      return identity;\n    })();\n  }\n  /** Performs a scan of identities from index and number of coint. Returns true if anything is found. */\n  // async scan2(index: number, count: number) {\n  //     // Reset the scan index height.\n  //     // this.identityIndex = -1;\n  //     let found = false;\n  //     let lastFoundIndex = 0;\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  //     for (let i = index; i < count; i++) {\n  //         const identityNode = this.getIdentityNode(i);\n  //         const identityId = this.getAddress(identityNode, this.identityNetwork);\n  //         try {\n  //             const identity = await this.find(identityId);\n  //             if (identity) {\n  //                 this.add(identity);\n  //             }\n  //             console.log('FOUND!!!');\n  //             found = true;\n  //             lastFoundIndex = index;\n  //         }\n  //         catch (err) {\n  //             // console.log('Identity find result: ', err);\n  //         }\n  //     }\n  //     // If the last found index is higher than previously known index height, make sure we save it.\n  //     if (lastFoundIndex > this.identityIndex) {\n  //         this.identityIndex = lastFoundIndex;\n  //     }\n  //     return found;\n  // }\n\n\n  initialize() {\n    return []; // return [{\n    //     name: 'Sondre Bjellås',\n    //     shortName: 'Sondre Bjellås',\n    //     alias: 'sondreb',\n    //     title: 'Public',\n    //     id: 'PJZZYTPq2Uf6LJRkdgTVZ4xgRBi3vZmpdf',\n    //     published: true,\n    //     locked: false,\n    //     time: new Date()\n    // }, {\n    //     name: 'SondreB',\n    //     shortname: 'SondreB',\n    //     alias: 'sondre',\n    //     title: 'Personal, Gaming',\n    //     id: 'PHnT3Fx1EN5uMBbYBivjDdkke3n2pb5svd',\n    //     published: true,\n    //     locked: false,\n    //     time: new Date()\n    // }, {\n    //     name: 'Sondre Bjellås',\n    //     shortname: 'Sondre Bjellås',\n    //     alias: 'citychainfoundation',\n    //     title: 'CTO, City Chain Foundation',\n    //     id: 'PXdMWVDaG1kmqbQX5JdsE5m4HFnRVxoqHf',\n    //     published: true,\n    //     locked: false,\n    //     time: new Date()\n    // }, {\n    //     name: 'New Identity',\n    //     shortname: 'New Identity',\n    //     alias: null,\n    //     title: 'Random',\n    //     id: 'PH99VjuZKX36CoKkXE4Z87BPKt2c4FyTwZ',\n    //     published: false,\n    //     locked: false,\n    //     time: new Date()\n    // }, {\n    //     name: 'Locked',\n    //     shortname: 'Locked',\n    //     alias: null,\n    //     title: '?',\n    //     id: 'PMzHABeaLVHP7kLDYFeHkE1CZaeS8wXvxv',\n    //     published: true,\n    //     locked: true,\n    //     time: new Date()\n    // }, {\n    //     name: 'Locked',\n    //     shortname: 'Locked',\n    //     alias: null,\n    //     title: '?',\n    //     id: 'PFfMFoJWHmHuQWfxoAmjgq7cqVxC9xTXfr',\n    //     published: false,\n    //     locked: true,\n    //     time: new Date()\n    // }];\n  }\n\n  static ɵfac = function IdentityService_Factory(t) {\n    return new (t || IdentityService)(i0.ɵɵinject(i1.ApplicationStateService), i0.ɵɵinject(i2.HubService), i0.ɵɵinject(i3.AuthenticationService), i0.ɵɵinject(i4.ElectronService), i0.ɵɵinject(i5.StorageService));\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: IdentityService,\n    factory: IdentityService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":null,"metadata":{},"sourceType":"module"}