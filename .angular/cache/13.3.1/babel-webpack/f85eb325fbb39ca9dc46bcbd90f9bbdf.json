{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { WalletInfo } from '../classes/wallet-info';\nimport { TransactionInfo } from '../classes/transaction-info';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./api.service\";\nimport * as i2 from \"./global.service\";\nimport * as i3 from \"./logger.service\";\nimport * as i4 from \"./application-state.service\";\nexport class WalletService {\n  apiService;\n  globalService;\n  log;\n  appState;\n  static singletonInstance;\n  walletBalanceSubscription;\n  walletHistorySubscription;\n  stakingInfoSubscription;\n  generalWalletInfoSubscription;\n  /** Set to true to make the wallet update wallet status at higher frequency. Set to false when high refresh rate is not needed. */\n\n  active = false;\n  walletName;\n  coinUnit;\n  confirmedBalance;\n  unconfirmedBalance;\n  transactionArray;\n  stakingEnabled;\n  stakingActive;\n  stakingWeight;\n  lastBlockSyncedHeight;\n  netStakingWeight;\n  expectedTime;\n  dateTime;\n  isStarting;\n  isStopping;\n  hasBalance = false;\n  percentSyncedNumber = 0;\n  percentSynced = '0%';\n  generalInfo;\n  stakingInfo;\n  activeWallet; // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle, id-blacklist, id-match\n\n  _history = new Subject();\n  history$ = this._history.asObservable();\n\n  constructor(apiService, globalService, log, appState) {\n    this.apiService = apiService;\n    this.globalService = globalService;\n    this.log = log;\n    this.appState = appState;\n\n    if (!WalletService.singletonInstance) {\n      WalletService.singletonInstance = this;\n    }\n\n    return WalletService.singletonInstance;\n  }\n\n  get walletMode() {\n    return localStorage.getItem('Settings:WalletMode') || 'multi';\n  }\n\n  get isMultiAddressMode() {\n    return this.walletMode !== 'single';\n  }\n\n  get isSingleAddressMode() {\n    return this.walletMode === 'single';\n  }\n\n  start() {\n    this.walletName = this.globalService.getWalletName();\n    this.coinUnit = this.globalService.getCoinUnit();\n    this.startSubscriptions();\n  }\n\n  stop() {\n    this.walletName = '';\n    this.coinUnit = '';\n    this.confirmedBalance = null;\n    this.unconfirmedBalance = null;\n    this.active = false;\n    this.transactionArray = [];\n    this.cancelSubscriptions();\n  }\n\n  startStaking(password) {\n    this.isStarting = true;\n    this.isStopping = false;\n    const walletData = {\n      name: this.globalService.getWalletName(),\n      password\n    };\n    this.apiService.startStaking(walletData).subscribe(response => {\n      this.log.info('Start staking:', response);\n      this.stakingEnabled = true;\n      this.isStarting = false;\n    }, error => {\n      this.isStarting = false;\n      this.stakingEnabled = false;\n      this.apiService.handleException(error);\n    });\n  }\n\n  stopStaking() {\n    this.isStopping = true;\n    this.isStarting = false;\n    this.apiService.stopStaking().subscribe(response => {\n      this.log.info('Stop staking:', response);\n      this.stakingEnabled = false;\n    }, error => {\n      this.apiService.handleException(error);\n    });\n  }\n\n  resync() {\n    this.apiService.removeHistory(this.globalService.getWalletName()).subscribe(() => {\n      // Clear the transaction history so UI updates.\n      this.transactionArray = [];\n\n      this._history.next(this.transactionArray);\n    }, error => {\n      console.error(error);\n    });\n  }\n\n  cancelSubscriptions() {\n    if (this.walletBalanceSubscription) {\n      this.walletBalanceSubscription.unsubscribe();\n    }\n\n    if (this.walletHistorySubscription) {\n      this.walletHistorySubscription.unsubscribe();\n    }\n\n    if (this.stakingInfoSubscription) {\n      this.stakingInfoSubscription.unsubscribe();\n    }\n\n    if (this.generalWalletInfoSubscription) {\n      this.generalWalletInfoSubscription.unsubscribe();\n    }\n  }\n\n  startSubscriptions() {\n    this.getWalletBalance();\n    this.getHistory();\n\n    if (this.appState.activeChain.pos) {\n      this.getStakingInfo();\n    }\n\n    this.getGeneralWalletInfo();\n  }\n  /** Called to cancel and restart all subscriptions. */\n\n\n  reactivate() {\n    this.cancelSubscriptions();\n    this.startSubscriptions();\n  }\n\n  getWalletBalance() {\n    const walletInfo = new WalletInfo(this.globalService.getWalletName());\n    this.walletBalanceSubscription = this.apiService.getWalletBalance(walletInfo).subscribe(response => {\n      this.log.info('Get wallet balance:', response);\n      const balanceResponse = response;\n      this.confirmedBalance = balanceResponse.balances[0].amountConfirmed;\n      this.unconfirmedBalance = balanceResponse.balances[0].amountUnconfirmed;\n\n      if (this.confirmedBalance + this.unconfirmedBalance > 0) {\n        this.hasBalance = true;\n      } else {\n        this.hasBalance = false;\n      }\n    }, error => {\n      this.apiService.handleException(error); // this.reactivate();\n    });\n  }\n\n  getHistory() {\n    const walletInfo = new WalletInfo(this.globalService.getWalletName());\n    let historyResponse;\n    this.walletHistorySubscription = this.apiService.getWalletHistory(walletInfo).subscribe(response => {\n      if (!!response.history && response.history[0].transactionsHistory.length > 0) {\n        historyResponse = response.history[0].transactionsHistory;\n        this.getTransactionInfo(historyResponse);\n      }\n    }, error => {\n      this.apiService.handleException(error); // this.reactivate();\n    });\n  }\n\n  getTransactionInfo(transactions) {\n    this.transactionArray = [];\n\n    for (const transaction of transactions) {\n      let transactionType;\n\n      if (transaction.type === 'send') {\n        transactionType = 'sent';\n      } else if (transaction.type === 'received') {\n        transactionType = 'received';\n      } else if (transaction.type === 'staked') {\n        transactionType = 'staked';\n      }\n\n      const transactionId = transaction.id;\n      const transactionAmount = transaction.amount;\n      let transactionFee;\n\n      if (transaction.fee) {\n        transactionFee = transaction.fee;\n      } else {\n        transactionFee = 0;\n      }\n\n      const transactionConfirmedInBlock = transaction.confirmedInBlock;\n      const transactionTimestamp = transaction.timestamp;\n      this.transactionArray.push(new TransactionInfo(transactionType, transactionId, transactionAmount, transactionFee, transactionConfirmedInBlock, transactionTimestamp));\n    }\n\n    this._history.next(this.transactionArray);\n  } // \"{\"enabled\":true,\"staking\":true,\"errors\":null,\"currentBlockSize\":151,\"currentBlockTx\":1,\"pooledTx\":0,\"difficulty\":143238.23770936558,\"searchInterval\":16,\"weight\":173749360622480,\"netStakeWeight\":16433501129748,\"expectedTime\":6}\"\n\n\n  getStakingInfo() {\n    this.stakingInfoSubscription = this.apiService.getStakingInfo().subscribe(response => {\n      this.log.info('Get staking info:', response);\n      const stakingResponse = response;\n      this.stakingInfo = stakingResponse;\n      this.stakingEnabled = stakingResponse.enabled;\n      this.stakingActive = stakingResponse.staking;\n      this.stakingWeight = stakingResponse.weight;\n      this.netStakingWeight = stakingResponse.netStakeWeight;\n      this.expectedTime = stakingResponse.expectedTime;\n      this.dateTime = this.secondsToString(this.expectedTime);\n\n      if (this.stakingActive) {\n        this.isStarting = false;\n      } else {\n        this.isStopping = false;\n      }\n    }, error => {\n      this.apiService.handleException(error); // this.reactivate();\n    });\n  }\n\n  getGeneralWalletInfo() {\n    const walletInfo = new WalletInfo(this.globalService.getWalletName());\n    this.generalWalletInfoSubscription = this.apiService.getGeneralInfoTyped(walletInfo).subscribe(response => {\n      this.log.info('Get wallet info:', response);\n      this.generalInfo = response;\n      this.lastBlockSyncedHeight = this.generalInfo.lastBlockSyncedHeight; // Translate the epoch value to a proper JavaScript date.\n\n      this.generalInfo.creationTime = new Date(this.generalInfo.creationTime * 1000);\n\n      if (this.generalInfo.lastBlockSyncedHeight) {\n        this.percentSyncedNumber = this.generalInfo.lastBlockSyncedHeight / this.generalInfo.chainTip * 100;\n\n        if (this.percentSyncedNumber.toFixed(0) === '100' && this.generalInfo.lastBlockSyncedHeight !== this.generalInfo.chainTip) {\n          this.percentSyncedNumber = 99;\n        }\n\n        this.percentSynced = this.percentSyncedNumber.toFixed(0) + '%';\n      }\n    }, error => {\n      this.apiService.handleException(error); // this.reactivate();\n    });\n  }\n\n  secondsToString(seconds) {\n    const numDays = Math.floor(seconds / 86400);\n    const numHours = Math.floor(seconds % 86400 / 3600);\n    const numMinutes = Math.floor(seconds % 86400 % 3600 / 60);\n    const numSeconds = seconds % 86400 % 3600 % 60;\n    let dateString = '';\n\n    if (numDays > 0) {\n      if (numDays > 1) {\n        dateString += numDays + ' days ';\n      } else {\n        dateString += numDays + ' day ';\n      }\n    }\n\n    if (numHours > 0) {\n      if (numHours > 1) {\n        dateString += numHours + ' hours ';\n      } else {\n        dateString += numHours + ' hour ';\n      }\n    }\n\n    if (numMinutes > 0) {\n      if (numMinutes > 1) {\n        dateString += numMinutes + ' minutes ';\n      } else {\n        dateString += numMinutes + ' minute ';\n      }\n    }\n\n    if (dateString === '') {\n      // If dateString is empty at this time, we'll append the seconds. Normally we don't care to show the seconds.\n      dateString = numSeconds + ' seconds';\n    }\n\n    return dateString;\n  }\n\n  static ɵfac = function WalletService_Factory(t) {\n    return new (t || WalletService)(i0.ɵɵinject(i1.ApiService), i0.ɵɵinject(i2.GlobalService), i0.ɵɵinject(i3.Logger), i0.ɵɵinject(i4.ApplicationStateService));\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: WalletService,\n    factory: WalletService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":null,"metadata":{},"sourceType":"module"}