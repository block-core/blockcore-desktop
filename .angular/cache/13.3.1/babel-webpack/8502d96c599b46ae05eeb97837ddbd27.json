{"ast":null,"code":"import base64url from 'base64url'; // Should we replicate this code to avoid dependency? It's a very simple utility.\n\nimport utf8 from 'utf8';\nimport * as city from 'city-lib';\nimport * as blockcoreMessage from '@blockcore/message';\n/*\r\n    Blockcore-Jose-JS\r\n    Blockcore Javascript Object Signing and Encryption (JOSE) for JavaScript\r\n\r\n    NOTE: Currently only supports ES256K, refer to other implementations (e.g. jsrsasign) for additional algorithms.\r\n\r\n    - Encodes either a JavaScript object or string into a JWT.\r\n    - Supports requirement of signature, and reading the key from \"kid\" in header.\r\n\r\n    Future improvements:\r\n\r\n    - JSON Web Encryption (JWE)\r\n    - JSON Web Key (JWK)\r\n    - JSON Web Key Set (JWKS)\r\n    - JSON Web Signature (JWS) (DONE)\r\n    - JSON Web Token (JWT)\r\n\r\n    .NET version: https://github.com/block-core/blockcore-jose\r\n*/\n\nexport class Jws {\n  static identityNetwork = {\n    pubKeyHash: 55,\n    scriptHash: 117\n  };\n\n  static encode(payload, identity) {\n    let payloadText;\n\n    if (typeof payload === 'string' || payload instanceof String) {\n      payloadText = payload;\n    } else {\n      payloadText = JSON.stringify(payload);\n    }\n\n    const publicKey = this.getAddress(identity, this.identityNetwork);\n    const header = {\n      alg: 'ES256K',\n      typ: 'JWT',\n      kid: publicKey\n    };\n    const headerText = JSON.stringify(header); // Header is first encoded to UTF-8 then base64url encoded, while payload is encoded directly to base64url. This is according to the specification.\n\n    let message = base64url.encode(utf8.encode(headerText)) + '.' + base64url.encode(payloadText);\n    const signature = blockcoreMessage.sign(message, identity.privateKey, true, '');\n    message += '.' + base64url.encode(signature);\n    return message;\n  }\n\n  static sign(payload, secret) {\n    let payloadText;\n\n    if (typeof payload === 'string' || payload instanceof String) {\n      payloadText = payload;\n    } else {\n      payloadText = JSON.stringify(payload);\n    }\n\n    const header = {\n      alg: 'ES256K',\n      typ: 'JWT',\n      kid: secret\n    };\n    const headerText = JSON.stringify(header); // Header is first encoded to UTF-8 then base64url encoded, while payload is encoded directly to base64url. This is according to the specification.\n\n    const message = base64url.encode(utf8.encode(headerText)) + '.' + base64url.encode(payloadText) + '.';\n    return message;\n  }\n\n  static decode(payload, header = false, requireSignature = false) {\n    const matchResult = payload.match(/^([^.]+)\\.([^.]+)\\.([^.]+)$/);\n\n    if (matchResult == null) {\n      throw new Error('JWS payload is not in correct format of \\'Header.Payload.Signature\\'.');\n    }\n\n    const values = payload.split('.'); // Validate that there is a signature and that it's valid.\n\n    if (requireSignature === true) {}\n\n    if (header === true) {\n      const decoded = base64url.decode(utf8.decode(values[0]));\n      const json = JSON.parse(decoded);\n      return json;\n    } else {\n      const decoded = base64url.decode(values[1]);\n      const json = JSON.parse(decoded);\n      return json;\n    }\n  }\n\n  static getAddress(node, network) {\n    return city.payments.p2pkh({\n      pubkey: node.publicKey,\n      network\n    }).address;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}