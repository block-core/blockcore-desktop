{"ast":null,"code":"import _defineProperty from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _toConsumableArray from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _objectSpread from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\objectSpread2.js\";\nimport _createForOfIteratorHelper from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _slicedToArray from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nvar e = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : global,\n    t = Object.keys,\n    n = Array.isArray;\n\nfunction r(e, n) {\n  return \"object\" != typeof n || t(n).forEach(function (t) {\n    e[t] = n[t];\n  }), e;\n}\n\n\"undefined\" == typeof Promise || e.Promise || (e.Promise = Promise);\nvar s = Object.getPrototypeOf,\n    i = {}.hasOwnProperty;\n\nfunction o(e, t) {\n  return i.call(e, t);\n}\n\nfunction a(e, n) {\n  \"function\" == typeof n && (n = n(s(e))), (\"undefined\" == typeof Reflect ? t : Reflect.ownKeys)(n).forEach(function (t) {\n    l(e, t, n[t]);\n  });\n}\n\nvar u = Object.defineProperty;\n\nfunction l(e, t, n, s) {\n  u(e, t, r(n && o(n, \"get\") && \"function\" == typeof n.get ? {\n    get: n.get,\n    set: n.set,\n    configurable: !0\n  } : {\n    value: n,\n    configurable: !0,\n    writable: !0\n  }, s));\n}\n\nfunction c(e) {\n  return {\n    from: function from(t) {\n      return e.prototype = Object.create(t.prototype), l(e.prototype, \"constructor\", e), {\n        extend: a.bind(null, e.prototype)\n      };\n    }\n  };\n}\n\nvar h = Object.getOwnPropertyDescriptor;\n\nfunction d(e, t) {\n  var n;\n  return h(e, t) || (n = s(e)) && d(n, t);\n}\n\nvar f = [].slice;\n\nfunction p(e, t, n) {\n  return f.call(e, t, n);\n}\n\nfunction y(e, t) {\n  return t(e);\n}\n\nfunction m(e) {\n  if (!e) throw new Error(\"Assertion Failed\");\n}\n\nfunction v(t) {\n  e.setImmediate ? setImmediate(t) : setTimeout(t, 0);\n}\n\nfunction g(e, t) {\n  return e.reduce(function (e, n, r) {\n    var s = t(n, r);\n    return s && (e[s[0]] = s[1]), e;\n  }, {});\n}\n\nfunction b(e, t) {\n  if (o(e, t)) return e[t];\n  if (!t) return e;\n\n  if (\"string\" != typeof t) {\n    for (var n = [], r = 0, s = t.length; r < s; ++r) {\n      var i = b(e, t[r]);\n      n.push(i);\n    }\n\n    return n;\n  }\n\n  var a = t.indexOf(\".\");\n\n  if (-1 !== a) {\n    var u = e[t.substr(0, a)];\n    return void 0 === u ? void 0 : b(u, t.substr(a + 1));\n  }\n}\n\nfunction _(e, t, r) {\n  if (e && void 0 !== t && (!(\"isFrozen\" in Object) || !Object.isFrozen(e))) if (\"string\" != typeof t && \"length\" in t) {\n    m(\"string\" != typeof r && \"length\" in r);\n\n    for (var s = 0, i = t.length; s < i; ++s) {\n      _(e, t[s], r[s]);\n    }\n  } else {\n    var o = t.indexOf(\".\");\n\n    if (-1 !== o) {\n      var a = t.substr(0, o),\n          u = t.substr(o + 1);\n      if (\"\" === u) void 0 === r ? n(e) && !isNaN(parseInt(a)) ? e.splice(a, 1) : delete e[a] : e[a] = r;else {\n        var l = e[a];\n        l || (l = e[a] = {}), _(l, u, r);\n      }\n    } else void 0 === r ? n(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r;\n  }\n}\n\nfunction w(e) {\n  var t = {};\n\n  for (var n in e) {\n    o(e, n) && (t[n] = e[n]);\n  }\n\n  return t;\n}\n\nvar x = [].concat;\n\nfunction k(e) {\n  return x.apply([], e);\n}\n\nvar E = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(k([8, 16, 32, 64].map(function (e) {\n  return [\"Int\", \"Uint\", \"Float\"].map(function (t) {\n    return t + e + \"Array\";\n  });\n}))).filter(function (t) {\n  return e[t];\n}),\n    P = E.map(function (t) {\n  return e[t];\n});\ng(E, function (e) {\n  return [e, !0];\n});\nvar K = null;\n\nfunction O(e) {\n  K = \"undefined\" != typeof WeakMap && new WeakMap();\n  var t = S(e);\n  return K = null, t;\n}\n\nfunction S(e) {\n  if (!e || \"object\" != typeof e) return e;\n  var t = K && K.get(e);\n  if (t) return t;\n\n  if (n(e)) {\n    t = [], K && K.set(e, t);\n\n    for (var r = 0, i = e.length; r < i; ++r) {\n      t.push(S(e[r]));\n    }\n  } else if (P.indexOf(e.constructor) >= 0) t = e;else {\n    var _n2 = s(e);\n\n    for (var a in t = _n2 === Object.prototype ? {} : Object.create(_n2), K && K.set(e, t), e) {\n      o(e, a) && (t[a] = S(e[a]));\n    }\n  }\n\n  return t;\n}\n\nvar _ref = {},\n    A = _ref.toString;\n\nfunction C(e) {\n  return A.call(e).slice(8, -1);\n}\n\nvar j = \"undefined\" != typeof Symbol ? Symbol.iterator : \"@@iterator\",\n    D = \"symbol\" == typeof j ? function (e) {\n  var t;\n  return null != e && (t = e[j]) && t.apply(e);\n} : function () {\n  return null;\n},\n    I = {};\n\nfunction B(e) {\n  var t, r, s, i;\n\n  if (1 === arguments.length) {\n    if (n(e)) return e.slice();\n    if (this === I && \"string\" == typeof e) return [e];\n\n    if (i = D(e)) {\n      for (r = []; !(s = i.next()).done;) {\n        r.push(s.value);\n      }\n\n      return r;\n    }\n\n    if (null == e) return [e];\n\n    if (\"number\" == typeof (t = e.length)) {\n      for (r = new Array(t); t--;) {\n        r[t] = e[t];\n      }\n\n      return r;\n    }\n\n    return [e];\n  }\n\n  for (t = arguments.length, r = new Array(t); t--;) {\n    r[t] = arguments[t];\n  }\n\n  return r;\n}\n\nvar T = \"undefined\" != typeof Symbol ? function (e) {\n  return \"AsyncFunction\" === e[Symbol.toStringTag];\n} : function () {\n  return !1;\n};\nvar R = \"undefined\" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nfunction F(e, t) {\n  R = e, M = t;\n}\n\nvar M = function M() {\n  return !0;\n};\n\nvar N = !new Error(\"\").stack;\n\nfunction q() {\n  if (N) try {\n    throw q.arguments, new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\n\nfunction $(e, t) {\n  var n = e.stack;\n  return n ? (t = t || 0, 0 === n.indexOf(e.name) && (t += (e.name + e.message).split(\"\\n\").length), n.split(\"\\n\").slice(t).filter(M).map(function (e) {\n    return \"\\n\" + e;\n  }).join(\"\")) : \"\";\n}\n\nvar U = [\"Unknown\", \"Constraint\", \"Data\", \"TransactionInactive\", \"ReadOnly\", \"Version\", \"NotFound\", \"InvalidState\", \"InvalidAccess\", \"Abort\", \"Timeout\", \"QuotaExceeded\", \"Syntax\", \"DataClone\"],\n    L = [\"Modify\", \"Bulk\", \"OpenFailed\", \"VersionChange\", \"Schema\", \"Upgrade\", \"InvalidTable\", \"MissingAPI\", \"NoSuchDatabase\", \"InvalidArgument\", \"SubTransaction\", \"Unsupported\", \"Internal\", \"DatabaseClosed\", \"PrematureCommit\", \"ForeignAwait\"].concat(U),\n    V = {\n  VersionChanged: \"Database version changed by other database connection\",\n  DatabaseClosed: \"Database has been closed\",\n  Abort: \"Transaction aborted\",\n  TransactionInactive: \"Transaction has already completed or failed\",\n  MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\n\nfunction W(e, t) {\n  this._e = q(), this.name = e, this.message = t;\n}\n\nfunction Y(e, t) {\n  return e + \". Errors: \" + Object.keys(t).map(function (e) {\n    return t[e].toString();\n  }).filter(function (e, t, n) {\n    return n.indexOf(e) === t;\n  }).join(\"\\n\");\n}\n\nfunction z(e, t, n, r) {\n  this._e = q(), this.failures = t, this.failedKeys = r, this.successCount = n, this.message = Y(e, t);\n}\n\nfunction G(e, t) {\n  this._e = q(), this.name = \"BulkError\", this.failures = Object.keys(t).map(function (e) {\n    return t[e];\n  }), this.failuresByPos = t, this.message = Y(e, t);\n}\n\nc(W).from(Error).extend({\n  stack: {\n    get: function get() {\n      return this._stack || (this._stack = this.name + \": \" + this.message + $(this._e, 2));\n    }\n  },\n  toString: function toString() {\n    return this.name + \": \" + this.message;\n  }\n}), c(z).from(W), c(G).from(W);\nvar H = L.reduce(function (e, t) {\n  return e[t] = t + \"Error\", e;\n}, {});\nvar Q = W;\nvar X = L.reduce(function (e, t) {\n  var n = t + \"Error\";\n\n  function r(e, r) {\n    this._e = q(), this.name = n, e ? \"string\" == typeof e ? (this.message = \"\".concat(e).concat(r ? \"\\n \" + r : \"\"), this.inner = r || null) : \"object\" == typeof e && (this.message = \"\".concat(e.name, \" \").concat(e.message), this.inner = e) : (this.message = V[t] || n, this.inner = null);\n  }\n\n  return c(r).from(Q), e[t] = r, e;\n}, {});\nX.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;\nvar J = U.reduce(function (e, t) {\n  return e[t + \"Error\"] = X[t], e;\n}, {});\nvar Z = L.reduce(function (e, t) {\n  return -1 === [\"Syntax\", \"Type\", \"Range\"].indexOf(t) && (e[t + \"Error\"] = X[t]), e;\n}, {});\n\nfunction ee() {}\n\nfunction te(e) {\n  return e;\n}\n\nfunction ne(e, t) {\n  return null == e || e === te ? t : function (n) {\n    return t(e(n));\n  };\n}\n\nfunction re(e, t) {\n  return function () {\n    e.apply(this, arguments), t.apply(this, arguments);\n  };\n}\n\nfunction se(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n    void 0 !== n && (arguments[0] = n);\n    var r = this.onsuccess,\n        s = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var i = t.apply(this, arguments);\n    return r && (this.onsuccess = this.onsuccess ? re(r, this.onsuccess) : r), s && (this.onerror = this.onerror ? re(s, this.onerror) : s), void 0 !== i ? i : n;\n  };\n}\n\nfunction ie(e, t) {\n  return e === ee ? t : function () {\n    e.apply(this, arguments);\n    var n = this.onsuccess,\n        r = this.onerror;\n    this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? re(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? re(r, this.onerror) : r);\n  };\n}\n\nfunction oe(e, t) {\n  return e === ee ? t : function (n) {\n    var s = e.apply(this, arguments);\n    r(n, s);\n    var i = this.onsuccess,\n        o = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var a = t.apply(this, arguments);\n    return i && (this.onsuccess = this.onsuccess ? re(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? re(o, this.onerror) : o), void 0 === s ? void 0 === a ? void 0 : a : r(s, a);\n  };\n}\n\nfunction ae(e, t) {\n  return e === ee ? t : function () {\n    return !1 !== t.apply(this, arguments) && e.apply(this, arguments);\n  };\n}\n\nfunction ue(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n\n    if (n && \"function\" == typeof n.then) {\n      for (var r = this, s = arguments.length, i = new Array(s); s--;) {\n        i[s] = arguments[s];\n      }\n\n      return n.then(function () {\n        return t.apply(r, i);\n      });\n    }\n\n    return t.apply(this, arguments);\n  };\n}\n\nZ.ModifyError = z, Z.DexieError = W, Z.BulkError = G;\nvar le = {};\n\nvar _ref2 = \"undefined\" == typeof Promise ? [] : function () {\n  var e = Promise.resolve();\n  if (\"undefined\" == typeof crypto || !crypto.subtle) return [e, s(e), e];\n  var t = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n  return [t, s(t), e];\n}(),\n    _ref3 = _slicedToArray(_ref2, 3),\n    ce = _ref3[0],\n    he = _ref3[1],\n    de = _ref3[2],\n    fe = he && he.then,\n    pe = ce && ce.constructor,\n    ye = !!de;\n\nvar me = !1,\n    ve = de ? function () {\n  de.then(qe);\n} : e.setImmediate ? setImmediate.bind(null, qe) : e.MutationObserver ? function () {\n  var e = document.createElement(\"div\");\n  new MutationObserver(function () {\n    qe(), e = null;\n  }).observe(e, {\n    attributes: !0\n  }), e.setAttribute(\"i\", \"1\");\n} : function () {\n  setTimeout(qe, 0);\n},\n    ge = function ge(e, t) {\n  Oe.push([e, t]), _e && (ve(), _e = !1);\n},\n    be = !0,\n    _e = !0,\n    we = [],\n    xe = [],\n    ke = null,\n    Ee = te,\n    Pe = {\n  id: \"global\",\n  global: !0,\n  ref: 0,\n  unhandleds: [],\n  onunhandled: ct,\n  pgp: !1,\n  env: {},\n  finalize: function finalize() {\n    this.unhandleds.forEach(function (e) {\n      try {\n        ct(e[0], e[1]);\n      } catch (e) {}\n    });\n  }\n},\n    Ke = Pe,\n    Oe = [],\n    Se = 0,\n    Ae = [];\n\nfunction Ce(e) {\n  if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n  this._listeners = [], this.onuncatched = ee, this._lib = !1;\n  var t = this._PSD = Ke;\n\n  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), \"function\" != typeof e) {\n    if (e !== le) throw new TypeError(\"Not a function\");\n    return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Be(this, this._value));\n  }\n\n  this._state = null, this._value = null, ++t.ref, Ie(this, e);\n}\n\nvar je = {\n  get: function get() {\n    var e = Ke,\n        t = Qe;\n\n    function n(n, r) {\n      var _this = this;\n\n      var s = !e.global && (e !== Ke || t !== Qe);\n      var i = s && !et();\n      var o = new Ce(function (t, o) {\n        Re(_this, new De(ut(n, e, s, i), ut(r, e, s, i), t, o, e));\n      });\n      return R && Ne(o, this), o;\n    }\n\n    return n.prototype = le, n;\n  },\n  set: function set(e) {\n    l(this, \"then\", e && e.prototype === le ? je : {\n      get: function get() {\n        return e;\n      },\n      set: je.set\n    });\n  }\n};\n\nfunction De(e, t, n, r, s) {\n  this.onFulfilled = \"function\" == typeof e ? e : null, this.onRejected = \"function\" == typeof t ? t : null, this.resolve = n, this.reject = r, this.psd = s;\n}\n\nfunction Ie(e, t) {\n  try {\n    t(function (t) {\n      if (null === e._state) {\n        if (t === e) throw new TypeError(\"A promise cannot be resolved with itself.\");\n        var n = e._lib && $e();\n        t && \"function\" == typeof t.then ? Ie(e, function (e, n) {\n          t instanceof Ce ? t._then(e, n) : t.then(e, n);\n        }) : (e._state = !0, e._value = t, Te(e)), n && Ue();\n      }\n    }, Be.bind(null, e));\n  } catch (t) {\n    Be(e, t);\n  }\n}\n\nfunction Be(e, t) {\n  if (xe.push(t), null === e._state) {\n    var n = e._lib && $e();\n    t = Ee(t), e._state = !1, e._value = t, R && null !== t && \"object\" == typeof t && !t._promise && function (e, t, n) {\n      try {\n        e.apply(null, n);\n      } catch (e) {\n        t && t(e);\n      }\n    }(function () {\n      var n = d(t, \"stack\");\n      t._promise = e, l(t, \"stack\", {\n        get: function get() {\n          return me ? n && (n.get ? n.get.apply(t) : n.value) : e.stack;\n        }\n      });\n    }), function (e) {\n      we.some(function (t) {\n        return t._value === e._value;\n      }) || we.push(e);\n    }(e), Te(e), n && Ue();\n  }\n}\n\nfunction Te(e) {\n  var t = e._listeners;\n  e._listeners = [];\n\n  for (var n = 0, r = t.length; n < r; ++n) {\n    Re(e, t[n]);\n  }\n\n  var s = e._PSD;\n  --s.ref || s.finalize(), 0 === Se && (++Se, ge(function () {\n    0 == --Se && Le();\n  }, []));\n}\n\nfunction Re(e, t) {\n  if (null !== e._state) {\n    var n = e._state ? t.onFulfilled : t.onRejected;\n    if (null === n) return (e._state ? t.resolve : t.reject)(e._value);\n    ++t.psd.ref, ++Se, ge(Fe, [n, e, t]);\n  } else e._listeners.push(t);\n}\n\nfunction Fe(e, t, n) {\n  try {\n    ke = t;\n    var r,\n        s = t._value;\n    t._state ? r = e(s) : (xe.length && (xe = []), r = e(s), -1 === xe.indexOf(s) && function (e) {\n      var t = we.length;\n\n      for (; t;) {\n        if (we[--t]._value === e._value) return void we.splice(t, 1);\n      }\n    }(t)), n.resolve(r);\n  } catch (e) {\n    n.reject(e);\n  } finally {\n    ke = null, 0 == --Se && Le(), --n.psd.ref || n.psd.finalize();\n  }\n}\n\nfunction Me(e, t, n) {\n  if (t.length === n) return t;\n  var r = \"\";\n\n  if (!1 === e._state) {\n    var s,\n        i,\n        o = e._value;\n    null != o ? (s = o.name || \"Error\", i = o.message || o, r = $(o, 0)) : (s = o, i = \"\"), t.push(s + (i ? \": \" + i : \"\") + r);\n  }\n\n  return R && ((r = $(e._stackHolder, 2)) && -1 === t.indexOf(r) && t.push(r), e._prev && Me(e._prev, t, n)), t;\n}\n\nfunction Ne(e, t) {\n  var n = t ? t._numPrev + 1 : 0;\n  n < 100 && (e._prev = t, e._numPrev = n);\n}\n\nfunction qe() {\n  $e() && Ue();\n}\n\nfunction $e() {\n  var e = be;\n  return be = !1, _e = !1, e;\n}\n\nfunction Ue() {\n  var e, t, n;\n\n  do {\n    for (; Oe.length > 0;) {\n      for (e = Oe, Oe = [], n = e.length, t = 0; t < n; ++t) {\n        var r = e[t];\n        r[0].apply(null, r[1]);\n      }\n    }\n  } while (Oe.length > 0);\n\n  be = !0, _e = !0;\n}\n\nfunction Le() {\n  var e = we;\n  we = [], e.forEach(function (e) {\n    e._PSD.onunhandled.call(null, e._value, e);\n  });\n\n  for (var t = Ae.slice(0), n = t.length; n;) {\n    t[--n]();\n  }\n}\n\nfunction Ve(e) {\n  return new Ce(le, !1, e);\n}\n\nfunction We(e, t) {\n  var n = Ke;\n  return function () {\n    var r = $e(),\n        s = Ke;\n\n    try {\n      return st(n, !0), e.apply(this, arguments);\n    } catch (e) {\n      t && t(e);\n    } finally {\n      st(s, !1), r && Ue();\n    }\n  };\n}\n\na(Ce.prototype, {\n  then: je,\n  _then: function _then(e, t) {\n    Re(this, new De(null, null, e, t, Ke));\n  },\n  catch: function _catch(e) {\n    if (1 === arguments.length) return this.then(null, e);\n    var t = arguments[0],\n        n = arguments[1];\n    return \"function\" == typeof t ? this.then(null, function (e) {\n      return e instanceof t ? n(e) : Ve(e);\n    }) : this.then(null, function (e) {\n      return e && e.name === t ? n(e) : Ve(e);\n    });\n  },\n  finally: function _finally(e) {\n    return this.then(function (t) {\n      return e(), t;\n    }, function (t) {\n      return e(), Ve(t);\n    });\n  },\n  stack: {\n    get: function get() {\n      if (this._stack) return this._stack;\n\n      try {\n        me = !0;\n        var e = Me(this, [], 20).join(\"\\nFrom previous: \");\n        return null !== this._state && (this._stack = e), e;\n      } finally {\n        me = !1;\n      }\n    }\n  },\n  timeout: function timeout(e, t) {\n    var _this2 = this;\n\n    return e < 1 / 0 ? new Ce(function (n, r) {\n      var s = setTimeout(function () {\n        return r(new X.Timeout(t));\n      }, e);\n\n      _this2.then(n, r).finally(clearTimeout.bind(null, s));\n    }) : this;\n  }\n}), \"undefined\" != typeof Symbol && Symbol.toStringTag && l(Ce.prototype, Symbol.toStringTag, \"Dexie.Promise\"), Pe.env = it(), a(Ce, {\n  all: function all() {\n    var e = B.apply(null, arguments).map(tt);\n    return new Ce(function (t, n) {\n      0 === e.length && t([]);\n      var r = e.length;\n      e.forEach(function (s, i) {\n        return Ce.resolve(s).then(function (n) {\n          e[i] = n, --r || t(e);\n        }, n);\n      });\n    });\n  },\n  resolve: function resolve(e) {\n    if (e instanceof Ce) return e;\n    if (e && \"function\" == typeof e.then) return new Ce(function (t, n) {\n      e.then(t, n);\n    });\n    var t = new Ce(le, !0, e);\n    return Ne(t, ke), t;\n  },\n  reject: Ve,\n  race: function race() {\n    var e = B.apply(null, arguments).map(tt);\n    return new Ce(function (t, n) {\n      e.map(function (e) {\n        return Ce.resolve(e).then(t, n);\n      });\n    });\n  },\n  PSD: {\n    get: function get() {\n      return Ke;\n    },\n    set: function set(e) {\n      return Ke = e;\n    }\n  },\n  totalEchoes: {\n    get: function get() {\n      return Qe;\n    }\n  },\n  newPSD: Je,\n  usePSD: ot,\n  scheduler: {\n    get: function get() {\n      return ge;\n    },\n    set: function set(e) {\n      ge = e;\n    }\n  },\n  rejectionMapper: {\n    get: function get() {\n      return Ee;\n    },\n    set: function set(e) {\n      Ee = e;\n    }\n  },\n  follow: function follow(e, t) {\n    return new Ce(function (n, r) {\n      return Je(function (t, n) {\n        var r = Ke;\n        r.unhandleds = [], r.onunhandled = n, r.finalize = re(function () {\n          var _this3 = this;\n\n          !function (e) {\n            function t() {\n              e(), Ae.splice(Ae.indexOf(t), 1);\n            }\n\n            Ae.push(t), ++Se, ge(function () {\n              0 == --Se && Le();\n            }, []);\n          }(function () {\n            0 === _this3.unhandleds.length ? t() : n(_this3.unhandleds[0]);\n          });\n        }, r.finalize), e();\n      }, t, n, r);\n    });\n  }\n}), pe && (pe.allSettled && l(Ce, \"allSettled\", function () {\n  var e = B.apply(null, arguments).map(tt);\n  return new Ce(function (t) {\n    0 === e.length && t([]);\n    var n = e.length;\n    var r = new Array(n);\n    e.forEach(function (e, s) {\n      return Ce.resolve(e).then(function (e) {\n        return r[s] = {\n          status: \"fulfilled\",\n          value: e\n        };\n      }, function (e) {\n        return r[s] = {\n          status: \"rejected\",\n          reason: e\n        };\n      }).then(function () {\n        return --n || t(r);\n      });\n    });\n  });\n}), pe.any && \"undefined\" != typeof AggregateError && l(Ce, \"any\", function () {\n  var e = B.apply(null, arguments).map(tt);\n  return new Ce(function (t, n) {\n    0 === e.length && n(new AggregateError([]));\n    var r = e.length;\n    var s = new Array(r);\n    e.forEach(function (e, i) {\n      return Ce.resolve(e).then(function (e) {\n        return t(e);\n      }, function (e) {\n        s[i] = e, --r || n(new AggregateError(s));\n      });\n    });\n  });\n}));\nvar Ye = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar ze = 0,\n    Ge = [],\n    He = 0,\n    Qe = 0,\n    Xe = 0;\n\nfunction Je(e, t, n, s) {\n  var i = Ke,\n      o = Object.create(i);\n  o.parent = i, o.ref = 0, o.global = !1, o.id = ++Xe;\n  var a = Pe.env;\n  o.env = ye ? {\n    Promise: Ce,\n    PromiseProp: {\n      value: Ce,\n      configurable: !0,\n      writable: !0\n    },\n    all: Ce.all,\n    race: Ce.race,\n    allSettled: Ce.allSettled,\n    any: Ce.any,\n    resolve: Ce.resolve,\n    reject: Ce.reject,\n    nthen: lt(a.nthen, o),\n    gthen: lt(a.gthen, o)\n  } : {}, t && r(o, t), ++i.ref, o.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n  var u = ot(o, e, n, s);\n  return 0 === o.ref && o.finalize(), u;\n}\n\nfunction Ze() {\n  return Ye.id || (Ye.id = ++ze), ++Ye.awaits, Ye.echoes += 100, Ye.id;\n}\n\nfunction et() {\n  return !!Ye.awaits && (0 == --Ye.awaits && (Ye.id = 0), Ye.echoes = 100 * Ye.awaits, !0);\n}\n\nfunction tt(e) {\n  return Ye.echoes && e && e.constructor === pe ? (Ze(), e.then(function (e) {\n    return et(), e;\n  }, function (e) {\n    return et(), ht(e);\n  })) : e;\n}\n\nfunction nt(e) {\n  ++Qe, Ye.echoes && 0 != --Ye.echoes || (Ye.echoes = Ye.id = 0), Ge.push(Ke), st(e, !0);\n}\n\nfunction rt() {\n  var e = Ge[Ge.length - 1];\n  Ge.pop(), st(e, !1);\n}\n\nfunction st(t, n) {\n  var r = Ke;\n\n  if ((n ? !Ye.echoes || He++ && t === Ke : !He || --He && t === Ke) || at(n ? nt.bind(null, t) : rt), t !== Ke && (Ke = t, r === Pe && (Pe.env = it()), ye)) {\n    var s = Pe.env.Promise,\n        i = t.env;\n    he.then = i.nthen, s.prototype.then = i.gthen, (r.global || t.global) && (Object.defineProperty(e, \"Promise\", i.PromiseProp), s.all = i.all, s.race = i.race, s.resolve = i.resolve, s.reject = i.reject, i.allSettled && (s.allSettled = i.allSettled), i.any && (s.any = i.any));\n  }\n}\n\nfunction it() {\n  var t = e.Promise;\n  return ye ? {\n    Promise: t,\n    PromiseProp: Object.getOwnPropertyDescriptor(e, \"Promise\"),\n    all: t.all,\n    race: t.race,\n    allSettled: t.allSettled,\n    any: t.any,\n    resolve: t.resolve,\n    reject: t.reject,\n    nthen: he.then,\n    gthen: t.prototype.then\n  } : {};\n}\n\nfunction ot(e, t, n, r, s) {\n  var i = Ke;\n\n  try {\n    return st(e, !0), t(n, r, s);\n  } finally {\n    st(i, !1);\n  }\n}\n\nfunction at(e) {\n  fe.call(ce, e);\n}\n\nfunction ut(e, t, n, r) {\n  return \"function\" != typeof e ? e : function () {\n    var s = Ke;\n    n && Ze(), st(t, !0);\n\n    try {\n      return e.apply(this, arguments);\n    } finally {\n      st(s, !1), r && at(et);\n    }\n  };\n}\n\nfunction lt(e, t) {\n  return function (n, r) {\n    return e.call(this, ut(n, t), ut(r, t));\n  };\n}\n\n-1 === (\"\" + fe).indexOf(\"[native code]\") && (Ze = et = ee);\n\nfunction ct(t, n) {\n  var s;\n\n  try {\n    s = n.onuncatched(t);\n  } catch (e) {}\n\n  if (!1 !== s) try {\n    var i,\n        o = {\n      promise: n,\n      reason: t\n    };\n    if (e.document && document.createEvent ? ((i = document.createEvent(\"Event\")).initEvent(\"unhandledrejection\", !0, !0), r(i, o)) : e.CustomEvent && r(i = new CustomEvent(\"unhandledrejection\", {\n      detail: o\n    }), o), i && e.dispatchEvent && (dispatchEvent(i), !e.PromiseRejectionEvent && e.onunhandledrejection)) try {\n      e.onunhandledrejection(i);\n    } catch (e) {}\n    R && i && !i.defaultPrevented && console.warn(\"Unhandled rejection: \".concat(t.stack || t));\n  } catch (e) {}\n}\n\nvar ht = Ce.reject;\n\nfunction dt(e, t, n, r) {\n  if (e.idbdb && (e._state.openComplete || Ke.letThrough || e._vip)) {\n    var s = e._createTransaction(t, n, e._dbSchema);\n\n    try {\n      s.create(), e._state.PR1398_maxLoop = 3;\n    } catch (s) {\n      return s.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(function () {\n        return dt(e, t, n, r);\n      })) : ht(s);\n    }\n\n    return s._promise(t, function (e, t) {\n      return Je(function () {\n        return Ke.trans = s, r(e, t, s);\n      });\n    }).then(function (e) {\n      return s._completion.then(function () {\n        return e;\n      });\n    });\n  }\n\n  if (e._state.openComplete) return ht(new X.DatabaseClosed(e._state.dbOpenError));\n\n  if (!e._state.isBeingOpened) {\n    if (!e._options.autoOpen) return ht(new X.DatabaseClosed());\n    e.open().catch(ee);\n  }\n\n  return e._state.dbReadyPromise.then(function () {\n    return dt(e, t, n, r);\n  });\n}\n\nvar ft = String.fromCharCode(65535),\n    pt = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\",\n    yt = [],\n    mt = \"undefined\" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent),\n    vt = mt,\n    gt = mt,\n    bt = function bt(e) {\n  return !/(dexie\\.js|dexie\\.min\\.js)/.test(e);\n};\n\nfunction _t(e, t) {\n  return e ? t ? function () {\n    return e.apply(this, arguments) && t.apply(this, arguments);\n  } : e : t;\n}\n\nvar wt = {\n  type: 3,\n  lower: -1 / 0,\n  lowerOpen: !1,\n  upper: [[]],\n  upperOpen: !1\n};\n\nfunction xt(e) {\n  return \"string\" != typeof e || /\\./.test(e) ? function (e) {\n    return e;\n  } : function (t) {\n    return void 0 === t[e] && e in t && delete (t = O(t))[e], t;\n  };\n}\n\nvar kt = /*#__PURE__*/function () {\n  function kt() {\n    _classCallCheck(this, kt);\n  }\n\n  _createClass(kt, [{\n    key: \"_trans\",\n    value: function _trans(e, t, n) {\n      var r = this._tx || Ke.trans,\n          s = this.name;\n\n      function i(e, n, r) {\n        if (!r.schema[s]) throw new X.NotFound(\"Table \" + s + \" not part of transaction\");\n        return t(r.idbtrans, r);\n      }\n\n      var o = $e();\n\n      try {\n        return r && r.db === this.db ? r === Ke.trans ? r._promise(e, i, n) : Je(function () {\n          return r._promise(e, i, n);\n        }, {\n          trans: r,\n          transless: Ke.transless || Ke\n        }) : dt(this.db, e, [this.name], i);\n      } finally {\n        o && Ue();\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(e, t) {\n      var _this4 = this;\n\n      return e && e.constructor === Object ? this.where(e).first(t) : this._trans(\"readonly\", function (t) {\n        return _this4.core.get({\n          trans: t,\n          key: e\n        }).then(function (e) {\n          return _this4.hook.reading.fire(e);\n        });\n      }).then(t);\n    }\n  }, {\n    key: \"where\",\n    value: function where(e) {\n      if (\"string\" == typeof e) return new this.db.WhereClause(this, e);\n      if (n(e)) return new this.db.WhereClause(this, \"[\".concat(e.join(\"+\"), \"]\"));\n      var r = t(e);\n      if (1 === r.length) return this.where(r[0]).equals(e[r[0]]);\n      var s = this.schema.indexes.concat(this.schema.primKey).filter(function (e) {\n        return e.compound && r.every(function (t) {\n          return e.keyPath.indexOf(t) >= 0;\n        }) && e.keyPath.every(function (e) {\n          return r.indexOf(e) >= 0;\n        });\n      })[0];\n      if (s && this.db._maxKey !== ft) return this.where(s.name).equals(s.keyPath.map(function (t) {\n        return e[t];\n      }));\n      !s && R && console.warn(\"The query \".concat(JSON.stringify(e), \" on \").concat(this.name, \" would benefit of a compound index [\").concat(r.join(\"+\"), \"]\"));\n      var i = this.schema.idxByName,\n          o = this.db._deps.indexedDB;\n\n      function a(e, t) {\n        try {\n          return 0 === o.cmp(e, t);\n        } catch (e) {\n          return !1;\n        }\n      }\n\n      var _r$reduce = r.reduce(function (_ref4, s) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            t = _ref5[0],\n            r = _ref5[1];\n\n        var o = i[s],\n            u = e[s];\n        return [t || o, t || !o ? _t(r, o && o.multi ? function (e) {\n          var t = b(e, s);\n          return n(t) && t.some(function (e) {\n            return a(u, e);\n          });\n        } : function (e) {\n          return a(u, b(e, s));\n        }) : r];\n      }, [null, null]),\n          _r$reduce2 = _slicedToArray(_r$reduce, 2),\n          u = _r$reduce2[0],\n          l = _r$reduce2[1];\n\n      return u ? this.where(u.name).equals(e[u.keyPath]).filter(l) : s ? this.filter(l) : this.where(r).equals(\"\");\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(e) {\n      return this.toCollection().and(e);\n    }\n  }, {\n    key: \"count\",\n    value: function count(e) {\n      return this.toCollection().count(e);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(e) {\n      return this.toCollection().offset(e);\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(e) {\n      return this.toCollection().limit(e);\n    }\n  }, {\n    key: \"each\",\n    value: function each(e) {\n      return this.toCollection().each(e);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(e) {\n      return this.toCollection().toArray(e);\n    }\n  }, {\n    key: \"toCollection\",\n    value: function toCollection() {\n      return new this.db.Collection(new this.db.WhereClause(this));\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(e) {\n      return new this.db.Collection(new this.db.WhereClause(this, n(e) ? \"[\".concat(e.join(\"+\"), \"]\") : e));\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      return this.toCollection().reverse();\n    }\n  }, {\n    key: \"mapToClass\",\n    value: function mapToClass(e) {\n      this.schema.mappedClass = e;\n\n      var t = function t(_t2) {\n        if (!_t2) return _t2;\n        var n = Object.create(e.prototype);\n\n        for (var r in _t2) {\n          if (o(_t2, r)) try {\n            n[r] = _t2[r];\n          } catch (e) {}\n        }\n\n        return n;\n      };\n\n      return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook(\"reading\", t), e;\n    }\n  }, {\n    key: \"defineClass\",\n    value: function defineClass() {\n      return this.mapToClass(function (e) {\n        r(this, e);\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(e, t) {\n      var _this5 = this;\n\n      var _this$schema$primKey = this.schema.primKey,\n          n = _this$schema$primKey.auto,\n          r = _this$schema$primKey.keyPath;\n      var s = e;\n      return r && n && (s = xt(r)(e)), this._trans(\"readwrite\", function (e) {\n        return _this5.core.mutate({\n          trans: e,\n          type: \"add\",\n          keys: null != t ? [t] : null,\n          values: [s]\n        });\n      }).then(function (e) {\n        return e.numFailures ? Ce.reject(e.failures[0]) : e.lastResult;\n      }).then(function (t) {\n        if (r) try {\n          _(e, r, t);\n        } catch (e) {}\n        return t;\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(e, r) {\n      if (\"object\" != typeof e || n(e)) return this.where(\":id\").equals(e).modify(r);\n      {\n        var _n3 = b(e, this.schema.primKey.keyPath);\n\n        if (void 0 === _n3) return ht(new X.InvalidArgument(\"Given object does not contain its primary key\"));\n\n        try {\n          \"function\" != typeof r ? t(r).forEach(function (t) {\n            _(e, t, r[t]);\n          }) : r(e, {\n            value: e,\n            primKey: _n3\n          });\n        } catch (e) {}\n\n        return this.where(\":id\").equals(_n3).modify(r);\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(e, t) {\n      var _this6 = this;\n\n      var _this$schema$primKey2 = this.schema.primKey,\n          n = _this$schema$primKey2.auto,\n          r = _this$schema$primKey2.keyPath;\n      var s = e;\n      return r && n && (s = xt(r)(e)), this._trans(\"readwrite\", function (e) {\n        return _this6.core.mutate({\n          trans: e,\n          type: \"put\",\n          values: [s],\n          keys: null != t ? [t] : null\n        });\n      }).then(function (e) {\n        return e.numFailures ? Ce.reject(e.failures[0]) : e.lastResult;\n      }).then(function (t) {\n        if (r) try {\n          _(e, r, t);\n        } catch (e) {}\n        return t;\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(e) {\n      var _this7 = this;\n\n      return this._trans(\"readwrite\", function (t) {\n        return _this7.core.mutate({\n          trans: t,\n          type: \"delete\",\n          keys: [e]\n        });\n      }).then(function (e) {\n        return e.numFailures ? Ce.reject(e.failures[0]) : void 0;\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this8 = this;\n\n      return this._trans(\"readwrite\", function (e) {\n        return _this8.core.mutate({\n          trans: e,\n          type: \"deleteRange\",\n          range: wt\n        });\n      }).then(function (e) {\n        return e.numFailures ? Ce.reject(e.failures[0]) : void 0;\n      });\n    }\n  }, {\n    key: \"bulkGet\",\n    value: function bulkGet(e) {\n      var _this9 = this;\n\n      return this._trans(\"readonly\", function (t) {\n        return _this9.core.getMany({\n          keys: e,\n          trans: t\n        }).then(function (e) {\n          return e.map(function (e) {\n            return _this9.hook.reading.fire(e);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"bulkAdd\",\n    value: function bulkAdd(e, t, n) {\n      var _this10 = this;\n\n      var r = Array.isArray(t) ? t : void 0,\n          s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n      return this._trans(\"readwrite\", function (t) {\n        var _this10$schema$primKe = _this10.schema.primKey,\n            n = _this10$schema$primKe.auto,\n            i = _this10$schema$primKe.keyPath;\n        if (i && r) throw new X.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n        if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n        var o = e.length;\n        var a = i && n ? e.map(xt(i)) : e;\n        return _this10.core.mutate({\n          trans: t,\n          type: \"add\",\n          keys: r,\n          values: a,\n          wantResults: s\n        }).then(function (_ref6) {\n          var e = _ref6.numFailures,\n              t = _ref6.results,\n              n = _ref6.lastResult,\n              r = _ref6.failures;\n          if (0 === e) return s ? t : n;\n          throw new G(\"\".concat(_this10.name, \".bulkAdd(): \").concat(e, \" of \").concat(o, \" operations failed\"), r);\n        });\n      });\n    }\n  }, {\n    key: \"bulkPut\",\n    value: function bulkPut(e, t, n) {\n      var _this11 = this;\n\n      var r = Array.isArray(t) ? t : void 0,\n          s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n      return this._trans(\"readwrite\", function (t) {\n        var _this11$schema$primKe = _this11.schema.primKey,\n            n = _this11$schema$primKe.auto,\n            i = _this11$schema$primKe.keyPath;\n        if (i && r) throw new X.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n        if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n        var o = e.length;\n        var a = i && n ? e.map(xt(i)) : e;\n        return _this11.core.mutate({\n          trans: t,\n          type: \"put\",\n          keys: r,\n          values: a,\n          wantResults: s\n        }).then(function (_ref7) {\n          var e = _ref7.numFailures,\n              t = _ref7.results,\n              n = _ref7.lastResult,\n              r = _ref7.failures;\n          if (0 === e) return s ? t : n;\n          throw new G(\"\".concat(_this11.name, \".bulkPut(): \").concat(e, \" of \").concat(o, \" operations failed\"), r);\n        });\n      });\n    }\n  }, {\n    key: \"bulkDelete\",\n    value: function bulkDelete(e) {\n      var _this12 = this;\n\n      var t = e.length;\n      return this._trans(\"readwrite\", function (t) {\n        return _this12.core.mutate({\n          trans: t,\n          type: \"delete\",\n          keys: e\n        });\n      }).then(function (_ref8) {\n        var e = _ref8.numFailures,\n            n = _ref8.lastResult,\n            r = _ref8.failures;\n        if (0 === e) return n;\n        throw new G(\"\".concat(_this12.name, \".bulkDelete(): \").concat(e, \" of \").concat(t, \" operations failed\"), r);\n      });\n    }\n  }]);\n\n  return kt;\n}();\n\nfunction Et(e) {\n  var r = {},\n      s = function s(t, n) {\n    if (n) {\n      for (var s = arguments.length, i = new Array(s - 1); --s;) {\n        i[s - 1] = arguments[s];\n      }\n\n      return r[t].subscribe.apply(null, i), e;\n    }\n\n    if (\"string\" == typeof t) return r[t];\n  };\n\n  s.addEventType = a;\n\n  for (var i = 1, o = arguments.length; i < o; ++i) {\n    a(arguments[i]);\n  }\n\n  return s;\n\n  function a(e, t, n) {\n    if (\"object\" == typeof e) return u(e);\n    t || (t = ae), n || (n = ee);\n    var i = {\n      subscribers: [],\n      fire: n,\n      subscribe: function subscribe(e) {\n        -1 === i.subscribers.indexOf(e) && (i.subscribers.push(e), i.fire = t(i.fire, e));\n      },\n      unsubscribe: function unsubscribe(e) {\n        i.subscribers = i.subscribers.filter(function (t) {\n          return t !== e;\n        }), i.fire = i.subscribers.reduce(t, n);\n      }\n    };\n    return r[e] = s[e] = i, i;\n  }\n\n  function u(e) {\n    t(e).forEach(function (t) {\n      var r = e[t];\n      if (n(r)) a(t, e[t][0], e[t][1]);else {\n        if (\"asap\" !== r) throw new X.InvalidArgument(\"Invalid event config\");\n        var s = a(t, te, function () {\n          for (var e = arguments.length, t = new Array(e); e--;) {\n            t[e] = arguments[e];\n          }\n\n          s.subscribers.forEach(function (e) {\n            v(function () {\n              e.apply(null, t);\n            });\n          });\n        });\n      }\n    });\n  }\n}\n\nfunction Pt(e, t) {\n  return c(t).from({\n    prototype: e\n  }), t;\n}\n\nfunction Kt(e, t) {\n  return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);\n}\n\nfunction Ot(e, t) {\n  e.filter = _t(e.filter, t);\n}\n\nfunction St(e, t, n) {\n  var r = e.replayFilter;\n  e.replayFilter = r ? function () {\n    return _t(r(), t());\n  } : t, e.justLimit = n && !r;\n}\n\nfunction At(e, t) {\n  if (e.isPrimKey) return t.primaryKey;\n  var n = t.getIndexByKeyPath(e.index);\n  if (!n) throw new X.Schema(\"KeyPath \" + e.index + \" on object store \" + t.name + \" is not indexed\");\n  return n;\n}\n\nfunction Ct(e, t, n) {\n  var r = At(e, t.schema);\n  return t.openCursor({\n    trans: n,\n    values: !e.keysOnly,\n    reverse: \"prev\" === e.dir,\n    unique: !!e.unique,\n    query: {\n      index: r,\n      range: e.range\n    }\n  });\n}\n\nfunction jt(e, t, n, r) {\n  var s = e.replayFilter ? _t(e.filter, e.replayFilter()) : e.filter;\n\n  if (e.or) {\n    var _i = {},\n        _a = function _a(e, n, r) {\n      if (!s || s(n, r, function (e) {\n        return n.stop(e);\n      }, function (e) {\n        return n.fail(e);\n      })) {\n        var a = n.primaryKey,\n            u = \"\" + a;\n        \"[object ArrayBuffer]\" === u && (u = \"\" + new Uint8Array(a)), o(_i, u) || (_i[u] = !0, t(e, n, r));\n      }\n    };\n\n    return Promise.all([e.or._iterate(_a, n), Dt(Ct(e, r, n), e.algorithm, _a, !e.keysOnly && e.valueMapper)]);\n  }\n\n  return Dt(Ct(e, r, n), _t(e.algorithm, s), t, !e.keysOnly && e.valueMapper);\n}\n\nfunction Dt(e, t, n, r) {\n  var s = We(r ? function (e, t, s) {\n    return n(r(e), t, s);\n  } : n);\n  return e.then(function (e) {\n    if (e) return e.start(function () {\n      var n = function n() {\n        return e.continue();\n      };\n\n      t && !t(e, function (e) {\n        return n = e;\n      }, function (t) {\n        e.stop(t), n = ee;\n      }, function (t) {\n        e.fail(t), n = ee;\n      }) || s(e.value, e, function (e) {\n        return n = e;\n      }), n();\n    });\n  });\n}\n\nfunction It(e, t) {\n  try {\n    var _n4 = Bt(e),\n        _r = Bt(t);\n\n    if (_n4 !== _r) return \"Array\" === _n4 ? 1 : \"Array\" === _r ? -1 : \"binary\" === _n4 ? 1 : \"binary\" === _r ? -1 : \"string\" === _n4 ? 1 : \"string\" === _r ? -1 : \"Date\" === _n4 ? 1 : \"Date\" !== _r ? NaN : -1;\n\n    switch (_n4) {\n      case \"number\":\n      case \"Date\":\n      case \"string\":\n        return e > t ? 1 : e < t ? -1 : 0;\n\n      case \"binary\":\n        return function (e, t) {\n          var n = e.length,\n              r = t.length,\n              s = n < r ? n : r;\n\n          for (var _n5 = 0; _n5 < s; ++_n5) {\n            if (e[_n5] !== t[_n5]) return e[_n5] < t[_n5] ? -1 : 1;\n          }\n\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(Tt(e), Tt(t));\n\n      case \"Array\":\n        return function (e, t) {\n          var n = e.length,\n              r = t.length,\n              s = n < r ? n : r;\n\n          for (var _n6 = 0; _n6 < s; ++_n6) {\n            var _r2 = It(e[_n6], t[_n6]);\n\n            if (0 !== _r2) return _r2;\n          }\n\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(e, t);\n    }\n  } catch (e) {}\n\n  return NaN;\n}\n\nfunction Bt(e) {\n  var t = typeof e;\n  if (\"object\" !== t) return t;\n  if (ArrayBuffer.isView(e)) return \"binary\";\n  var n = C(e);\n  return \"ArrayBuffer\" === n ? \"binary\" : n;\n}\n\nfunction Tt(e) {\n  return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);\n}\n\nvar Rt = /*#__PURE__*/function () {\n  function Rt() {\n    _classCallCheck(this, Rt);\n  }\n\n  _createClass(Rt, [{\n    key: \"_read\",\n    value: function _read(e, t) {\n      var n = this._ctx;\n      return n.error ? n.table._trans(null, ht.bind(null, n.error)) : n.table._trans(\"readonly\", e).then(t);\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(e) {\n      var t = this._ctx;\n      return t.error ? t.table._trans(null, ht.bind(null, t.error)) : t.table._trans(\"readwrite\", e, \"locked\");\n    }\n  }, {\n    key: \"_addAlgorithm\",\n    value: function _addAlgorithm(e) {\n      var t = this._ctx;\n      t.algorithm = _t(t.algorithm, e);\n    }\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(e, t) {\n      return jt(this._ctx, e, t, this._ctx.table.core);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(e) {\n      var t = Object.create(this.constructor.prototype),\n          n = Object.create(this._ctx);\n      return e && r(n, e), t._ctx = n, t;\n    }\n  }, {\n    key: \"raw\",\n    value: function raw() {\n      return this._ctx.valueMapper = null, this;\n    }\n  }, {\n    key: \"each\",\n    value: function each(e) {\n      var t = this._ctx;\n      return this._read(function (n) {\n        return jt(t, e, n, t.table.core);\n      });\n    }\n  }, {\n    key: \"count\",\n    value: function count(e) {\n      var _this13 = this;\n\n      return this._read(function (e) {\n        var t = _this13._ctx,\n            n = t.table.core;\n        if (Kt(t, !0)) return n.count({\n          trans: e,\n          query: {\n            index: At(t, n.schema),\n            range: t.range\n          }\n        }).then(function (e) {\n          return Math.min(e, t.limit);\n        });\n        var r = 0;\n        return jt(t, function () {\n          return ++r, !1;\n        }, e, n).then(function () {\n          return r;\n        });\n      }).then(e);\n    }\n  }, {\n    key: \"sortBy\",\n    value: function sortBy(e, t) {\n      var n = e.split(\".\").reverse(),\n          r = n[0],\n          s = n.length - 1;\n\n      function i(e, t) {\n        return t ? i(e[n[t]], t - 1) : e[r];\n      }\n\n      var o = \"next\" === this._ctx.dir ? 1 : -1;\n\n      function a(e, t) {\n        var n = i(e, s),\n            r = i(t, s);\n        return n < r ? -o : n > r ? o : 0;\n      }\n\n      return this.toArray(function (e) {\n        return e.sort(a);\n      }).then(t);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(e) {\n      var _this14 = this;\n\n      return this._read(function (e) {\n        var t = _this14._ctx;\n\n        if (\"next\" === t.dir && Kt(t, !0) && t.limit > 0) {\n          var _n7 = t.valueMapper,\n              _r3 = At(t, t.table.core.schema);\n\n          return t.table.core.query({\n            trans: e,\n            limit: t.limit,\n            values: !0,\n            query: {\n              index: _r3,\n              range: t.range\n            }\n          }).then(function (_ref9) {\n            var e = _ref9.result;\n            return _n7 ? e.map(_n7) : e;\n          });\n        }\n\n        {\n          var _n8 = [];\n          return jt(t, function (e) {\n            return _n8.push(e);\n          }, e, t.table.core).then(function () {\n            return _n8;\n          });\n        }\n      }, e);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(e) {\n      var t = this._ctx;\n      return e <= 0 || (t.offset += e, Kt(t) ? St(t, function () {\n        var t = e;\n        return function (e, n) {\n          return 0 === t || (1 === t ? (--t, !1) : (n(function () {\n            e.advance(t), t = 0;\n          }), !1));\n        };\n      }) : St(t, function () {\n        var t = e;\n        return function () {\n          return --t < 0;\n        };\n      })), this;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(e) {\n      return this._ctx.limit = Math.min(this._ctx.limit, e), St(this._ctx, function () {\n        var t = e;\n        return function (e, n, r) {\n          return --t <= 0 && n(r), t >= 0;\n        };\n      }, !0), this;\n    }\n  }, {\n    key: \"until\",\n    value: function until(e, t) {\n      return Ot(this._ctx, function (n, r, s) {\n        return !e(n.value) || (r(s), t);\n      }), this;\n    }\n  }, {\n    key: \"first\",\n    value: function first(e) {\n      return this.limit(1).toArray(function (e) {\n        return e[0];\n      }).then(e);\n    }\n  }, {\n    key: \"last\",\n    value: function last(e) {\n      return this.reverse().first(e);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(e) {\n      var t, n;\n      return Ot(this._ctx, function (t) {\n        return e(t.value);\n      }), t = this._ctx, n = e, t.isMatch = _t(t.isMatch, n), this;\n    }\n  }, {\n    key: \"and\",\n    value: function and(e) {\n      return this.filter(e);\n    }\n  }, {\n    key: \"or\",\n    value: function or(e) {\n      return new this.db.WhereClause(this._ctx.table, e, this);\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      return this._ctx.dir = \"prev\" === this._ctx.dir ? \"next\" : \"prev\", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;\n    }\n  }, {\n    key: \"desc\",\n    value: function desc() {\n      return this.reverse();\n    }\n  }, {\n    key: \"eachKey\",\n    value: function eachKey(e) {\n      var t = this._ctx;\n      return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n        e(n.key, n);\n      });\n    }\n  }, {\n    key: \"eachUniqueKey\",\n    value: function eachUniqueKey(e) {\n      return this._ctx.unique = \"unique\", this.eachKey(e);\n    }\n  }, {\n    key: \"eachPrimaryKey\",\n    value: function eachPrimaryKey(e) {\n      var t = this._ctx;\n      return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n        e(n.primaryKey, n);\n      });\n    }\n  }, {\n    key: \"keys\",\n    value: function keys(e) {\n      var t = this._ctx;\n      t.keysOnly = !t.isMatch;\n      var n = [];\n      return this.each(function (e, t) {\n        n.push(t.key);\n      }).then(function () {\n        return n;\n      }).then(e);\n    }\n  }, {\n    key: \"primaryKeys\",\n    value: function primaryKeys(e) {\n      var t = this._ctx;\n      if (\"next\" === t.dir && Kt(t, !0) && t.limit > 0) return this._read(function (e) {\n        var n = At(t, t.table.core.schema);\n        return t.table.core.query({\n          trans: e,\n          values: !1,\n          limit: t.limit,\n          query: {\n            index: n,\n            range: t.range\n          }\n        });\n      }).then(function (_ref10) {\n        var e = _ref10.result;\n        return e;\n      }).then(e);\n      t.keysOnly = !t.isMatch;\n      var n = [];\n      return this.each(function (e, t) {\n        n.push(t.primaryKey);\n      }).then(function () {\n        return n;\n      }).then(e);\n    }\n  }, {\n    key: \"uniqueKeys\",\n    value: function uniqueKeys(e) {\n      return this._ctx.unique = \"unique\", this.keys(e);\n    }\n  }, {\n    key: \"firstKey\",\n    value: function firstKey(e) {\n      return this.limit(1).keys(function (e) {\n        return e[0];\n      }).then(e);\n    }\n  }, {\n    key: \"lastKey\",\n    value: function lastKey(e) {\n      return this.reverse().firstKey(e);\n    }\n  }, {\n    key: \"distinct\",\n    value: function distinct() {\n      var e = this._ctx,\n          t = e.index && e.table.schema.idxByName[e.index];\n      if (!t || !t.multi) return this;\n      var n = {};\n      return Ot(this._ctx, function (e) {\n        var t = e.primaryKey.toString(),\n            r = o(n, t);\n        return n[t] = !0, !r;\n      }), this;\n    }\n  }, {\n    key: \"modify\",\n    value: function modify(e) {\n      var _this15 = this;\n\n      var n = this._ctx;\n      return this._write(function (r) {\n        var s;\n        if (\"function\" == typeof e) s = e;else {\n          var i = t(e),\n              o = i.length;\n\n          s = function s(t) {\n            for (var n = !1, r = 0; r < o; ++r) {\n              var s = i[r],\n                  a = e[s];\n              b(t, s) !== a && (_(t, s, a), n = !0);\n            }\n\n            return n;\n          };\n        }\n        var a = n.table.core,\n            _a$schema$primaryKey = a.schema.primaryKey,\n            u = _a$schema$primaryKey.outbound,\n            l = _a$schema$primaryKey.extractKey,\n            c = _this15.db._options.modifyChunkSize || 200,\n            h = [];\n        var d = 0;\n\n        var f = [],\n            p = function p(e, n) {\n          var r = n.failures,\n              s = n.numFailures;\n          d += e - s;\n\n          var _iterator = _createForOfIteratorHelper(t(r)),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _e2 = _step.value;\n              h.push(r[_e2]);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        };\n\n        return _this15.clone().primaryKeys().then(function (t) {\n          var i = function i(o) {\n            var h = Math.min(c, t.length - o);\n            return a.getMany({\n              trans: r,\n              keys: t.slice(o, o + h),\n              cache: \"immutable\"\n            }).then(function (d) {\n              var f = [],\n                  y = [],\n                  m = u ? [] : null,\n                  v = [];\n\n              for (var _e3 = 0; _e3 < h; ++_e3) {\n                var _n9 = d[_e3],\n                    _r4 = {\n                  value: O(_n9),\n                  primKey: t[o + _e3]\n                };\n                !1 !== s.call(_r4, _r4.value, _r4) && (null == _r4.value ? v.push(t[o + _e3]) : u || 0 === It(l(_n9), l(_r4.value)) ? (y.push(_r4.value), u && m.push(t[o + _e3])) : (v.push(t[o + _e3]), f.push(_r4.value)));\n              }\n\n              var g = Kt(n) && n.limit === 1 / 0 && (\"function\" != typeof e || e === Ft) && {\n                index: n.index,\n                range: n.range\n              };\n              return Promise.resolve(f.length > 0 && a.mutate({\n                trans: r,\n                type: \"add\",\n                values: f\n              }).then(function (e) {\n                for (var _t3 in e.failures) {\n                  v.splice(parseInt(_t3), 1);\n                }\n\n                p(f.length, e);\n              })).then(function () {\n                return (y.length > 0 || g && \"object\" == typeof e) && a.mutate({\n                  trans: r,\n                  type: \"put\",\n                  keys: m,\n                  values: y,\n                  criteria: g,\n                  changeSpec: \"function\" != typeof e && e\n                }).then(function (e) {\n                  return p(y.length, e);\n                });\n              }).then(function () {\n                return (v.length > 0 || g && e === Ft) && a.mutate({\n                  trans: r,\n                  type: \"delete\",\n                  keys: v,\n                  criteria: g\n                }).then(function (e) {\n                  return p(v.length, e);\n                });\n              }).then(function () {\n                return t.length > o + h && i(o + c);\n              });\n            });\n          };\n\n          return i(0).then(function () {\n            if (h.length > 0) throw new z(\"Error modifying one or more objects\", h, d, f);\n            return t.length;\n          });\n        });\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var e = this._ctx,\n          t = e.range;\n      return Kt(e) && (e.isPrimKey && !gt || 3 === t.type) ? this._write(function (n) {\n        var r = e.table.core.schema.primaryKey,\n            s = t;\n        return e.table.core.count({\n          trans: n,\n          query: {\n            index: r,\n            range: s\n          }\n        }).then(function (t) {\n          return e.table.core.mutate({\n            trans: n,\n            type: \"deleteRange\",\n            range: s\n          }).then(function (_ref11) {\n            var e = _ref11.failures,\n                n = _ref11.lastResult,\n                r = _ref11.results,\n                s = _ref11.numFailures;\n            if (s) throw new z(\"Could not delete some values\", Object.keys(e).map(function (t) {\n              return e[t];\n            }), t - s);\n            return t - s;\n          });\n        });\n      }) : this.modify(Ft);\n    }\n  }]);\n\n  return Rt;\n}();\n\nvar Ft = function Ft(e, t) {\n  return t.value = null;\n};\n\nfunction Mt(e, t) {\n  return e < t ? -1 : e === t ? 0 : 1;\n}\n\nfunction Nt(e, t) {\n  return e > t ? -1 : e === t ? 0 : 1;\n}\n\nfunction qt(e, t, n) {\n  var r = e instanceof Yt ? new e.Collection(e) : e;\n  return r._ctx.error = n ? new n(t) : new TypeError(t), r;\n}\n\nfunction $t(e) {\n  return new e.Collection(e, function () {\n    return Wt(\"\");\n  }).limit(0);\n}\n\nfunction Ut(e, t, n, r, s, i) {\n  for (var o = Math.min(e.length, r.length), a = -1, u = 0; u < o; ++u) {\n    var l = t[u];\n    if (l !== r[u]) return s(e[u], n[u]) < 0 ? e.substr(0, u) + n[u] + n.substr(u + 1) : s(e[u], r[u]) < 0 ? e.substr(0, u) + r[u] + n.substr(u + 1) : a >= 0 ? e.substr(0, a) + t[a] + n.substr(a + 1) : null;\n    s(e[u], l) < 0 && (a = u);\n  }\n\n  return o < r.length && \"next\" === i ? e + n.substr(e.length) : o < e.length && \"prev\" === i ? e.substr(0, n.length) : a < 0 ? null : e.substr(0, a) + r[a] + n.substr(a + 1);\n}\n\nfunction Lt(e, t, n, r) {\n  var s,\n      i,\n      o,\n      a,\n      u,\n      l,\n      c,\n      h = n.length;\n  if (!n.every(function (e) {\n    return \"string\" == typeof e;\n  })) return qt(e, \"String expected.\");\n\n  function d(e) {\n    s = function (e) {\n      return \"next\" === e ? function (e) {\n        return e.toUpperCase();\n      } : function (e) {\n        return e.toLowerCase();\n      };\n    }(e), i = function (e) {\n      return \"next\" === e ? function (e) {\n        return e.toLowerCase();\n      } : function (e) {\n        return e.toUpperCase();\n      };\n    }(e), o = \"next\" === e ? Mt : Nt;\n    var t = n.map(function (e) {\n      return {\n        lower: i(e),\n        upper: s(e)\n      };\n    }).sort(function (e, t) {\n      return o(e.lower, t.lower);\n    });\n    a = t.map(function (e) {\n      return e.upper;\n    }), u = t.map(function (e) {\n      return e.lower;\n    }), l = e, c = \"next\" === e ? \"\" : r;\n  }\n\n  d(\"next\");\n  var f = new e.Collection(e, function () {\n    return Vt(a[0], u[h - 1] + r);\n  });\n\n  f._ondirectionchange = function (e) {\n    d(e);\n  };\n\n  var p = 0;\n  return f._addAlgorithm(function (e, n, r) {\n    var s = e.key;\n    if (\"string\" != typeof s) return !1;\n    var d = i(s);\n    if (t(d, u, p)) return !0;\n\n    for (var f = null, y = p; y < h; ++y) {\n      var m = Ut(s, d, a[y], u[y], o, l);\n      null === m && null === f ? p = y + 1 : (null === f || o(f, m) > 0) && (f = m);\n    }\n\n    return n(null !== f ? function () {\n      e.continue(f + c);\n    } : r), !1;\n  }), f;\n}\n\nfunction Vt(e, t, n, r) {\n  return {\n    type: 2,\n    lower: e,\n    upper: t,\n    lowerOpen: n,\n    upperOpen: r\n  };\n}\n\nfunction Wt(e) {\n  return {\n    type: 1,\n    lower: e,\n    upper: e\n  };\n}\n\nvar Yt = /*#__PURE__*/function () {\n  function Yt() {\n    _classCallCheck(this, Yt);\n  }\n\n  _createClass(Yt, [{\n    key: \"Collection\",\n    get: function get() {\n      return this._ctx.table.db.Collection;\n    }\n  }, {\n    key: \"between\",\n    value: function between(e, t, n, r) {\n      n = !1 !== n, r = !0 === r;\n\n      try {\n        return this._cmp(e, t) > 0 || 0 === this._cmp(e, t) && (n || r) && (!n || !r) ? $t(this) : new this.Collection(this, function () {\n          return Vt(e, t, !n, !r);\n        });\n      } catch (e) {\n        return qt(this, pt);\n      }\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(e) {\n      return null == e ? qt(this, pt) : new this.Collection(this, function () {\n        return Wt(e);\n      });\n    }\n  }, {\n    key: \"above\",\n    value: function above(e) {\n      return null == e ? qt(this, pt) : new this.Collection(this, function () {\n        return Vt(e, void 0, !0);\n      });\n    }\n  }, {\n    key: \"aboveOrEqual\",\n    value: function aboveOrEqual(e) {\n      return null == e ? qt(this, pt) : new this.Collection(this, function () {\n        return Vt(e, void 0, !1);\n      });\n    }\n  }, {\n    key: \"below\",\n    value: function below(e) {\n      return null == e ? qt(this, pt) : new this.Collection(this, function () {\n        return Vt(void 0, e, !1, !0);\n      });\n    }\n  }, {\n    key: \"belowOrEqual\",\n    value: function belowOrEqual(e) {\n      return null == e ? qt(this, pt) : new this.Collection(this, function () {\n        return Vt(void 0, e);\n      });\n    }\n  }, {\n    key: \"startsWith\",\n    value: function startsWith(e) {\n      return \"string\" != typeof e ? qt(this, \"String expected.\") : this.between(e, e + ft, !0, !0);\n    }\n  }, {\n    key: \"startsWithIgnoreCase\",\n    value: function startsWithIgnoreCase(e) {\n      return \"\" === e ? this.startsWith(e) : Lt(this, function (e, t) {\n        return 0 === e.indexOf(t[0]);\n      }, [e], ft);\n    }\n  }, {\n    key: \"equalsIgnoreCase\",\n    value: function equalsIgnoreCase(e) {\n      return Lt(this, function (e, t) {\n        return e === t[0];\n      }, [e], \"\");\n    }\n  }, {\n    key: \"anyOfIgnoreCase\",\n    value: function anyOfIgnoreCase() {\n      var e = B.apply(I, arguments);\n      return 0 === e.length ? $t(this) : Lt(this, function (e, t) {\n        return -1 !== t.indexOf(e);\n      }, e, \"\");\n    }\n  }, {\n    key: \"startsWithAnyOfIgnoreCase\",\n    value: function startsWithAnyOfIgnoreCase() {\n      var e = B.apply(I, arguments);\n      return 0 === e.length ? $t(this) : Lt(this, function (e, t) {\n        return t.some(function (t) {\n          return 0 === e.indexOf(t);\n        });\n      }, e, ft);\n    }\n  }, {\n    key: \"anyOf\",\n    value: function anyOf() {\n      var _this16 = this;\n\n      var e = B.apply(I, arguments);\n      var t = this._cmp;\n\n      try {\n        e.sort(t);\n      } catch (e) {\n        return qt(this, pt);\n      }\n\n      if (0 === e.length) return $t(this);\n      var n = new this.Collection(this, function () {\n        return Vt(e[0], e[e.length - 1]);\n      });\n\n      n._ondirectionchange = function (n) {\n        t = \"next\" === n ? _this16._ascending : _this16._descending, e.sort(t);\n      };\n\n      var r = 0;\n      return n._addAlgorithm(function (n, s, i) {\n        var o = n.key;\n\n        for (; t(o, e[r]) > 0;) {\n          if (++r, r === e.length) return s(i), !1;\n        }\n\n        return 0 === t(o, e[r]) || (s(function () {\n          n.continue(e[r]);\n        }), !1);\n      }), n;\n    }\n  }, {\n    key: \"notEqual\",\n    value: function notEqual(e) {\n      return this.inAnyRange([[-(1 / 0), e], [e, this.db._maxKey]], {\n        includeLowers: !1,\n        includeUppers: !1\n      });\n    }\n  }, {\n    key: \"noneOf\",\n    value: function noneOf() {\n      var e = B.apply(I, arguments);\n      if (0 === e.length) return new this.Collection(this);\n\n      try {\n        e.sort(this._ascending);\n      } catch (e) {\n        return qt(this, pt);\n      }\n\n      var t = e.reduce(function (e, t) {\n        return e ? e.concat([[e[e.length - 1][1], t]]) : [[-(1 / 0), t]];\n      }, null);\n      return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, {\n        includeLowers: !1,\n        includeUppers: !1\n      });\n    }\n  }, {\n    key: \"inAnyRange\",\n    value: function inAnyRange(e, t) {\n      var _this17 = this;\n\n      var n = this._cmp,\n          r = this._ascending,\n          s = this._descending,\n          i = this._min,\n          o = this._max;\n      if (0 === e.length) return $t(this);\n      if (!e.every(function (e) {\n        return void 0 !== e[0] && void 0 !== e[1] && r(e[0], e[1]) <= 0;\n      })) return qt(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", X.InvalidArgument);\n      var a = !t || !1 !== t.includeLowers,\n          u = t && !0 === t.includeUppers;\n      var l,\n          c = r;\n\n      function h(e, t) {\n        return c(e[0], t[0]);\n      }\n\n      try {\n        l = e.reduce(function (e, t) {\n          var r = 0,\n              s = e.length;\n\n          for (; r < s; ++r) {\n            var _s = e[r];\n\n            if (n(t[0], _s[1]) < 0 && n(t[1], _s[0]) > 0) {\n              _s[0] = i(_s[0], t[0]), _s[1] = o(_s[1], t[1]);\n              break;\n            }\n          }\n\n          return r === s && e.push(t), e;\n        }, []), l.sort(h);\n      } catch (e) {\n        return qt(this, pt);\n      }\n\n      var d = 0;\n      var f = u ? function (e) {\n        return r(e, l[d][1]) > 0;\n      } : function (e) {\n        return r(e, l[d][1]) >= 0;\n      },\n          p = a ? function (e) {\n        return s(e, l[d][0]) > 0;\n      } : function (e) {\n        return s(e, l[d][0]) >= 0;\n      };\n      var y = f;\n      var m = new this.Collection(this, function () {\n        return Vt(l[0][0], l[l.length - 1][1], !a, !u);\n      });\n      return m._ondirectionchange = function (e) {\n        \"next\" === e ? (y = f, c = r) : (y = p, c = s), l.sort(h);\n      }, m._addAlgorithm(function (e, t, n) {\n        for (var s = e.key; y(s);) {\n          if (++d, d === l.length) return t(n), !1;\n        }\n\n        return !!function (e) {\n          return !f(e) && !p(e);\n        }(s) || (0 === _this17._cmp(s, l[d][1]) || 0 === _this17._cmp(s, l[d][0]) || t(function () {\n          c === r ? e.continue(l[d][0]) : e.continue(l[d][1]);\n        }), !1);\n      }), m;\n    }\n  }, {\n    key: \"startsWithAnyOf\",\n    value: function startsWithAnyOf() {\n      var e = B.apply(I, arguments);\n      return e.every(function (e) {\n        return \"string\" == typeof e;\n      }) ? 0 === e.length ? $t(this) : this.inAnyRange(e.map(function (e) {\n        return [e, e + ft];\n      })) : qt(this, \"startsWithAnyOf() only works with strings\");\n    }\n  }]);\n\n  return Yt;\n}();\n\nfunction zt(e) {\n  return We(function (t) {\n    return Gt(t), e(t.target.error), !1;\n  });\n}\n\nfunction Gt(e) {\n  e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();\n}\n\nvar Ht = Et(null, \"storagemutated\");\n\nvar Qt = /*#__PURE__*/function () {\n  function Qt() {\n    _classCallCheck(this, Qt);\n  }\n\n  _createClass(Qt, [{\n    key: \"_lock\",\n    value: function _lock() {\n      return m(!Ke.global), ++this._reculock, 1 !== this._reculock || Ke.global || (Ke.lockOwnerFor = this), this;\n    }\n  }, {\n    key: \"_unlock\",\n    value: function _unlock() {\n      if (m(!Ke.global), 0 == --this._reculock) for (Ke.global || (Ke.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {\n        var e = this._blockedFuncs.shift();\n\n        try {\n          ot(e[1], e[0]);\n        } catch (e) {}\n      }\n      return this;\n    }\n  }, {\n    key: \"_locked\",\n    value: function _locked() {\n      return this._reculock && Ke.lockOwnerFor !== this;\n    }\n  }, {\n    key: \"create\",\n    value: function create(e) {\n      var _this18 = this;\n\n      if (!this.mode) return this;\n      var t = this.db.idbdb,\n          n = this.db._state.dbOpenError;\n      if (m(!this.idbtrans), !e && !t) switch (n && n.name) {\n        case \"DatabaseClosedError\":\n          throw new X.DatabaseClosed(n);\n\n        case \"MissingAPIError\":\n          throw new X.MissingAPI(n.message, n);\n\n        default:\n          throw new X.OpenFailed(n);\n      }\n      if (!this.active) throw new X.TransactionInactive();\n      return m(null === this._completion._state), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n        durability: this.chromeTransactionDurability\n      }) : t.transaction(this.storeNames, this.mode, {\n        durability: this.chromeTransactionDurability\n      }))).onerror = We(function (t) {\n        Gt(t), _this18._reject(e.error);\n      }), e.onabort = We(function (t) {\n        Gt(t), _this18.active && _this18._reject(new X.Abort(e.error)), _this18.active = !1, _this18.on(\"abort\").fire(t);\n      }), e.oncomplete = We(function () {\n        _this18.active = !1, _this18._resolve(), \"mutatedParts\" in e && Ht.storagemutated.fire(e.mutatedParts);\n      }), this;\n    }\n  }, {\n    key: \"_promise\",\n    value: function _promise(e, t, n) {\n      var _this19 = this;\n\n      if (\"readwrite\" === e && \"readwrite\" !== this.mode) return ht(new X.ReadOnly(\"Transaction is readonly\"));\n      if (!this.active) return ht(new X.TransactionInactive());\n      if (this._locked()) return new Ce(function (r, s) {\n        _this19._blockedFuncs.push([function () {\n          _this19._promise(e, t, n).then(r, s);\n        }, Ke]);\n      });\n      if (n) return Je(function () {\n        var e = new Ce(function (e, n) {\n          _this19._lock();\n\n          var r = t(e, n, _this19);\n          r && r.then && r.then(e, n);\n        });\n        return e.finally(function () {\n          return _this19._unlock();\n        }), e._lib = !0, e;\n      });\n      var r = new Ce(function (e, n) {\n        var r = t(e, n, _this19);\n        r && r.then && r.then(e, n);\n      });\n      return r._lib = !0, r;\n    }\n  }, {\n    key: \"_root\",\n    value: function _root() {\n      return this.parent ? this.parent._root() : this;\n    }\n  }, {\n    key: \"waitFor\",\n    value: function waitFor(e) {\n      var t = this._root();\n\n      var n = Ce.resolve(e);\n      if (t._waitingFor) t._waitingFor = t._waitingFor.then(function () {\n        return n;\n      });else {\n        t._waitingFor = n, t._waitingQueue = [];\n        var r = t.idbtrans.objectStore(t.storeNames[0]);\n        !function e() {\n          for (++t._spinCount; t._waitingQueue.length;) {\n            t._waitingQueue.shift()();\n          }\n\n          t._waitingFor && (r.get(-1 / 0).onsuccess = e);\n        }();\n      }\n      var s = t._waitingFor;\n      return new Ce(function (e, r) {\n        n.then(function (n) {\n          return t._waitingQueue.push(We(e.bind(null, n)));\n        }, function (e) {\n          return t._waitingQueue.push(We(r.bind(null, e)));\n        }).finally(function () {\n          t._waitingFor === s && (t._waitingFor = null);\n        });\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));\n    }\n  }, {\n    key: \"table\",\n    value: function table(e) {\n      var t = this._memoizedTables || (this._memoizedTables = {});\n      if (o(t, e)) return t[e];\n      var n = this.schema[e];\n      if (!n) throw new X.NotFound(\"Table \" + e + \" not part of transaction\");\n      var r = new this.db.Table(e, n, this);\n      return r.core = this.db.core.table(e), t[e] = r, r;\n    }\n  }]);\n\n  return Qt;\n}();\n\nfunction Xt(e, t, n, r, s, i, o) {\n  return {\n    name: e,\n    keyPath: t,\n    unique: n,\n    multi: r,\n    auto: s,\n    compound: i,\n    src: (n && !o ? \"&\" : \"\") + (r ? \"*\" : \"\") + (s ? \"++\" : \"\") + Jt(t)\n  };\n}\n\nfunction Jt(e) {\n  return \"string\" == typeof e ? e : e ? \"[\" + [].join.call(e, \"+\") + \"]\" : \"\";\n}\n\nfunction Zt(e, t, n) {\n  return {\n    name: e,\n    primKey: t,\n    indexes: n,\n    mappedClass: null,\n    idxByName: g(n, function (e) {\n      return [e.name, e];\n    })\n  };\n}\n\nvar _en = function en(e) {\n  try {\n    return e.only([[]]), _en = function en() {\n      return [[]];\n    }, [[]];\n  } catch (e) {\n    return _en = function en() {\n      return ft;\n    }, ft;\n  }\n};\n\nfunction tn(e) {\n  return null == e ? function () {} : \"string\" == typeof e ? function (e) {\n    return 1 === e.split(\".\").length ? function (t) {\n      return t[e];\n    } : function (t) {\n      return b(t, e);\n    };\n  }(e) : function (t) {\n    return b(t, e);\n  };\n}\n\nfunction nn(e) {\n  return [].slice.call(e);\n}\n\nvar rn = 0;\n\nfunction sn(e) {\n  return null == e ? \":id\" : \"string\" == typeof e ? e : \"[\".concat(e.join(\"+\"), \"]\");\n}\n\nfunction on(e, t, r) {\n  function s(e) {\n    if (3 === e.type) return null;\n    if (4 === e.type) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    var n = e.lower,\n        r = e.upper,\n        s = e.lowerOpen,\n        i = e.upperOpen;\n    return void 0 === n ? void 0 === r ? null : t.upperBound(r, !!i) : void 0 === r ? t.lowerBound(n, !!s) : t.bound(n, r, !!s, !!i);\n  }\n\n  var _ref12 = function (e, t) {\n    var r = nn(e.objectStoreNames);\n    return {\n      schema: {\n        name: e.name,\n        tables: r.map(function (e) {\n          return t.objectStore(e);\n        }).map(function (e) {\n          var t = e.keyPath,\n              r = e.autoIncrement,\n              s = n(t),\n              i = null == t,\n              o = {},\n              a = {\n            name: e.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: !0,\n              outbound: i,\n              compound: s,\n              keyPath: t,\n              autoIncrement: r,\n              unique: !0,\n              extractKey: tn(t)\n            },\n            indexes: nn(e.indexNames).map(function (t) {\n              return e.index(t);\n            }).map(function (e) {\n              var t = e.name,\n                  r = e.unique,\n                  s = e.multiEntry,\n                  i = e.keyPath,\n                  a = {\n                name: t,\n                compound: n(i),\n                keyPath: i,\n                unique: r,\n                multiEntry: s,\n                extractKey: tn(i)\n              };\n              return o[sn(i)] = a, a;\n            }),\n            getIndexByKeyPath: function getIndexByKeyPath(e) {\n              return o[sn(e)];\n            }\n          };\n          return o[\":id\"] = a.primaryKey, null != t && (o[sn(t)] = a.primaryKey), a;\n        })\n      },\n      hasGetAll: r.length > 0 && \"getAll\" in t.objectStore(r[0]) && !(\"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n    };\n  }(e, r),\n      i = _ref12.schema,\n      o = _ref12.hasGetAll,\n      a = i.tables.map(function (e) {\n    return function (e) {\n      var t = e.name;\n      return {\n        name: t,\n        schema: e,\n        mutate: function mutate(_ref13) {\n          var e = _ref13.trans,\n              n = _ref13.type,\n              r = _ref13.keys,\n              i = _ref13.values,\n              o = _ref13.range;\n          return new Promise(function (a, u) {\n            a = We(a);\n            var l = e.objectStore(t),\n                c = null == l.keyPath,\n                h = \"put\" === n || \"add\" === n;\n            if (!h && \"delete\" !== n && \"deleteRange\" !== n) throw new Error(\"Invalid operation type: \" + n);\n\n            var _ref14 = r || i || {\n              length: 1\n            },\n                d = _ref14.length;\n\n            if (r && i && r.length !== i.length) throw new Error(\"Given keys array must have same length as given values array.\");\n            if (0 === d) return a({\n              numFailures: 0,\n              failures: {},\n              results: [],\n              lastResult: void 0\n            });\n            var f;\n            var p = [],\n                y = [];\n            var m = 0;\n\n            var v = function v(e) {\n              ++m, Gt(e);\n            };\n\n            if (\"deleteRange\" === n) {\n              if (4 === o.type) return a({\n                numFailures: m,\n                failures: y,\n                results: [],\n                lastResult: void 0\n              });\n              3 === o.type ? p.push(f = l.clear()) : p.push(f = l.delete(s(o)));\n            } else {\n              var _ref15 = h ? c ? [i, r] : [i, null] : [r, null],\n                  _ref16 = _slicedToArray(_ref15, 2),\n                  _e4 = _ref16[0],\n                  _t4 = _ref16[1];\n\n              if (h) for (var _r5 = 0; _r5 < d; ++_r5) {\n                p.push(f = _t4 && void 0 !== _t4[_r5] ? l[n](_e4[_r5], _t4[_r5]) : l[n](_e4[_r5])), f.onerror = v;\n              } else for (var _t5 = 0; _t5 < d; ++_t5) {\n                p.push(f = l[n](_e4[_t5])), f.onerror = v;\n              }\n            }\n\n            var g = function g(e) {\n              var t = e.target.result;\n              p.forEach(function (e, t) {\n                return null != e.error && (y[t] = e.error);\n              }), a({\n                numFailures: m,\n                failures: y,\n                results: \"delete\" === n ? r : p.map(function (e) {\n                  return e.result;\n                }),\n                lastResult: t\n              });\n            };\n\n            f.onerror = function (e) {\n              v(e), g(e);\n            }, f.onsuccess = g;\n          });\n        },\n        getMany: function getMany(_ref17) {\n          var e = _ref17.trans,\n              n = _ref17.keys;\n          return new Promise(function (r, s) {\n            r = We(r);\n            var i = e.objectStore(t),\n                o = n.length,\n                a = new Array(o);\n            var u,\n                l = 0,\n                c = 0;\n\n            var h = function h(e) {\n              var t = e.target;\n              a[t._pos] = t.result, ++c === l && r(a);\n            },\n                d = zt(s);\n\n            for (var _e5 = 0; _e5 < o; ++_e5) {\n              null != n[_e5] && (u = i.get(n[_e5]), u._pos = _e5, u.onsuccess = h, u.onerror = d, ++l);\n            }\n\n            0 === l && r(a);\n          });\n        },\n        get: function get(_ref18) {\n          var e = _ref18.trans,\n              n = _ref18.key;\n          return new Promise(function (r, s) {\n            r = We(r);\n            var i = e.objectStore(t).get(n);\n            i.onsuccess = function (e) {\n              return r(e.target.result);\n            }, i.onerror = zt(s);\n          });\n        },\n        query: function (e) {\n          return function (n) {\n            return new Promise(function (r, i) {\n              r = We(r);\n              var o = n.trans,\n                  a = n.values,\n                  u = n.limit,\n                  l = n.query,\n                  c = u === 1 / 0 ? void 0 : u,\n                  h = l.index,\n                  d = l.range,\n                  f = o.objectStore(t),\n                  p = h.isPrimaryKey ? f : f.index(h.name),\n                  y = s(d);\n              if (0 === u) return r({\n                result: []\n              });\n\n              if (e) {\n                var _e6 = a ? p.getAll(y, c) : p.getAllKeys(y, c);\n\n                _e6.onsuccess = function (e) {\n                  return r({\n                    result: e.target.result\n                  });\n                }, _e6.onerror = zt(i);\n              } else {\n                var _e7 = 0;\n\n                var _t6 = a || !(\"openKeyCursor\" in p) ? p.openCursor(y) : p.openKeyCursor(y),\n                    _n10 = [];\n\n                _t6.onsuccess = function (s) {\n                  var i = _t6.result;\n                  return i ? (_n10.push(a ? i.value : i.primaryKey), ++_e7 === u ? r({\n                    result: _n10\n                  }) : void i.continue()) : r({\n                    result: _n10\n                  });\n                }, _t6.onerror = zt(i);\n              }\n            });\n          };\n        }(o),\n        openCursor: function openCursor(_ref19) {\n          var e = _ref19.trans,\n              n = _ref19.values,\n              r = _ref19.query,\n              i = _ref19.reverse,\n              o = _ref19.unique;\n          return new Promise(function (a, u) {\n            a = We(a);\n            var l = r.index,\n                c = r.range,\n                h = e.objectStore(t),\n                d = l.isPrimaryKey ? h : h.index(l.name),\n                f = i ? o ? \"prevunique\" : \"prev\" : o ? \"nextunique\" : \"next\",\n                p = n || !(\"openKeyCursor\" in d) ? d.openCursor(s(c), f) : d.openKeyCursor(s(c), f);\n            p.onerror = zt(u), p.onsuccess = We(function (t) {\n              var n = p.result;\n              if (!n) return void a(null);\n              n.___id = ++rn, n.done = !1;\n              var r = n.continue.bind(n);\n              var s = n.continuePrimaryKey;\n              s && (s = s.bind(n));\n\n              var i = n.advance.bind(n),\n                  o = function o() {\n                throw new Error(\"Cursor not stopped\");\n              };\n\n              n.trans = e, n.stop = n.continue = n.continuePrimaryKey = n.advance = function () {\n                throw new Error(\"Cursor not started\");\n              }, n.fail = We(u), n.next = function () {\n                var _this20 = this;\n\n                var e = 1;\n                return this.start(function () {\n                  return e-- ? _this20.continue() : _this20.stop();\n                }).then(function () {\n                  return _this20;\n                });\n              }, n.start = function (e) {\n                var t = new Promise(function (e, t) {\n                  e = We(e), p.onerror = zt(t), n.fail = t, n.stop = function (t) {\n                    n.stop = n.continue = n.continuePrimaryKey = n.advance = o, e(t);\n                  };\n                }),\n                    a = function a() {\n                  if (p.result) try {\n                    e();\n                  } catch (e) {\n                    n.fail(e);\n                  } else n.done = !0, n.start = function () {\n                    throw new Error(\"Cursor behind last entry\");\n                  }, n.stop();\n                };\n\n                return p.onsuccess = We(function (e) {\n                  p.onsuccess = a, a();\n                }), n.continue = r, n.continuePrimaryKey = s, n.advance = i, a(), t;\n              }, a(n);\n            }, u);\n          });\n        },\n        count: function count(_ref20) {\n          var e = _ref20.query,\n              n = _ref20.trans;\n          var r = e.index,\n              i = e.range;\n          return new Promise(function (e, o) {\n            var a = n.objectStore(t),\n                u = r.isPrimaryKey ? a : a.index(r.name),\n                l = s(i),\n                c = l ? u.count(l) : u.count();\n            c.onsuccess = We(function (t) {\n              return e(t.target.result);\n            }), c.onerror = zt(o);\n          });\n        }\n      };\n    }(e);\n  }),\n      u = {};\n\n  return a.forEach(function (e) {\n    return u[e.name] = e;\n  }), {\n    stack: \"dbcore\",\n    transaction: e.transaction.bind(e),\n    table: function table(e) {\n      if (!u[e]) throw new Error(\"Table '\".concat(e, \"' not found\"));\n      return u[e];\n    },\n    MIN_KEY: -1 / 0,\n    MAX_KEY: _en(t),\n    schema: i\n  };\n}\n\nfunction an(_ref21, t) {\n  var e = _ref21._novip;\n\n  var n = t.db,\n      r = function (e, t, _ref22, s) {\n    var n = _ref22.IDBKeyRange,\n        r = _ref22.indexedDB;\n\n    var i = function (e, t) {\n      return t.reduce(function (e, _ref23) {\n        var t = _ref23.create;\n        return _objectSpread(_objectSpread({}, e), t(e));\n      }, e);\n    }(on(t, n, s), e.dbcore);\n\n    return {\n      dbcore: i\n    };\n  }(e._middlewares, n, e._deps, t);\n\n  e.core = r.dbcore, e.tables.forEach(function (t) {\n    var n = t.name;\n    e.core.schema.tables.some(function (e) {\n      return e.name === n;\n    }) && (t.core = e.core.table(n), e[n] instanceof e.Table && (e[n].core = t.core));\n  });\n}\n\nfunction un(_ref24, t, n, r) {\n  var e = _ref24._novip;\n  n.forEach(function (n) {\n    var s = r[n];\n    t.forEach(function (t) {\n      var r = d(t, n);\n      (!r || \"value\" in r && void 0 === r.value) && (t === e.Transaction.prototype || t instanceof e.Transaction ? l(t, n, {\n        get: function get() {\n          return this.table(n);\n        },\n        set: function set(e) {\n          u(this, n, {\n            value: e,\n            writable: !0,\n            configurable: !0,\n            enumerable: !0\n          });\n        }\n      }) : t[n] = new e.Table(n, s));\n    });\n  });\n}\n\nfunction ln(_ref25, t) {\n  var e = _ref25._novip;\n  t.forEach(function (t) {\n    for (var _n11 in t) {\n      t[_n11] instanceof e.Table && delete t[_n11];\n    }\n  });\n}\n\nfunction cn(e, t) {\n  return e._cfg.version - t._cfg.version;\n}\n\nfunction hn(e, n, r, s) {\n  var i = e._dbSchema,\n      o = e._createTransaction(\"readwrite\", e._storeNames, i);\n\n  o.create(r), o._completion.catch(s);\n\n  var a = o._reject.bind(o),\n      u = Ke.transless || Ke;\n\n  Je(function () {\n    Ke.trans = o, Ke.transless = u, 0 === n ? (t(i).forEach(function (e) {\n      fn(r, e, i[e].primKey, i[e].indexes);\n    }), an(e, r), Ce.follow(function () {\n      return e.on.populate.fire(o);\n    }).catch(a)) : function (_ref26, n, r, s) {\n      var e = _ref26._novip;\n      var i = [],\n          o = e._versions;\n      var a = e._dbSchema = yn(e, e.idbdb, s),\n          u = !1;\n\n      function l() {\n        return i.length ? Ce.resolve(i.shift()(r.idbtrans)).then(l) : Ce.resolve();\n      }\n\n      return o.filter(function (e) {\n        return e._cfg.version >= n;\n      }).forEach(function (o) {\n        i.push(function () {\n          var i = a,\n              l = o._cfg.dbschema;\n          mn(e, i, s), mn(e, l, s), a = e._dbSchema = l;\n          var c = dn(i, l);\n          c.add.forEach(function (e) {\n            fn(s, e[0], e[1].primKey, e[1].indexes);\n          }), c.change.forEach(function (e) {\n            if (e.recreate) throw new X.Upgrade(\"Not yet support for changing primary key\");\n            {\n              var _t7 = s.objectStore(e.name);\n\n              e.add.forEach(function (e) {\n                return pn(_t7, e);\n              }), e.change.forEach(function (e) {\n                _t7.deleteIndex(e.name), pn(_t7, e);\n              }), e.del.forEach(function (e) {\n                return _t7.deleteIndex(e);\n              });\n            }\n          });\n          var h = o._cfg.contentUpgrade;\n\n          if (h && o._cfg.version > n) {\n            an(e, s), r._memoizedTables = {}, u = !0;\n\n            var _n12 = w(l);\n\n            c.del.forEach(function (e) {\n              _n12[e] = i[e];\n            }), ln(e, [e.Transaction.prototype]), un(e, [e.Transaction.prototype], t(_n12), _n12), r.schema = _n12;\n\n            var _o = T(h);\n\n            var _a2;\n\n            _o && Ze();\n\n            var _d = Ce.follow(function () {\n              if (_a2 = h(r), _a2 && _o) {\n                var e = et.bind(null, null);\n\n                _a2.then(e, e);\n              }\n            });\n\n            return _a2 && \"function\" == typeof _a2.then ? Ce.resolve(_a2) : _d.then(function () {\n              return _a2;\n            });\n          }\n        }), i.push(function (t) {\n          if (!u || !vt) {\n            !function (e, t) {\n              [].slice.call(t.db.objectStoreNames).forEach(function (n) {\n                return null == e[n] && t.db.deleteObjectStore(n);\n              });\n            }(o._cfg.dbschema, t);\n          }\n\n          ln(e, [e.Transaction.prototype]), un(e, [e.Transaction.prototype], e._storeNames, e._dbSchema), r.schema = e._dbSchema;\n        });\n      }), l().then(function () {\n        var e, n;\n        n = s, t(e = a).forEach(function (t) {\n          n.db.objectStoreNames.contains(t) || fn(n, t, e[t].primKey, e[t].indexes);\n        });\n      });\n    }(e, n, o, r).catch(a);\n  });\n}\n\nfunction dn(e, t) {\n  var n = {\n    del: [],\n    add: [],\n    change: []\n  };\n  var r;\n\n  for (r in e) {\n    t[r] || n.del.push(r);\n  }\n\n  for (r in t) {\n    var _s2 = e[r],\n        _i2 = t[r];\n\n    if (_s2) {\n      var _e8 = {\n        name: r,\n        def: _i2,\n        recreate: !1,\n        del: [],\n        add: [],\n        change: []\n      };\n      if (\"\" + (_s2.primKey.keyPath || \"\") != \"\" + (_i2.primKey.keyPath || \"\") || _s2.primKey.auto !== _i2.primKey.auto && !mt) _e8.recreate = !0, n.change.push(_e8);else {\n        var _t8 = _s2.idxByName,\n            _r6 = _i2.idxByName;\n\n        var _o2 = void 0;\n\n        for (_o2 in _t8) {\n          _r6[_o2] || _e8.del.push(_o2);\n        }\n\n        for (_o2 in _r6) {\n          var _n13 = _t8[_o2],\n              _s3 = _r6[_o2];\n          _n13 ? _n13.src !== _s3.src && _e8.change.push(_s3) : _e8.add.push(_s3);\n        }\n\n        (_e8.del.length > 0 || _e8.add.length > 0 || _e8.change.length > 0) && n.change.push(_e8);\n      }\n    } else n.add.push([r, _i2]);\n  }\n\n  return n;\n}\n\nfunction fn(e, t, n, r) {\n  var s = e.db.createObjectStore(t, n.keyPath ? {\n    keyPath: n.keyPath,\n    autoIncrement: n.auto\n  } : {\n    autoIncrement: n.auto\n  });\n  return r.forEach(function (e) {\n    return pn(s, e);\n  }), s;\n}\n\nfunction pn(e, t) {\n  e.createIndex(t.name, t.keyPath, {\n    unique: t.unique,\n    multiEntry: t.multi\n  });\n}\n\nfunction yn(e, t, n) {\n  var r = {};\n  return p(t.objectStoreNames, 0).forEach(function (e) {\n    var t = n.objectStore(e);\n    var s = t.keyPath;\n    var i = Xt(Jt(s), s || \"\", !1, !1, !!t.autoIncrement, s && \"string\" != typeof s, !0),\n        o = [];\n\n    for (var _e9 = 0; _e9 < t.indexNames.length; ++_e9) {\n      var _n14 = t.index(t.indexNames[_e9]);\n\n      s = _n14.keyPath;\n      var a = Xt(_n14.name, s, !!_n14.unique, !!_n14.multiEntry, !1, s && \"string\" != typeof s, !1);\n      o.push(a);\n    }\n\n    r[e] = Zt(e, i, o);\n  }), r;\n}\n\nfunction mn(_ref27, n, r) {\n  var t = _ref27._novip;\n  var s = r.db.objectStoreNames;\n\n  for (var _e10 = 0; _e10 < s.length; ++_e10) {\n    var _i3 = s[_e10],\n        _o3 = r.objectStore(_i3);\n\n    t._hasGetAll = \"getAll\" in _o3;\n\n    for (var _e11 = 0; _e11 < _o3.indexNames.length; ++_e11) {\n      var _t9 = _o3.indexNames[_e11],\n          _r7 = _o3.index(_t9).keyPath,\n          _s4 = \"string\" == typeof _r7 ? _r7 : \"[\" + p(_r7).join(\"+\") + \"]\";\n\n      if (n[_i3]) {\n        var _e12 = n[_i3].idxByName[_s4];\n        _e12 && (_e12.name = _t9, delete n[_i3].idxByName[_s4], n[_i3].idxByName[_t9] = _e12);\n      }\n    }\n  }\n\n  \"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604 && (t._hasGetAll = !1);\n}\n\nvar vn = /*#__PURE__*/function () {\n  function vn() {\n    _classCallCheck(this, vn);\n  }\n\n  _createClass(vn, [{\n    key: \"_parseStoresSpec\",\n    value: function _parseStoresSpec(e, r) {\n      t(e).forEach(function (t) {\n        if (null !== e[t]) {\n          var s = e[t].split(\",\").map(function (e, t) {\n            var r = (e = e.trim()).replace(/([&*]|\\+\\+)/g, \"\"),\n                s = /^\\[/.test(r) ? r.match(/^\\[(.*)\\]$/)[1].split(\"+\") : r;\n            return Xt(r, s || null, /\\&/.test(e), /\\*/.test(e), /\\+\\+/.test(e), n(s), 0 === t);\n          }),\n              i = s.shift();\n          if (i.multi) throw new X.Schema(\"Primary key cannot be multi-valued\");\n          s.forEach(function (e) {\n            if (e.auto) throw new X.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n            if (!e.keyPath) throw new X.Schema(\"Index must have a name and cannot be an empty string\");\n          }), r[t] = Zt(t, i, s);\n        }\n      });\n    }\n  }, {\n    key: \"stores\",\n    value: function stores(e) {\n      var n = this.db;\n      this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, e) : e;\n      var s = n._versions,\n          i = {};\n      var o = {};\n      return s.forEach(function (e) {\n        r(i, e._cfg.storesSource), o = e._cfg.dbschema = {}, e._parseStoresSpec(i, o);\n      }), n._dbSchema = o, ln(n, [n._allTables, n, n.Transaction.prototype]), un(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], t(o), o), n._storeNames = t(o), this;\n    }\n  }, {\n    key: \"upgrade\",\n    value: function upgrade(e) {\n      return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee, e), this;\n    }\n  }]);\n\n  return vn;\n}();\n\nfunction gn(e, t) {\n  var n = e._dbNamesDB;\n  return n || (n = e._dbNamesDB = new $n(\"__dbnames\", {\n    addons: [],\n    indexedDB: e,\n    IDBKeyRange: t\n  }), n.version(1).stores({\n    dbnames: \"name\"\n  })), n.table(\"dbnames\");\n}\n\nfunction bn(e) {\n  return e && \"function\" == typeof e.databases;\n}\n\nfunction _n(e) {\n  return Je(function () {\n    return Ke.letThrough = !0, e();\n  });\n}\n\nfunction wn() {\n  var e;\n  return !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function (t) {\n    var n = function n() {\n      return indexedDB.databases().finally(t);\n    };\n\n    e = setInterval(n, 100), n();\n  }).finally(function () {\n    return clearInterval(e);\n  }) : Promise.resolve();\n}\n\nfunction xn(e) {\n  var n = e._state,\n      r = e._deps.indexedDB;\n  if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function () {\n    return n.dbOpenError ? ht(n.dbOpenError) : e;\n  });\n  R && (n.openCanceller._stackHolder = q()), n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;\n  var s = n.openCanceller;\n\n  function i() {\n    if (n.openCanceller !== s) throw new X.DatabaseClosed(\"db.open() was cancelled\");\n  }\n\n  var o = n.dbReadyResolve,\n      a = null,\n      u = !1;\n  return Ce.race([s, (\"undefined\" == typeof navigator ? Ce.resolve() : wn()).then(function () {\n    return new Ce(function (s, o) {\n      if (i(), !r) throw new X.MissingAPI();\n      var l = e.name,\n          c = n.autoSchema ? r.open(l) : r.open(l, Math.round(10 * e.verno));\n      if (!c) throw new X.MissingAPI();\n      c.onerror = zt(o), c.onblocked = We(e._fireOnBlocked), c.onupgradeneeded = We(function (t) {\n        if (a = c.transaction, n.autoSchema && !e._options.allowEmptyDB) {\n          c.onerror = Gt, a.abort(), c.result.close();\n\n          var _e13 = r.deleteDatabase(l);\n\n          _e13.onsuccess = _e13.onerror = We(function () {\n            o(new X.NoSuchDatabase(\"Database \".concat(l, \" doesnt exist\")));\n          });\n        } else {\n          a.onerror = zt(o);\n          var s = t.oldVersion > Math.pow(2, 62) ? 0 : t.oldVersion;\n          u = s < 1, e._novip.idbdb = c.result, hn(e, s / 10, a, o);\n        }\n      }, o), c.onsuccess = We(function () {\n        a = null;\n        var r = e._novip.idbdb = c.result,\n            i = p(r.objectStoreNames);\n        if (i.length > 0) try {\n          var _s5 = r.transaction(1 === (o = i).length ? o[0] : o, \"readonly\");\n\n          n.autoSchema ? function (_ref28, n, r) {\n            var e = _ref28._novip;\n            e.verno = n.version / 10;\n            var s = e._dbSchema = yn(0, n, r);\n            e._storeNames = p(n.objectStoreNames, 0), un(e, [e._allTables], t(s), s);\n          }(e, r, _s5) : (mn(e, e._dbSchema, _s5), function (e, t) {\n            var n = dn(yn(0, e.idbdb, t), e._dbSchema);\n            return !(n.add.length || n.change.some(function (e) {\n              return e.add.length || e.change.length;\n            }));\n          }(e, _s5) || console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\")), an(e, _s5);\n        } catch (e) {}\n        var o;\n        yt.push(e), r.onversionchange = We(function (t) {\n          n.vcFired = !0, e.on(\"versionchange\").fire(t);\n        }), r.onclose = We(function (t) {\n          e.on(\"close\").fire(t);\n        }), u && function (_ref29, n) {\n          var e = _ref29.indexedDB,\n              t = _ref29.IDBKeyRange;\n          !bn(e) && \"__dbnames\" !== n && gn(e, t).put({\n            name: n\n          }).catch(ee);\n        }(e._deps, l), s();\n      }, o);\n    });\n  })]).then(function () {\n    return i(), n.onReadyBeingFired = [], Ce.resolve(_n(function () {\n      return e.on.ready.fire(e.vip);\n    })).then(function t() {\n      if (n.onReadyBeingFired.length > 0) {\n        var _r8 = n.onReadyBeingFired.reduce(ue, ee);\n\n        return n.onReadyBeingFired = [], Ce.resolve(_n(function () {\n          return _r8(e.vip);\n        })).then(t);\n      }\n    });\n  }).finally(function () {\n    n.onReadyBeingFired = null, n.isBeingOpened = !1;\n  }).then(function () {\n    return e;\n  }).catch(function (t) {\n    n.dbOpenError = t;\n\n    try {\n      a && a.abort();\n    } catch (e) {}\n\n    return s === n.openCanceller && e._close(), ht(t);\n  }).finally(function () {\n    n.openComplete = !0, o();\n  });\n}\n\nfunction kn(e) {\n  var t = function t(_t10) {\n    return e.next(_t10);\n  },\n      r = i(t),\n      s = i(function (t) {\n    return e.throw(t);\n  });\n\n  function i(e) {\n    return function (t) {\n      var i = e(t),\n          o = i.value;\n      return i.done ? o : o && \"function\" == typeof o.then ? o.then(r, s) : n(o) ? Promise.all(o).then(r, s) : r(o);\n    };\n  }\n\n  return i(t)();\n}\n\nfunction En(e, t, n) {\n  var r = arguments.length;\n  if (r < 2) throw new X.InvalidArgument(\"Too few arguments\");\n\n  for (var s = new Array(r - 1); --r;) {\n    s[r - 1] = arguments[r];\n  }\n\n  n = s.pop();\n  var i = k(s);\n  return [e, i, n];\n}\n\nfunction Pn(e, t, n, r, s) {\n  return Ce.resolve().then(function () {\n    var i = Ke.transless || Ke,\n        o = e._createTransaction(t, n, e._dbSchema, r),\n        a = {\n      trans: o,\n      transless: i\n    };\n\n    if (r) o.idbtrans = r.idbtrans;else try {\n      o.create(), e._state.PR1398_maxLoop = 3;\n    } catch (r) {\n      return r.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(function () {\n        return Pn(e, t, n, null, s);\n      })) : ht(r);\n    }\n    var u = T(s);\n    var l;\n    u && Ze();\n    var c = Ce.follow(function () {\n      if (l = s.call(o, o), l) if (u) {\n        var e = et.bind(null, null);\n        l.then(e, e);\n      } else \"function\" == typeof l.next && \"function\" == typeof l.throw && (l = kn(l));\n    }, a);\n    return (l && \"function\" == typeof l.then ? Ce.resolve(l).then(function (e) {\n      return o.active ? e : ht(new X.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"));\n    }) : c.then(function () {\n      return l;\n    })).then(function (e) {\n      return r && o._resolve(), o._completion.then(function () {\n        return e;\n      });\n    }).catch(function (e) {\n      return o._reject(e), ht(e);\n    });\n  });\n}\n\nfunction Kn(e, t, r) {\n  var s = n(e) ? e.slice() : [e];\n\n  for (var _e14 = 0; _e14 < r; ++_e14) {\n    s.push(t);\n  }\n\n  return s;\n}\n\nvar On = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: function create(e) {\n    return _objectSpread(_objectSpread({}, e), {}, {\n      table: function table(t) {\n        var n = e.table(t),\n            r = n.schema,\n            s = {},\n            i = [];\n\n        function o(e, t, n) {\n          var r = sn(e),\n              a = s[r] = s[r] || [],\n              u = null == e ? 0 : \"string\" == typeof e ? 1 : e.length,\n              l = t > 0,\n              c = _objectSpread(_objectSpread({}, n), {}, {\n            isVirtual: l,\n            keyTail: t,\n            keyLength: u,\n            extractKey: tn(e),\n            unique: !l && n.unique\n          });\n\n          if (a.push(c), c.isPrimaryKey || i.push(c), u > 1) {\n            o(2 === u ? e[0] : e.slice(0, u - 1), t + 1, n);\n          }\n\n          return a.sort(function (e, t) {\n            return e.keyTail - t.keyTail;\n          }), c;\n        }\n\n        var a = o(r.primaryKey.keyPath, 0, r.primaryKey);\n        s[\":id\"] = [a];\n\n        var _iterator2 = _createForOfIteratorHelper(r.indexes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _e15 = _step2.value;\n            o(_e15.keyPath, 0, _e15);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        function u(t) {\n          var n = t.query.index;\n          return n.isVirtual ? _objectSpread(_objectSpread({}, t), {}, {\n            query: {\n              index: n,\n              range: (r = t.query.range, s = n.keyTail, {\n                type: 1 === r.type ? 2 : r.type,\n                lower: Kn(r.lower, r.lowerOpen ? e.MAX_KEY : e.MIN_KEY, s),\n                lowerOpen: !0,\n                upper: Kn(r.upper, r.upperOpen ? e.MIN_KEY : e.MAX_KEY, s),\n                upperOpen: !0\n              })\n            }\n          }) : t;\n          var r, s;\n        }\n\n        var l = _objectSpread(_objectSpread({}, n), {}, {\n          schema: _objectSpread(_objectSpread({}, r), {}, {\n            primaryKey: a,\n            indexes: i,\n            getIndexByKeyPath: function getIndexByKeyPath(e) {\n              var t = s[sn(e)];\n              return t && t[0];\n            }\n          }),\n          count: function count(e) {\n            return n.count(u(e));\n          },\n          query: function query(e) {\n            return n.query(u(e));\n          },\n          openCursor: function openCursor(t) {\n            var _t$query$index = t.query.index,\n                r = _t$query$index.keyTail,\n                s = _t$query$index.isVirtual,\n                i = _t$query$index.keyLength;\n            if (!s) return n.openCursor(t);\n            return n.openCursor(u(t)).then(function (n) {\n              return n && function (n) {\n                var s = Object.create(n, {\n                  continue: {\n                    value: function value(s) {\n                      null != s ? n.continue(Kn(s, t.reverse ? e.MAX_KEY : e.MIN_KEY, r)) : t.unique ? n.continue(n.key.slice(0, i).concat(t.reverse ? e.MIN_KEY : e.MAX_KEY, r)) : n.continue();\n                    }\n                  },\n                  continuePrimaryKey: {\n                    value: function value(t, s) {\n                      n.continuePrimaryKey(Kn(t, e.MAX_KEY, r), s);\n                    }\n                  },\n                  primaryKey: {\n                    get: function get() {\n                      return n.primaryKey;\n                    }\n                  },\n                  key: {\n                    get: function get() {\n                      var e = n.key;\n                      return 1 === i ? e[0] : e.slice(0, i);\n                    }\n                  },\n                  value: {\n                    get: function get() {\n                      return n.value;\n                    }\n                  }\n                });\n                return s;\n              }(n);\n            });\n          }\n        });\n\n        return l;\n      }\n    });\n  }\n};\n\nfunction Sn(e, n, r, s) {\n  return r = r || {}, s = s || \"\", t(e).forEach(function (t) {\n    if (o(n, t)) {\n      var i = e[t],\n          a = n[t];\n\n      if (\"object\" == typeof i && \"object\" == typeof a && i && a) {\n        var _e16 = C(i);\n\n        _e16 !== C(a) ? r[s + t] = n[t] : \"Object\" === _e16 ? Sn(i, a, r, s + t + \".\") : i !== a && (r[s + t] = n[t]);\n      } else i !== a && (r[s + t] = n[t]);\n    } else r[s + t] = void 0;\n  }), t(n).forEach(function (t) {\n    o(e, t) || (r[s + t] = n[t]);\n  }), r;\n}\n\nvar An = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: function create(e) {\n    return _objectSpread(_objectSpread({}, e), {}, {\n      table: function table(t) {\n        var n = e.table(t),\n            r = n.schema.primaryKey,\n            s = _objectSpread(_objectSpread({}, n), {}, {\n          mutate: function mutate(e) {\n            var s = Ke.trans,\n                _s$table$hook = s.table(t).hook,\n                i = _s$table$hook.deleting,\n                a = _s$table$hook.creating,\n                u = _s$table$hook.updating;\n\n            switch (e.type) {\n              case \"add\":\n                if (a.fire === ee) break;\n                return s._promise(\"readwrite\", function () {\n                  return l(e);\n                }, !0);\n\n              case \"put\":\n                if (a.fire === ee && u.fire === ee) break;\n                return s._promise(\"readwrite\", function () {\n                  return l(e);\n                }, !0);\n\n              case \"delete\":\n                if (i.fire === ee) break;\n                return s._promise(\"readwrite\", function () {\n                  return l(e);\n                }, !0);\n\n              case \"deleteRange\":\n                if (i.fire === ee) break;\n                return s._promise(\"readwrite\", function () {\n                  return function (e) {\n                    return c(e.trans, e.range, 1e4);\n                  }(e);\n                }, !0);\n            }\n\n            return n.mutate(e);\n\n            function l(e) {\n              var t = Ke.trans,\n                  s = e.keys || function (e, t) {\n                return \"delete\" === t.type ? t.keys : t.keys || t.values.map(e.extractKey);\n              }(r, e);\n\n              if (!s) throw new Error(\"Keys missing\");\n              return \"delete\" !== (e = \"add\" === e.type || \"put\" === e.type ? _objectSpread(_objectSpread({}, e), {}, {\n                keys: s\n              }) : _objectSpread({}, e)).type && (e.values = _toConsumableArray(e.values)), e.keys && (e.keys = _toConsumableArray(e.keys)), function (e, t, n) {\n                return \"add\" === t.type ? Promise.resolve([]) : e.getMany({\n                  trans: t.trans,\n                  keys: n,\n                  cache: \"immutable\"\n                });\n              }(n, e, s).then(function (l) {\n                var c = s.map(function (n, s) {\n                  var c = l[s],\n                      h = {\n                    onerror: null,\n                    onsuccess: null\n                  };\n                  if (\"delete\" === e.type) i.fire.call(h, n, c, t);else if (\"add\" === e.type || void 0 === c) {\n                    var _i4 = a.fire.call(h, n, e.values[s], t);\n\n                    null == n && null != _i4 && (n = _i4, e.keys[s] = n, r.outbound || _(e.values[s], r.keyPath, n));\n                  } else {\n                    var _r9 = Sn(c, e.values[s]),\n                        _i5 = u.fire.call(h, _r9, n, c, t);\n\n                    if (_i5) {\n                      var _t11 = e.values[s];\n                      Object.keys(_i5).forEach(function (e) {\n                        o(_t11, e) ? _t11[e] = _i5[e] : _(_t11, e, _i5[e]);\n                      });\n                    }\n                  }\n                  return h;\n                });\n                return n.mutate(e).then(function (_ref30) {\n                  var t = _ref30.failures,\n                      n = _ref30.results,\n                      r = _ref30.numFailures,\n                      i = _ref30.lastResult;\n\n                  for (var _r10 = 0; _r10 < s.length; ++_r10) {\n                    var _i6 = n ? n[_r10] : s[_r10],\n                        _o4 = c[_r10];\n\n                    null == _i6 ? _o4.onerror && _o4.onerror(t[_r10]) : _o4.onsuccess && _o4.onsuccess(\"put\" === e.type && l[_r10] ? e.values[_r10] : _i6);\n                  }\n\n                  return {\n                    failures: t,\n                    results: n,\n                    numFailures: r,\n                    lastResult: i\n                  };\n                }).catch(function (e) {\n                  return c.forEach(function (t) {\n                    return t.onerror && t.onerror(e);\n                  }), Promise.reject(e);\n                });\n              });\n            }\n\n            function c(e, t, s) {\n              return n.query({\n                trans: e,\n                values: !1,\n                query: {\n                  index: r,\n                  range: t\n                },\n                limit: s\n              }).then(function (_ref31) {\n                var n = _ref31.result;\n                return l({\n                  type: \"delete\",\n                  keys: n,\n                  trans: e\n                }).then(function (r) {\n                  return r.numFailures > 0 ? Promise.reject(r.failures[0]) : n.length < s ? {\n                    failures: [],\n                    numFailures: 0,\n                    lastResult: void 0\n                  } : c(e, _objectSpread(_objectSpread({}, t), {}, {\n                    lower: n[n.length - 1],\n                    lowerOpen: !0\n                  }), s);\n                });\n              });\n            }\n          }\n        });\n\n        return s;\n      }\n    });\n  }\n};\n\nfunction Cn(e, t, n) {\n  try {\n    if (!t) return null;\n    if (t.keys.length < e.length) return null;\n    var _r11 = [];\n\n    for (var _s6 = 0, _i7 = 0; _s6 < t.keys.length && _i7 < e.length; ++_s6) {\n      0 === It(t.keys[_s6], e[_i7]) && (_r11.push(n ? O(t.values[_s6]) : t.values[_s6]), ++_i7);\n    }\n\n    return _r11.length === e.length ? _r11 : null;\n  } catch (e) {\n    return null;\n  }\n}\n\nvar jn = {\n  stack: \"dbcore\",\n  level: -1,\n  create: function create(e) {\n    return {\n      table: function table(t) {\n        var n = e.table(t);\n        return _objectSpread(_objectSpread({}, n), {}, {\n          getMany: function getMany(e) {\n            if (!e.cache) return n.getMany(e);\n            var t = Cn(e.keys, e.trans._cache, \"clone\" === e.cache);\n            return t ? Ce.resolve(t) : n.getMany(e).then(function (t) {\n              return e.trans._cache = {\n                keys: e.keys,\n                values: \"clone\" === e.cache ? O(t) : t\n              }, t;\n            });\n          },\n          mutate: function mutate(e) {\n            return \"add\" !== e.type && (e.trans._cache = null), n.mutate(e);\n          }\n        });\n      }\n    };\n  }\n};\n\nfunction Dn(e) {\n  return !(\"from\" in e);\n}\n\nvar In = function In(e, t) {\n  if (!this) {\n    var _t12 = new In();\n\n    return e && \"d\" in e && r(_t12, e), _t12;\n  }\n\n  r(this, arguments.length ? {\n    d: 1,\n    from: e,\n    to: arguments.length > 1 ? t : e\n  } : {\n    d: 0\n  });\n};\n\nfunction Bn(e, t, n) {\n  var s = It(t, n);\n  if (isNaN(s)) return;\n  if (s > 0) throw RangeError();\n  if (Dn(e)) return r(e, {\n    from: t,\n    to: n,\n    d: 1\n  });\n  var i = e.l,\n      o = e.r;\n  if (It(n, e.from) < 0) return i ? Bn(i, t, n) : e.l = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Mn(e);\n  if (It(t, e.to) > 0) return o ? Bn(o, t, n) : e.r = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Mn(e);\n  It(t, e.from) < 0 && (e.from = t, e.l = null, e.d = o ? o.d + 1 : 1), It(n, e.to) > 0 && (e.to = n, e.r = null, e.d = e.l ? e.l.d + 1 : 1);\n  var a = !e.r;\n  i && !e.l && Tn(e, i), o && a && Tn(e, o);\n}\n\nfunction Tn(e, t) {\n  Dn(t) || function e(t, _ref32) {\n    var n = _ref32.from,\n        r = _ref32.to,\n        s = _ref32.l,\n        i = _ref32.r;\n    Bn(t, n, r), s && e(t, s), i && e(t, i);\n  }(e, t);\n}\n\nfunction Rn(e, t) {\n  var n = Fn(t);\n  var r = n.next();\n  if (r.done) return !1;\n  var s = r.value;\n  var i = Fn(e);\n  var o = i.next(s.from),\n      a = o.value;\n\n  for (; !r.done && !o.done;) {\n    if (It(a.from, s.to) <= 0 && It(a.to, s.from) >= 0) return !0;\n    It(s.from, a.from) < 0 ? s = (r = n.next(a.from)).value : a = (o = i.next(s.from)).value;\n  }\n\n  return !1;\n}\n\nfunction Fn(e) {\n  var t = Dn(e) ? null : {\n    s: 0,\n    n: e\n  };\n  return {\n    next: function next(e) {\n      var n = arguments.length > 0;\n\n      for (; t;) {\n        switch (t.s) {\n          case 0:\n            if (t.s = 1, n) for (; t.n.l && It(e, t.n.from) < 0;) {\n              t = {\n                up: t,\n                n: t.n.l,\n                s: 1\n              };\n            } else for (; t.n.l;) {\n              t = {\n                up: t,\n                n: t.n.l,\n                s: 1\n              };\n            }\n\n          case 1:\n            if (t.s = 2, !n || It(e, t.n.to) <= 0) return {\n              value: t.n,\n              done: !1\n            };\n\n          case 2:\n            if (t.n.r) {\n              t.s = 3, t = {\n                up: t,\n                n: t.n.r,\n                s: 0\n              };\n              continue;\n            }\n\n          case 3:\n            t = t.up;\n        }\n      }\n\n      return {\n        done: !0\n      };\n    }\n  };\n}\n\nfunction Mn(e) {\n  var t, n;\n  var r = ((null === (t = e.r) || void 0 === t ? void 0 : t.d) || 0) - ((null === (n = e.l) || void 0 === n ? void 0 : n.d) || 0),\n      s = r > 1 ? \"r\" : r < -1 ? \"l\" : \"\";\n\n  if (s) {\n    var _t13 = \"r\" === s ? \"l\" : \"r\",\n        _n15 = _objectSpread({}, e),\n        _r12 = e[s];\n\n    e.from = _r12.from, e.to = _r12.to, e[s] = _r12[s], _n15[s] = _r12[_t13], e[_t13] = _n15, _n15.d = Nn(_n15);\n  }\n\n  e.d = Nn(e);\n}\n\nfunction Nn(_ref33) {\n  var e = _ref33.r,\n      t = _ref33.l;\n  return (e ? t ? Math.max(e.d, t.d) : e.d : t ? t.d : 0) + 1;\n}\n\na(In.prototype, _defineProperty({\n  add: function add(e) {\n    return Tn(this, e), this;\n  },\n  addKey: function addKey(e) {\n    return Bn(this, e, e), this;\n  },\n  addKeys: function addKeys(e) {\n    var _this21 = this;\n\n    return e.forEach(function (e) {\n      return Bn(_this21, e, e);\n    }), this;\n  }\n}, j, function () {\n  return Fn(this);\n}));\nvar qn = {\n  stack: \"dbcore\",\n  level: 0,\n  create: function create(e) {\n    var r = e.schema.name,\n        s = new In(e.MIN_KEY, e.MAX_KEY);\n    return _objectSpread(_objectSpread({}, e), {}, {\n      table: function table(i) {\n        var o = e.table(i),\n            a = o.schema,\n            u = a.primaryKey,\n            l = u.extractKey,\n            c = u.outbound,\n            h = _objectSpread(_objectSpread({}, o), {}, {\n          mutate: function mutate(e) {\n            var t = e.trans,\n                u = t.mutatedParts || (t.mutatedParts = {}),\n                l = function l(e) {\n              var t = \"idb://\".concat(r, \"/\").concat(i, \"/\").concat(e);\n              return u[t] || (u[t] = new In());\n            },\n                c = l(\"\"),\n                h = l(\":dels\"),\n                d = e.type;\n\n            var _ref34 = \"deleteRange\" === e.type ? [e.range] : \"delete\" === e.type ? [e.keys] : e.values.length < 50 ? [[], e.values] : [],\n                _ref35 = _slicedToArray(_ref34, 2),\n                f = _ref35[0],\n                p = _ref35[1];\n\n            var y = e.trans._cache;\n            return o.mutate(e).then(function (e) {\n              if (n(f)) {\n                \"delete\" !== d && (f = e.results), c.addKeys(f);\n\n                var _t14 = Cn(f, y);\n\n                _t14 || \"add\" === d || h.addKeys(f), (_t14 || p) && function (e, t, r, s) {\n                  function i(t) {\n                    var i = e(t.name || \"\");\n\n                    function o(e) {\n                      return null != e ? t.extractKey(e) : null;\n                    }\n\n                    var a = function a(e) {\n                      return t.multiEntry && n(e) ? e.forEach(function (e) {\n                        return i.addKey(e);\n                      }) : i.addKey(e);\n                    };\n\n                    (r || s).forEach(function (e, t) {\n                      var n = r && o(r[t]),\n                          i = s && o(s[t]);\n                      0 !== It(n, i) && (null != n && a(n), null != i && a(i));\n                    });\n                  }\n\n                  t.indexes.forEach(i);\n                }(l, a, _t14, p);\n              } else if (f) {\n                var _e17 = {\n                  from: f.lower,\n                  to: f.upper\n                };\n                h.add(_e17), c.add(_e17);\n              } else c.add(s), h.add(s), a.indexes.forEach(function (e) {\n                return l(e.name).add(s);\n              });\n\n              return e;\n            });\n          }\n        }),\n            d = function d(_ref36) {\n          var _ref36$query = _ref36.query,\n              t = _ref36$query.index,\n              n = _ref36$query.range;\n          var r, s;\n          return [t, new In(null !== (r = n.lower) && void 0 !== r ? r : e.MIN_KEY, null !== (s = n.upper) && void 0 !== s ? s : e.MAX_KEY)];\n        },\n            f = {\n          get: function get(e) {\n            return [u, new In(e.key)];\n          },\n          getMany: function getMany(e) {\n            return [u, new In().addKeys(e.keys)];\n          },\n          count: d,\n          query: d,\n          openCursor: d\n        };\n\n        return t(f).forEach(function (e) {\n          h[e] = function (t) {\n            var _Ke = Ke,\n                n = _Ke.subscr;\n\n            if (n) {\n              var _a4 = function _a4(e) {\n                var t = \"idb://\".concat(r, \"/\").concat(i, \"/\").concat(e);\n                return n[t] || (n[t] = new In());\n              },\n                  _u = _a4(\"\"),\n                  _h = _a4(\":dels\"),\n                  _f$e = f[e](t),\n                  _f$e2 = _slicedToArray(_f$e, 2),\n                  _d2 = _f$e2[0],\n                  _p = _f$e2[1];\n\n              if (_a4(_d2.name || \"\").add(_p), !_d2.isPrimaryKey) {\n                if (\"count\" !== e) {\n                  var _n16 = \"query\" === e && c && t.values && o.query(_objectSpread(_objectSpread({}, t), {}, {\n                    values: !1\n                  }));\n\n                  return o[e].apply(this, arguments).then(function (r) {\n                    if (\"query\" === e) {\n                      if (c && t.values) return _n16.then(function (_ref37) {\n                        var e = _ref37.result;\n                        return _u.addKeys(e), r;\n                      });\n\n                      var _e18 = t.values ? r.result.map(l) : r.result;\n\n                      t.values ? _u.addKeys(_e18) : _h.addKeys(_e18);\n                    } else if (\"openCursor\" === e) {\n                      var _e19 = r,\n                          _n17 = t.values;\n                      return _e19 && Object.create(_e19, {\n                        key: {\n                          get: function get() {\n                            return _h.addKey(_e19.primaryKey), _e19.key;\n                          }\n                        },\n                        primaryKey: {\n                          get: function get() {\n                            var t = _e19.primaryKey;\n                            return _h.addKey(t), t;\n                          }\n                        },\n                        value: {\n                          get: function get() {\n                            return _n17 && _u.addKey(_e19.primaryKey), _e19.value;\n                          }\n                        }\n                      });\n                    }\n\n                    return r;\n                  });\n                }\n\n                _h.add(s);\n              }\n            }\n\n            return o[e].apply(this, arguments);\n          };\n        }), h;\n      }\n    });\n  }\n};\n\nvar $n = /*#__PURE__*/function () {\n  function $n(e, t) {\n    var _this22 = this;\n\n    _classCallCheck(this, $n);\n\n    this._middlewares = {}, this.verno = 0;\n    var n = $n.dependencies;\n    this._options = t = _objectSpread({\n      addons: $n.addons,\n      autoOpen: !0,\n      indexedDB: n.indexedDB,\n      IDBKeyRange: n.IDBKeyRange\n    }, t), this._deps = {\n      indexedDB: t.indexedDB,\n      IDBKeyRange: t.IDBKeyRange\n    };\n    var _t15 = t,\n        r = _t15.addons;\n    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;\n    var s = {\n      dbOpenError: null,\n      isBeingOpened: !1,\n      onReadyBeingFired: null,\n      openComplete: !1,\n      dbReadyResolve: ee,\n      dbReadyPromise: null,\n      cancelOpen: ee,\n      openCanceller: null,\n      autoSchema: !0,\n      PR1398_maxLoop: 3\n    };\n    var i;\n    s.dbReadyPromise = new Ce(function (e) {\n      s.dbReadyResolve = e;\n    }), s.openCanceller = new Ce(function (e, t) {\n      s.cancelOpen = t;\n    }), this._state = s, this.name = e, this.on = Et(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [ue, ee]\n    }), this.on.ready.subscribe = y(this.on.ready.subscribe, function (e) {\n      return function (t, n) {\n        $n.vip(function () {\n          var r = _this22._state;\n          if (r.openComplete) r.dbOpenError || Ce.resolve().then(t), n && e(t);else if (r.onReadyBeingFired) r.onReadyBeingFired.push(t), n && e(t);else {\n            e(t);\n            var _r13 = _this22;\n            n || e(function e() {\n              _r13.on.ready.unsubscribe(t), _r13.on.ready.unsubscribe(e);\n            });\n          }\n        });\n      };\n    }), this.Collection = (i = this, Pt(Rt.prototype, function (e, t) {\n      this.db = i;\n      var n = wt,\n          r = null;\n      if (t) try {\n        n = t();\n      } catch (e) {\n        r = e;\n      }\n      var s = e._ctx,\n          o = s.table,\n          a = o.hook.reading.fire;\n      this._ctx = {\n        table: o,\n        index: s.index,\n        isPrimKey: !s.index || o.schema.primKey.keyPath && s.index === o.schema.primKey.name,\n        range: n,\n        keysOnly: !1,\n        dir: \"next\",\n        unique: \"\",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: !0,\n        isMatch: null,\n        offset: 0,\n        limit: 1 / 0,\n        error: r,\n        or: s.or,\n        valueMapper: a !== te ? a : null\n      };\n    })), this.Table = function (e) {\n      return Pt(kt.prototype, function (t, n, r) {\n        this.db = e, this._tx = r, this.name = t, this.schema = n, this.hook = e._allTables[t] ? e._allTables[t].hook : Et(null, {\n          creating: [se, ee],\n          reading: [ne, te],\n          updating: [oe, ee],\n          deleting: [ie, ee]\n        });\n      });\n    }(this), this.Transaction = function (e) {\n      return Pt(Qt.prototype, function (t, n, r, s, i) {\n        var _this23 = this;\n\n        this.db = e, this.mode = t, this.storeNames = n, this.schema = r, this.chromeTransactionDurability = s, this.idbtrans = null, this.on = Et(this, \"complete\", \"error\", \"abort\"), this.parent = i || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ce(function (e, t) {\n          _this23._resolve = e, _this23._reject = t;\n        }), this._completion.then(function () {\n          _this23.active = !1, _this23.on.complete.fire();\n        }, function (e) {\n          var t = _this23.active;\n          return _this23.active = !1, _this23.on.error.fire(e), _this23.parent ? _this23.parent._reject(e) : t && _this23.idbtrans && _this23.idbtrans.abort(), ht(e);\n        });\n      });\n    }(this), this.Version = function (e) {\n      return Pt(vn.prototype, function (t) {\n        this.db = e, this._cfg = {\n          version: t,\n          storesSource: null,\n          dbschema: {},\n          tables: {},\n          contentUpgrade: null\n        };\n      });\n    }(this), this.WhereClause = function (e) {\n      return Pt(Yt.prototype, function (t, n, r) {\n        this.db = e, this._ctx = {\n          table: t,\n          index: \":id\" === n ? null : n,\n          or: r\n        };\n        var s = e._deps.indexedDB;\n        if (!s) throw new X.MissingAPI();\n        this._cmp = this._ascending = s.cmp.bind(s), this._descending = function (e, t) {\n          return s.cmp(t, e);\n        }, this._max = function (e, t) {\n          return s.cmp(e, t) > 0 ? e : t;\n        }, this._min = function (e, t) {\n          return s.cmp(e, t) < 0 ? e : t;\n        }, this._IDBKeyRange = e._deps.IDBKeyRange;\n      });\n    }(this), this.on(\"versionchange\", function (e) {\n      e.newVersion > 0 ? console.warn(\"Another connection wants to upgrade database '\".concat(_this22.name, \"'. Closing db now to resume the upgrade.\")) : console.warn(\"Another connection wants to delete database '\".concat(_this22.name, \"'. Closing db now to resume the delete request.\")), _this22.close();\n    }), this.on(\"blocked\", function (e) {\n      !e.newVersion || e.newVersion < e.oldVersion ? console.warn(\"Dexie.delete('\".concat(_this22.name, \"') was blocked\")) : console.warn(\"Upgrade '\".concat(_this22.name, \"' blocked by other connection holding version \").concat(e.oldVersion / 10));\n    }), this._maxKey = _en(t.IDBKeyRange), this._createTransaction = function (e, t, n, r) {\n      return new _this22.Transaction(e, t, n, _this22._options.chromeTransactionDurability, r);\n    }, this._fireOnBlocked = function (e) {\n      _this22.on(\"blocked\").fire(e), yt.filter(function (e) {\n        return e.name === _this22.name && e !== _this22 && !e._state.vcFired;\n      }).map(function (t) {\n        return t.on(\"versionchange\").fire(e);\n      });\n    }, this.use(On), this.use(An), this.use(qn), this.use(jn), this.vip = Object.create(this, {\n      _vip: {\n        value: !0\n      }\n    }), r.forEach(function (e) {\n      return e(_this22);\n    });\n  }\n\n  _createClass($n, [{\n    key: \"version\",\n    value: function version(e) {\n      if (isNaN(e) || e < .1) throw new X.Type(\"Given version is not a positive number\");\n      if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new X.Schema(\"Cannot add version when database is open\");\n      this.verno = Math.max(this.verno, e);\n      var t = this._versions;\n      var n = t.filter(function (t) {\n        return t._cfg.version === e;\n      })[0];\n      return n || (n = new this.Version(e), t.push(n), t.sort(cn), n.stores({}), this._state.autoSchema = !1, n);\n    }\n  }, {\n    key: \"_whenReady\",\n    value: function _whenReady(e) {\n      var _this24 = this;\n\n      return this.idbdb && (this._state.openComplete || Ke.letThrough || this._vip) ? e() : new Ce(function (e, t) {\n        if (_this24._state.openComplete) return t(new X.DatabaseClosed(_this24._state.dbOpenError));\n\n        if (!_this24._state.isBeingOpened) {\n          if (!_this24._options.autoOpen) return void t(new X.DatabaseClosed());\n\n          _this24.open().catch(ee);\n        }\n\n        _this24._state.dbReadyPromise.then(e, t);\n      }).then(e);\n    }\n  }, {\n    key: \"use\",\n    value: function use(_ref38) {\n      var e = _ref38.stack,\n          t = _ref38.create,\n          n = _ref38.level,\n          r = _ref38.name;\n      r && this.unuse({\n        stack: e,\n        name: r\n      });\n      var s = this._middlewares[e] || (this._middlewares[e] = []);\n      return s.push({\n        stack: e,\n        create: t,\n        level: null == n ? 10 : n,\n        name: r\n      }), s.sort(function (e, t) {\n        return e.level - t.level;\n      }), this;\n    }\n  }, {\n    key: \"unuse\",\n    value: function unuse(_ref39) {\n      var e = _ref39.stack,\n          t = _ref39.name,\n          n = _ref39.create;\n      return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter(function (e) {\n        return n ? e.create !== n : !!t && e.name !== t;\n      })), this;\n    }\n  }, {\n    key: \"open\",\n    value: function open() {\n      return xn(this);\n    }\n  }, {\n    key: \"_close\",\n    value: function _close() {\n      var e = this._state,\n          t = yt.indexOf(this);\n\n      if (t >= 0 && yt.splice(t, 1), this.idbdb) {\n        try {\n          this.idbdb.close();\n        } catch (e) {}\n\n        this._novip.idbdb = null;\n      }\n\n      e.dbReadyPromise = new Ce(function (t) {\n        e.dbReadyResolve = t;\n      }), e.openCanceller = new Ce(function (t, n) {\n        e.cancelOpen = n;\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._close();\n\n      var e = this._state;\n      this._options.autoOpen = !1, e.dbOpenError = new X.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _this25 = this;\n\n      var e = arguments.length > 0,\n          t = this._state;\n      return new Ce(function (n, r) {\n        var s = function s() {\n          _this25.close();\n\n          var e = _this25._deps.indexedDB.deleteDatabase(_this25.name);\n\n          e.onsuccess = We(function () {\n            !function (_ref40, n) {\n              var e = _ref40.indexedDB,\n                  t = _ref40.IDBKeyRange;\n              !bn(e) && \"__dbnames\" !== n && gn(e, t).delete(n).catch(ee);\n            }(_this25._deps, _this25.name), n();\n          }), e.onerror = zt(r), e.onblocked = _this25._fireOnBlocked;\n        };\n\n        if (e) throw new X.InvalidArgument(\"Arguments not allowed in db.delete()\");\n        t.isBeingOpened ? t.dbReadyPromise.then(s) : s();\n      });\n    }\n  }, {\n    key: \"backendDB\",\n    value: function backendDB() {\n      return this.idbdb;\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return null !== this.idbdb;\n    }\n  }, {\n    key: \"hasBeenClosed\",\n    value: function hasBeenClosed() {\n      var e = this._state.dbOpenError;\n      return e && \"DatabaseClosed\" === e.name;\n    }\n  }, {\n    key: \"hasFailed\",\n    value: function hasFailed() {\n      return null !== this._state.dbOpenError;\n    }\n  }, {\n    key: \"dynamicallyOpened\",\n    value: function dynamicallyOpened() {\n      return this._state.autoSchema;\n    }\n  }, {\n    key: \"tables\",\n    get: function get() {\n      var _this26 = this;\n\n      return t(this._allTables).map(function (e) {\n        return _this26._allTables[e];\n      });\n    }\n  }, {\n    key: \"transaction\",\n    value: function transaction() {\n      var e = En.apply(this, arguments);\n      return this._transaction.apply(this, e);\n    }\n  }, {\n    key: \"_transaction\",\n    value: function _transaction(e, t, n) {\n      var _this27 = this;\n\n      var r = Ke.trans;\n      r && r.db === this && -1 === e.indexOf(\"!\") || (r = null);\n      var s = -1 !== e.indexOf(\"?\");\n      var i, o;\n      e = e.replace(\"!\", \"\").replace(\"?\", \"\");\n\n      try {\n        if (o = t.map(function (e) {\n          var t = e instanceof _this27.Table ? e.name : e;\n          if (\"string\" != typeof t) throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n          return t;\n        }), \"r\" == e || \"readonly\" === e) i = \"readonly\";else {\n          if (\"rw\" != e && \"readwrite\" != e) throw new X.InvalidArgument(\"Invalid transaction mode: \" + e);\n          i = \"readwrite\";\n        }\n\n        if (r) {\n          if (\"readonly\" === r.mode && \"readwrite\" === i) {\n            if (!s) throw new X.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n            r = null;\n          }\n\n          r && o.forEach(function (e) {\n            if (r && -1 === r.storeNames.indexOf(e)) {\n              if (!s) throw new X.SubTransaction(\"Table \" + e + \" not included in parent transaction.\");\n              r = null;\n            }\n          }), s && r && !r.active && (r = null);\n        }\n      } catch (e) {\n        return r ? r._promise(null, function (t, n) {\n          n(e);\n        }) : ht(e);\n      }\n\n      var a = Pn.bind(null, this, i, o, r, n);\n      return r ? r._promise(i, a, \"lock\") : Ke.trans ? ot(Ke.transless, function () {\n        return _this27._whenReady(a);\n      }) : this._whenReady(a);\n    }\n  }, {\n    key: \"table\",\n    value: function table(e) {\n      if (!o(this._allTables, e)) throw new X.InvalidTable(\"Table \".concat(e, \" does not exist\"));\n      return this._allTables[e];\n    }\n  }]);\n\n  return $n;\n}();\n\nvar Un = \"undefined\" != typeof Symbol && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\n\nvar Ln = /*#__PURE__*/function () {\n  function Ln(e) {\n    _classCallCheck(this, Ln);\n\n    this._subscribe = e;\n  }\n\n  _createClass(Ln, [{\n    key: \"subscribe\",\n    value: function subscribe(e, t, n) {\n      return this._subscribe(e && \"function\" != typeof e ? e : {\n        next: e,\n        error: t,\n        complete: n\n      });\n    }\n  }, {\n    key: Un,\n    value: function value() {\n      return this;\n    }\n  }]);\n\n  return Ln;\n}();\n\nfunction Vn(e, n) {\n  return t(n).forEach(function (t) {\n    Tn(e[t] || (e[t] = new In()), n[t]);\n  }), e;\n}\n\nfunction Wn(e) {\n  return new Ln(function (n) {\n    var r = T(e);\n    var s = !1,\n        i = {},\n        o = {};\n    var a = {\n      get closed() {\n        return s;\n      },\n\n      unsubscribe: function unsubscribe() {\n        s = !0, Ht.storagemutated.unsubscribe(h);\n      }\n    };\n    n.start && n.start(a);\n    var u = !1,\n        l = !1;\n\n    function c() {\n      return t(o).some(function (e) {\n        return i[e] && Rn(i[e], o[e]);\n      });\n    }\n\n    var h = function h(e) {\n      Vn(i, e), c() && d();\n    },\n        d = function d() {\n      if (u || s) return;\n      i = {};\n\n      var t = {},\n          f = function (t) {\n        r && Ze();\n\n        var n = function n() {\n          return Je(e, {\n            subscr: t,\n            trans: null\n          });\n        },\n            s = Ke.trans ? ot(Ke.transless, n) : n();\n\n        return r && s.then(et, et), s;\n      }(t);\n\n      l || (Ht(\"storagemutated\", h), l = !0), u = !0, Promise.resolve(f).then(function (e) {\n        u = !1, s || (c() ? d() : (i = {}, o = t, n.next && n.next(e)));\n      }, function (e) {\n        u = !1, n.error && n.error(e), a.unsubscribe();\n      });\n    };\n\n    return d(), a;\n  });\n}\n\nvar Yn;\n\ntry {\n  Yn = {\n    indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB,\n    IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange\n  };\n} catch (e) {\n  Yn = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\n\nvar zn = $n;\n\nfunction Gn(e) {\n  var t = Hn;\n\n  try {\n    Hn = !0, Ht.storagemutated.fire(e);\n  } finally {\n    Hn = t;\n  }\n}\n\na(zn, _objectSpread(_objectSpread({}, Z), {}, {\n  delete: function _delete(e) {\n    return new zn(e, {\n      addons: []\n    }).delete();\n  },\n  exists: function exists(e) {\n    return new zn(e, {\n      addons: []\n    }).open().then(function (e) {\n      return e.close(), !0;\n    }).catch(\"NoSuchDatabaseError\", function () {\n      return !1;\n    });\n  },\n  getDatabaseNames: function getDatabaseNames(e) {\n    try {\n      return function (_ref41) {\n        var e = _ref41.indexedDB,\n            t = _ref41.IDBKeyRange;\n        return bn(e) ? Promise.resolve(e.databases()).then(function (e) {\n          return e.map(function (e) {\n            return e.name;\n          }).filter(function (e) {\n            return \"__dbnames\" !== e;\n          });\n        }) : gn(e, t).toCollection().primaryKeys();\n      }(zn.dependencies).then(e);\n    } catch (e) {\n      return ht(new X.MissingAPI());\n    }\n  },\n  defineClass: function defineClass() {\n    return function (e) {\n      r(this, e);\n    };\n  },\n  ignoreTransaction: function ignoreTransaction(e) {\n    return Ke.trans ? ot(Ke.transless, e) : e();\n  },\n  vip: _n,\n  async: function async(e) {\n    return function () {\n      try {\n        var t = kn(e.apply(this, arguments));\n        return t && \"function\" == typeof t.then ? t : Ce.resolve(t);\n      } catch (e) {\n        return ht(e);\n      }\n    };\n  },\n  spawn: function spawn(e, t, n) {\n    try {\n      var r = kn(e.apply(n, t || []));\n      return r && \"function\" == typeof r.then ? r : Ce.resolve(r);\n    } catch (e) {\n      return ht(e);\n    }\n  },\n  currentTransaction: {\n    get: function get() {\n      return Ke.trans || null;\n    }\n  },\n  waitFor: function waitFor(e, t) {\n    var n = Ce.resolve(\"function\" == typeof e ? zn.ignoreTransaction(e) : e).timeout(t || 6e4);\n    return Ke.trans ? Ke.trans.waitFor(n) : n;\n  },\n  Promise: Ce,\n  debug: {\n    get: function get() {\n      return R;\n    },\n    set: function set(e) {\n      F(e, \"dexie\" === e ? function () {\n        return !0;\n      } : bt);\n    }\n  },\n  derive: c,\n  extend: r,\n  props: a,\n  override: y,\n  Events: Et,\n  on: Ht,\n  liveQuery: Wn,\n  extendObservabilitySet: Vn,\n  getByKeyPath: b,\n  setByKeyPath: _,\n  delByKeyPath: function delByKeyPath(e, t) {\n    \"string\" == typeof t ? _(e, t, void 0) : \"length\" in t && [].map.call(t, function (t) {\n      _(e, t, void 0);\n    });\n  },\n  shallowClone: w,\n  deepClone: O,\n  getObjectDiff: Sn,\n  cmp: It,\n  asap: v,\n  minKey: -(1 / 0),\n  addons: [],\n  connections: yt,\n  errnames: H,\n  dependencies: Yn,\n  semVer: \"3.2.1\",\n  version: \"3.2.1\".split(\".\").map(function (e) {\n    return parseInt(e);\n  }).reduce(function (e, t, n) {\n    return e + t / Math.pow(10, 2 * n);\n  })\n})), zn.maxKey = _en(zn.dependencies.IDBKeyRange), \"undefined\" != typeof dispatchEvent && \"undefined\" != typeof addEventListener && (Ht(\"storagemutated\", function (e) {\n  if (!Hn) {\n    var _t16;\n\n    mt ? (_t16 = document.createEvent(\"CustomEvent\"), _t16.initCustomEvent(\"x-storagemutated-1\", !0, !0, e)) : _t16 = new CustomEvent(\"x-storagemutated-1\", {\n      detail: e\n    }), Hn = !0, dispatchEvent(_t16), Hn = !1;\n  }\n}), addEventListener(\"x-storagemutated-1\", function (_ref42) {\n  var e = _ref42.detail;\n  Hn || Gn(e);\n}));\nvar Hn = !1;\n\nif (\"undefined\" != typeof BroadcastChannel) {\n  var _e20 = new BroadcastChannel(\"x-storagemutated-1\");\n\n  Ht(\"storagemutated\", function (t) {\n    Hn || _e20.postMessage(t);\n  }), _e20.onmessage = function (e) {\n    e.data && Gn(e.data);\n  };\n} else if (\"undefined\" != typeof self && \"undefined\" != typeof navigator) {\n  Ht(\"storagemutated\", function (e) {\n    try {\n      Hn || (\"undefined\" != typeof localStorage && localStorage.setItem(\"x-storagemutated-1\", JSON.stringify({\n        trig: Math.random(),\n        changedParts: e\n      })), \"object\" == typeof self.clients && _toConsumableArray(self.clients.matchAll({\n        includeUncontrolled: !0\n      })).forEach(function (t) {\n        return t.postMessage({\n          type: \"x-storagemutated-1\",\n          changedParts: e\n        });\n      }));\n    } catch (e) {}\n  }), addEventListener(\"storage\", function (e) {\n    if (\"x-storagemutated-1\" === e.key) {\n      var _t17 = JSON.parse(e.newValue);\n\n      _t17 && Gn(_t17.changedParts);\n    }\n  });\n\n  var _e21 = self.document && navigator.serviceWorker;\n\n  _e21 && _e21.addEventListener(\"message\", function (_ref43) {\n    var e = _ref43.data;\n    e && \"x-storagemutated-1\" === e.type && Gn(e.changedParts);\n  });\n}\n\nCe.rejectionMapper = function (e, t) {\n  if (!e || e instanceof W || e instanceof TypeError || e instanceof SyntaxError || !e.name || !J[e.name]) return e;\n  var n = new J[e.name](t || e.message, e);\n  return \"stack\" in e && l(n, \"stack\", {\n    get: function get() {\n      return this.inner.stack;\n    }\n  }), n;\n}, F(R, bt);\nexport { $n as Dexie, In as RangeSet, $n as default, Wn as liveQuery, Tn as mergeRanges, Rn as rangesOverlap };","map":null,"metadata":{},"sourceType":"module"}