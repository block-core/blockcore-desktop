{"ast":null,"code":"const Buffer = require('safe-buffer').Buffer;\n\nconst bcrypto = require('./crypto');\n\nconst bscript = require('./script');\n\nconst bufferutils = require('./bufferutils');\n\nconst opcodes = require('bitcoin-ops');\n\nconst typeforce = require('typeforce');\n\nconst types = require('./types');\n\nconst varuint = require('varuint-bitcoin');\n\nconst networks = require('./networks');\n\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness);\n  }, 0);\n}\n\nfunction Transaction(network) {\n  this.network = network || networks.bitcoin;\n  this.version = 1;\n  if (this.network.isProofOfStake) this.time = Math.floor(new Date().getTime() / 1000);\n  this.locktime = 0;\n  this.ins = [];\n  this.outs = [];\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nconst ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\n\nTransaction.fromBuffer = function (buffer, __noStrict, network) {\n  network = network || networks.bitcoin;\n  let offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt32() {\n    const i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    const i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readUInt64() {\n    const i = bufferutils.readUInt64LE(buffer, offset);\n    offset += 8;\n    return i;\n  }\n\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n\n    for (var i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  const tx = new Transaction(network);\n  tx.version = readInt32();\n\n  if (network.isProofOfStake) {\n    tx.time = readUInt32();\n  }\n\n  const marker = buffer.readUInt8(offset);\n  const flag = buffer.readUInt8(offset + 1);\n  let hasWitnesses = false;\n\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n    offset += 2;\n    hasWitnesses = true;\n  }\n\n  const vinLen = readVarInt();\n\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    });\n  }\n\n  const voutLen = readVarInt();\n\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    });\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector();\n    } // was this pointless?\n\n\n    if (!tx.hasWitnesses()) {\n      throw new Error('Transaction has superfluous witness data');\n    }\n  }\n\n  tx.locktime = readUInt32();\n  if (__noStrict) return tx;\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data');\n  return tx;\n};\n\nTransaction.fromHex = function (hex, network) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'), null, network);\n};\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer);\n\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false;\n  }\n\n  return true;\n};\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n};\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE;\n  } // Add the input and return the input's index\n\n\n  return this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1;\n};\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n  return this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1;\n};\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0;\n  });\n};\n\nTransaction.prototype.weight = function () {\n  const base = this.__byteLength(false);\n\n  const total = this.__byteLength(true);\n\n  return base * 3 + total;\n};\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4);\n};\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true);\n};\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  const hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  return (hasWitnesses ? 10 : 8) + (this.network.isProofOfStake ? 4 : 0) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0) + this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {\n    return sum + vectorSize(input.witness);\n  }, 0) : 0);\n};\n\nTransaction.prototype.clone = function () {\n  const newTx = new Transaction(this.network);\n  newTx.version = this.version;\n  if (this.network.isProofOfStake) newTx.time = this.time;\n  newTx.locktime = this.locktime;\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    };\n  });\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    };\n  });\n  return newTx;\n};\n/**\r\n * Hash transaction for signing a specific input.\r\n *\r\n * Bitcoin uses a different hash for each signed transaction input.\r\n * This method copies the transaction, makes the necessary changes based on the\r\n * hashType, and then hashes the result.\r\n * This hash can then be used to sign the provided transaction input.\r\n */\n\n\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n  if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n  const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR;\n  }));\n  const txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return;\n      input.sequence = 0;\n    }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n    txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT;\n    } // ignore sequence numbers (except at inIndex)\n\n\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return;\n      input.sequence = 0;\n    });\n  } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]];\n    txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) {\n      input.script = EMPTY_SCRIPT;\n    });\n    txTmp.ins[inIndex].script = ourScript;\n  } // serialize and hash\n\n\n  const buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4);\n  buffer.writeInt32LE(hashType, buffer.length - 4);\n\n  txTmp.__toBuffer(buffer, 0, false);\n\n  return bcrypto.hash256(buffer);\n};\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n  let tbuffer, toffset;\n\n  function writeSlice(slice) {\n    toffset += slice.copy(tbuffer, toffset);\n  }\n\n  function writeUInt32(i) {\n    toffset = tbuffer.writeUInt32LE(i, toffset);\n  }\n\n  function writeUInt64(i) {\n    toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, tbuffer, toffset);\n    toffset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  let hashOutputs = ZERO;\n  let hashPrevouts = ZERO;\n  let hashSequence = ZERO;\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n    toffset = 0;\n    this.ins.forEach(function (txIn) {\n      writeSlice(txIn.hash);\n      writeUInt32(txIn.index);\n    });\n    hashPrevouts = bcrypto.hash256(tbuffer);\n  }\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n    toffset = 0;\n    this.ins.forEach(function (txIn) {\n      writeUInt32(txIn.sequence);\n    });\n    hashSequence = bcrypto.hash256(tbuffer);\n  }\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    const txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0);\n    tbuffer = Buffer.allocUnsafe(txOutsSize);\n    toffset = 0;\n    this.outs.forEach(function (out) {\n      writeUInt64(out.value);\n      writeVarSlice(out.script);\n    });\n    hashOutputs = bcrypto.hash256(tbuffer);\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    const output = this.outs[inIndex];\n    tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n    toffset = 0;\n    writeUInt64(output.value);\n    writeVarSlice(output.script);\n    hashOutputs = bcrypto.hash256(tbuffer);\n  }\n\n  tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n  toffset = 0;\n  const input = this.ins[inIndex];\n  writeUInt32(this.version);\n  if (this.network.isProofOfStake) writeUInt32(this.time);\n  writeSlice(hashPrevouts);\n  writeSlice(hashSequence);\n  writeSlice(input.hash);\n  writeUInt32(input.index);\n  writeVarSlice(prevOutScript);\n  writeUInt64(value);\n  writeUInt32(input.sequence);\n  writeSlice(hashOutputs);\n  writeUInt32(this.locktime);\n  writeUInt32(hashType);\n  return bcrypto.hash256(tbuffer);\n};\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false));\n};\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex');\n};\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true);\n};\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness));\n  let offset = initialOffset || 0;\n\n  function writeSlice(slice) {\n    offset += slice.copy(buffer, offset);\n  }\n\n  function writeUInt8(i) {\n    offset = buffer.writeUInt8(i, offset);\n  }\n\n  function writeUInt32(i) {\n    offset = buffer.writeUInt32LE(i, offset);\n  }\n\n  function writeInt32(i) {\n    offset = buffer.writeInt32LE(i, offset);\n  }\n\n  function writeUInt64(i) {\n    offset = bufferutils.writeUInt64LE(buffer, i, offset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, buffer, offset);\n    offset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeInt32(this.version); // If the transaction has the time value, meaning it is an POS-transaction, we'll\n  // write that to the buffer.\n\n  if (this.time) {\n    writeInt32(this.time);\n  }\n\n  const hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n  }\n\n  writeVarInt(this.ins.length);\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash);\n    writeUInt32(txIn.index);\n    writeVarSlice(txIn.script);\n    writeUInt32(txIn.sequence);\n  });\n  writeVarInt(this.outs.length);\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value);\n    } else {\n      writeSlice(txOut.valueBuffer);\n    }\n\n    writeVarSlice(txOut.script);\n  });\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness);\n    });\n  }\n\n  writeUInt32(this.locktime); // avoid slicing unless necessary\n\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset);\n  return buffer;\n};\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments);\n  this.ins[index].script = scriptSig;\n};\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n  this.ins[index].witness = witness;\n};\n\nmodule.exports = Transaction;","map":null,"metadata":{},"sourceType":"script"}