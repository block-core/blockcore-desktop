{"ast":null,"code":"import _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/** Handles HttpClient errors */\n\nexport var HttpErrorHandler = /*#__PURE__*/(function () {\n  var HttpErrorHandler = /*#__PURE__*/function () {\n    function HttpErrorHandler() {\n      var _this = this;\n\n      _classCallCheck(this, HttpErrorHandler);\n\n      /** Create curried handleError function that already knows the service name */\n      this.createHandleError = function () {\n        var serviceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        return function () {\n          var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'operation';\n          var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          return _this.handleError(serviceName, operation, result);\n        };\n      };\n    }\n    /**\r\n     * Returns a function that handles Http operation failures.\r\n     * This error handler lets the app continue to run as if no error occurred.\r\n     *\r\n     * @param serviceName = name of the data service that attempted the operation\r\n     * @param operation - name of the operation that failed\r\n     * @param result - optional value to return as the observable result\r\n     */\n\n\n    _createClass(HttpErrorHandler, [{\n      key: \"handleError\",\n      value: function handleError() {\n        var serviceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var operation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'operation';\n        var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function (error) {\n          // TODO: send the error to remote logging infrastructure\n          console.error(error); // log to console instead\n\n          var message = error.error instanceof ErrorEvent ? error.error.message : \"server returned code \".concat(error.status, \" with body \\\"\").concat(error.error, \"\\\"\"); // TODO: better job of transforming error for user consumption\n          // this.messageService.add(`${serviceName}: ${operation} failed: ${message}`);\n          // Let the app keep running by returning a safe result.\n\n          return of(result);\n        };\n      }\n    }]);\n\n    return HttpErrorHandler;\n  }();\n\n  /** @nocollapse */\n  HttpErrorHandler.ɵfac = function HttpErrorHandler_Factory(t) {\n    return new (t || HttpErrorHandler)();\n  };\n  /** @nocollapse */\n\n\n  HttpErrorHandler.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: HttpErrorHandler,\n    factory: HttpErrorHandler.ɵfac\n  });\n  return HttpErrorHandler;\n})();","map":null,"metadata":{},"sourceType":"module"}