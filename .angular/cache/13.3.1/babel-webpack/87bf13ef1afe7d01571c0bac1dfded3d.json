{"ast":null,"code":"import _defineProperty from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _toConsumableArray from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _objectSpread from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\objectSpread2.js\";\nimport _createForOfIteratorHelper from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _slicedToArray from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\n\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.1, Wed Feb 16 2022\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\nvar _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;\n\nvar keys = Object.keys;\nvar isArray = Array.isArray;\n\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n  _global.Promise = Promise;\n}\n\nfunction extend(obj, extension) {\n  if (typeof extension !== 'object') return obj;\n  keys(extension).forEach(function (key) {\n    obj[key] = extension[key];\n  });\n  return obj;\n}\n\nvar getProto = Object.getPrototypeOf;\nvar _hasOwn = {}.hasOwnProperty;\n\nfunction hasOwn(obj, prop) {\n  return _hasOwn.call(obj, prop);\n}\n\nfunction props(proto, extension) {\n  if (typeof extension === 'function') extension = extension(getProto(proto));\n  (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n    setProp(proto, key, extension[key]);\n  });\n}\n\nvar defineProperty = Object.defineProperty;\n\nfunction setProp(obj, prop, functionOrGetSet, options) {\n  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ? {\n    get: functionOrGetSet.get,\n    set: functionOrGetSet.set,\n    configurable: true\n  } : {\n    value: functionOrGetSet,\n    configurable: true,\n    writable: true\n  }, options));\n}\n\nfunction derive(Child) {\n  return {\n    from: function from(Parent) {\n      Child.prototype = Object.create(Parent.prototype);\n      setProp(Child.prototype, \"constructor\", Child);\n      return {\n        extend: props.bind(null, Child.prototype)\n      };\n    }\n  };\n}\n\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nfunction getPropertyDescriptor(obj, prop) {\n  var pd = getOwnPropertyDescriptor(obj, prop);\n  var proto;\n  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\n\nvar _slice = [].slice;\n\nfunction slice(args, start, end) {\n  return _slice.call(args, start, end);\n}\n\nfunction override(origFunc, overridedFactory) {\n  return overridedFactory(origFunc);\n}\n\nfunction assert(b) {\n  if (!b) throw new Error(\"Assertion Failed\");\n}\n\nfunction asap$1(fn) {\n  if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);\n}\n\nfunction arrayToObject(array, extractor) {\n  return array.reduce(function (result, item, i) {\n    var nameAndValue = extractor(item, i);\n    if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n    return result;\n  }, {});\n}\n\nfunction tryCatch(fn, onerror, args) {\n  try {\n    fn.apply(null, args);\n  } catch (ex) {\n    onerror && onerror(ex);\n  }\n}\n\nfunction getByKeyPath(obj, keyPath) {\n  if (hasOwn(obj, keyPath)) return obj[keyPath];\n  if (!keyPath) return obj;\n\n  if (typeof keyPath !== 'string') {\n    var rv = [];\n\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      var val = getByKeyPath(obj, keyPath[i]);\n      rv.push(val);\n    }\n\n    return rv;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period !== -1) {\n    var innerObj = obj[keyPath.substr(0, period)];\n    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n  }\n\n  return undefined;\n}\n\nfunction setByKeyPath(obj, keyPath, value) {\n  if (!obj || keyPath === undefined) return;\n  if ('isFrozen' in Object && Object.isFrozen(obj)) return;\n\n  if (typeof keyPath !== 'string' && 'length' in keyPath) {\n    assert(typeof value !== 'string' && 'length' in value);\n\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      setByKeyPath(obj, keyPath[i], value[i]);\n    }\n  } else {\n    var period = keyPath.indexOf('.');\n\n    if (period !== -1) {\n      var currentKeyPath = keyPath.substr(0, period);\n      var remainingKeyPath = keyPath.substr(period + 1);\n      if (remainingKeyPath === \"\") {\n        if (value === undefined) {\n          if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];\n        } else obj[currentKeyPath] = value;\n      } else {\n        var innerObj = obj[currentKeyPath];\n        if (!innerObj) innerObj = obj[currentKeyPath] = {};\n        setByKeyPath(innerObj, remainingKeyPath, value);\n      }\n    } else {\n      if (value === undefined) {\n        if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];\n      } else obj[keyPath] = value;\n    }\n  }\n}\n\nfunction delByKeyPath(obj, keyPath) {\n  if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {\n    setByKeyPath(obj, kp, undefined);\n  });\n}\n\nfunction shallowClone(obj) {\n  var rv = {};\n\n  for (var m in obj) {\n    if (hasOwn(obj, m)) rv[m] = obj[m];\n  }\n\n  return rv;\n}\n\nvar concat = [].concat;\n\nfunction flatten(a) {\n  return concat.apply([], a);\n}\n\nvar intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(',').concat(flatten([8, 16, 32, 64].map(function (num) {\n  return [\"Int\", \"Uint\", \"Float\"].map(function (t) {\n    return t + num + \"Array\";\n  });\n}))).filter(function (t) {\n  return _global[t];\n});\nvar intrinsicTypes = intrinsicTypeNames.map(function (t) {\n  return _global[t];\n});\narrayToObject(intrinsicTypeNames, function (x) {\n  return [x, true];\n});\nvar circularRefs = null;\n\nfunction deepClone(any) {\n  circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n  var rv = innerDeepClone(any);\n  circularRefs = null;\n  return rv;\n}\n\nfunction innerDeepClone(any) {\n  if (!any || typeof any !== 'object') return any;\n  var rv = circularRefs && circularRefs.get(any);\n  if (rv) return rv;\n\n  if (isArray(any)) {\n    rv = [];\n    circularRefs && circularRefs.set(any, rv);\n\n    for (var i = 0, l = any.length; i < l; ++i) {\n      rv.push(innerDeepClone(any[i]));\n    }\n  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n    rv = any;\n  } else {\n    var proto = getProto(any);\n    rv = proto === Object.prototype ? {} : Object.create(proto);\n    circularRefs && circularRefs.set(any, rv);\n\n    for (var prop in any) {\n      if (hasOwn(any, prop)) {\n        rv[prop] = innerDeepClone(any[prop]);\n      }\n    }\n  }\n\n  return rv;\n}\n\nvar _ref = {},\n    toString = _ref.toString;\n\nfunction toStringTag(o) {\n  return toString.call(o).slice(8, -1);\n}\n\nvar iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\nvar getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n  var i;\n  return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () {\n  return null;\n};\nvar NO_CHAR_ARRAY = {};\n\nfunction getArrayOf(arrayLike) {\n  var i, a, x, it;\n\n  if (arguments.length === 1) {\n    if (isArray(arrayLike)) return arrayLike.slice();\n    if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\n\n    if (it = getIteratorOf(arrayLike)) {\n      a = [];\n\n      while (x = it.next(), !x.done) {\n        a.push(x.value);\n      }\n\n      return a;\n    }\n\n    if (arrayLike == null) return [arrayLike];\n    i = arrayLike.length;\n\n    if (typeof i === 'number') {\n      a = new Array(i);\n\n      while (i--) {\n        a[i] = arrayLike[i];\n      }\n\n      return a;\n    }\n\n    return [arrayLike];\n  }\n\n  i = arguments.length;\n  a = new Array(i);\n\n  while (i--) {\n    a[i] = arguments[i];\n  }\n\n  return a;\n}\n\nvar isAsyncFunction = typeof Symbol !== 'undefined' ? function (fn) {\n  return fn[Symbol.toStringTag] === 'AsyncFunction';\n} : function () {\n  return false;\n};\nvar debug = typeof location !== 'undefined' && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nfunction setDebug(value, filter) {\n  debug = value;\n  libraryFilter = filter;\n}\n\nvar libraryFilter = function libraryFilter() {\n  return true;\n};\n\nvar NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\n\nfunction getErrorWithStack() {\n  if (NEEDS_THROW_FOR_STACK) try {\n    getErrorWithStack.arguments;\n    throw new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\n\nfunction prettyStack(exception, numIgnoredFrames) {\n  var stack = exception.stack;\n  if (!stack) return \"\";\n  numIgnoredFrames = numIgnoredFrames || 0;\n  if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n  return stack.split('\\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {\n    return \"\\n\" + frame;\n  }).join('');\n}\n\nvar dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];\nvar idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n  VersionChanged: \"Database version changed by other database connection\",\n  DatabaseClosed: \"Database has been closed\",\n  Abort: \"Transaction aborted\",\n  TransactionInactive: \"Transaction has already completed or failed\",\n  MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\n\nfunction DexieError(name, msg) {\n  this._e = getErrorWithStack();\n  this.name = name;\n  this.message = msg;\n}\n\nderive(DexieError).from(Error).extend({\n  stack: {\n    get: function get() {\n      return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n    }\n  },\n  toString: function toString() {\n    return this.name + \": \" + this.message;\n  }\n});\n\nfunction getMultiErrorMessage(msg, failures) {\n  return msg + \". Errors: \" + Object.keys(failures).map(function (key) {\n    return failures[key].toString();\n  }).filter(function (v, i, s) {\n    return s.indexOf(v) === i;\n  }).join('\\n');\n}\n\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n  this._e = getErrorWithStack();\n  this.failures = failures;\n  this.failedKeys = failedKeys;\n  this.successCount = successCount;\n  this.message = getMultiErrorMessage(msg, failures);\n}\n\nderive(ModifyError).from(DexieError);\n\nfunction BulkError(msg, failures) {\n  this._e = getErrorWithStack();\n  this.name = \"BulkError\";\n  this.failures = Object.keys(failures).map(function (pos) {\n    return failures[pos];\n  });\n  this.failuresByPos = failures;\n  this.message = getMultiErrorMessage(msg, failures);\n}\n\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce(function (obj, name) {\n  return obj[name] = name + \"Error\", obj;\n}, {});\nvar BaseException = DexieError;\nvar exceptions = errorList.reduce(function (obj, name) {\n  var fullName = name + \"Error\";\n\n  function DexieError(msgOrInner, inner) {\n    this._e = getErrorWithStack();\n    this.name = fullName;\n\n    if (!msgOrInner) {\n      this.message = defaultTexts[name] || fullName;\n      this.inner = null;\n    } else if (typeof msgOrInner === 'string') {\n      this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n      this.inner = inner || null;\n    } else if (typeof msgOrInner === 'object') {\n      this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n      this.inner = msgOrInner;\n    }\n  }\n\n  derive(DexieError).from(BaseException);\n  obj[name] = DexieError;\n  return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n  obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\n\nfunction mapError(domError, message) {\n  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n  var rv = new exceptionMap[domError.name](message || domError.message, domError);\n\n  if (\"stack\" in domError) {\n    setProp(rv, \"stack\", {\n      get: function get() {\n        return this.inner.stack;\n      }\n    });\n  }\n\n  return rv;\n}\n\nvar fullNameExceptions = errorList.reduce(function (obj, name) {\n  if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() {}\n\nfunction mirror(val) {\n  return val;\n}\n\nfunction pureFunctionChain(f1, f2) {\n  if (f1 == null || f1 === mirror) return f2;\n  return function (val) {\n    return f2(f1(val));\n  };\n}\n\nfunction callBoth(on1, on2) {\n  return function () {\n    on1.apply(this, arguments);\n    on2.apply(this, arguments);\n  };\n}\n\nfunction hookCreatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n    if (res !== undefined) arguments[0] = res;\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res2 !== undefined ? res2 : res;\n  };\n}\n\nfunction hookDeletingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    f1.apply(this, arguments);\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = this.onerror = null;\n    f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n  };\n}\n\nfunction hookUpdatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function (modifications) {\n    var res = f1.apply(this, arguments);\n    extend(modifications, res);\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n  };\n}\n\nfunction reverseStoppableEventChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    if (f2.apply(this, arguments) === false) return false;\n    return f1.apply(this, arguments);\n  };\n}\n\nfunction promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n\n    if (res && typeof res.then === 'function') {\n      var thiz = this,\n          i = arguments.length,\n          args = new Array(i);\n\n      while (i--) {\n        args[i] = arguments[i];\n      }\n\n      return res.then(function () {\n        return f2.apply(thiz, args);\n      });\n    }\n\n    return f2.apply(this, arguments);\n  };\n}\n\nvar INTERNAL = {};\n\nvar LONG_STACKS_CLIP_LIMIT = 100,\n    MAX_LONG_STACKS = 20,\n    ZONE_ECHO_LIMIT = 100,\n    _ref2 = typeof Promise === 'undefined' ? [] : function () {\n  var globalP = Promise.resolve();\n  if (typeof crypto === 'undefined' || !crypto.subtle) return [globalP, getProto(globalP), globalP];\n  var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n  return [nativeP, getProto(nativeP), globalP];\n}(),\n    _ref3 = _slicedToArray(_ref2, 3),\n    resolvedNativePromise = _ref3[0],\n    nativePromiseProto = _ref3[1],\n    resolvedGlobalPromise = _ref3[2],\n    nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n\nvar NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nvar patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? function () {\n  resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? function () {\n  var hiddenDiv = document.createElement(\"div\");\n  new MutationObserver(function () {\n    physicalTick();\n    hiddenDiv = null;\n  }).observe(hiddenDiv, {\n    attributes: true\n  });\n  hiddenDiv.setAttribute('i', '1');\n} : function () {\n  setTimeout(physicalTick, 0);\n};\n\nvar asap = function asap(callback, args) {\n  microtickQueue.push([callback, args]);\n\n  if (needsNewPhysicalTick) {\n    schedulePhysicalTick();\n    needsNewPhysicalTick = false;\n  }\n};\n\nvar isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    currentFulfiller = null,\n    rejectionMapper = mirror;\nvar globalPSD = {\n  id: 'global',\n  global: true,\n  ref: 0,\n  unhandleds: [],\n  onunhandled: globalError,\n  pgp: false,\n  env: {},\n  finalize: function finalize() {\n    this.unhandleds.forEach(function (uh) {\n      try {\n        globalError(uh[0], uh[1]);\n      } catch (e) {}\n    });\n  }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\n\nfunction DexiePromise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n  this._listeners = [];\n  this.onuncatched = nop;\n  this._lib = false;\n  var psd = this._PSD = PSD;\n\n  if (debug) {\n    this._stackHolder = getErrorWithStack();\n    this._prev = null;\n    this._numPrev = 0;\n  }\n\n  if (typeof fn !== 'function') {\n    if (fn !== INTERNAL) throw new TypeError('Not a function');\n    this._state = arguments[1];\n    this._value = arguments[2];\n    if (this._state === false) handleRejection(this, this._value);\n    return;\n  }\n\n  this._state = null;\n  this._value = null;\n  ++psd.ref;\n  executePromiseTask(this, fn);\n}\n\nvar thenProp = {\n  get: function get() {\n    var psd = PSD,\n        microTaskId = totalEchoes;\n\n    function then(onFulfilled, onRejected) {\n      var _this = this;\n\n      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n      var cleanup = possibleAwait && !decrementExpectedAwaits();\n      var rv = new DexiePromise(function (resolve, reject) {\n        propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n      });\n      debug && linkToPreviousPromise(rv, this);\n      return rv;\n    }\n\n    then.prototype = INTERNAL;\n    return then;\n  },\n  set: function set(value) {\n    setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {\n      get: function get() {\n        return value;\n      },\n      set: thenProp.set\n    });\n  }\n};\nprops(DexiePromise.prototype, {\n  then: thenProp,\n  _then: function _then(onFulfilled, onRejected) {\n    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n  },\n  catch: function _catch(onRejected) {\n    if (arguments.length === 1) return this.then(null, onRejected);\n    var type = arguments[0],\n        handler = arguments[1];\n    return typeof type === 'function' ? this.then(null, function (err) {\n      return err instanceof type ? handler(err) : PromiseReject(err);\n    }) : this.then(null, function (err) {\n      return err && err.name === type ? handler(err) : PromiseReject(err);\n    });\n  },\n  finally: function _finally(onFinally) {\n    return this.then(function (value) {\n      onFinally();\n      return value;\n    }, function (err) {\n      onFinally();\n      return PromiseReject(err);\n    });\n  },\n  stack: {\n    get: function get() {\n      if (this._stack) return this._stack;\n\n      try {\n        stack_being_generated = true;\n        var stacks = getStack(this, [], MAX_LONG_STACKS);\n        var stack = stacks.join(\"\\nFrom previous: \");\n        if (this._state !== null) this._stack = stack;\n        return stack;\n      } finally {\n        stack_being_generated = false;\n      }\n    }\n  },\n  timeout: function timeout(ms, msg) {\n    var _this2 = this;\n\n    return ms < Infinity ? new DexiePromise(function (resolve, reject) {\n      var handle = setTimeout(function () {\n        return reject(new exceptions.Timeout(msg));\n      }, ms);\n\n      _this2.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n    }) : this;\n  }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\n\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.resolve = resolve;\n  this.reject = reject;\n  this.psd = zone;\n}\n\nprops(DexiePromise, {\n  all: function all() {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve, reject) {\n      if (values.length === 0) resolve([]);\n      var remaining = values.length;\n      values.forEach(function (a, i) {\n        return DexiePromise.resolve(a).then(function (x) {\n          values[i] = x;\n          if (! --remaining) resolve(values);\n        }, reject);\n      });\n    });\n  },\n  resolve: function resolve(value) {\n    if (value instanceof DexiePromise) return value;\n    if (value && typeof value.then === 'function') return new DexiePromise(function (resolve, reject) {\n      value.then(resolve, reject);\n    });\n    var rv = new DexiePromise(INTERNAL, true, value);\n    linkToPreviousPromise(rv, currentFulfiller);\n    return rv;\n  },\n  reject: PromiseReject,\n  race: function race() {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve, reject) {\n      values.map(function (value) {\n        return DexiePromise.resolve(value).then(resolve, reject);\n      });\n    });\n  },\n  PSD: {\n    get: function get() {\n      return PSD;\n    },\n    set: function set(value) {\n      return PSD = value;\n    }\n  },\n  totalEchoes: {\n    get: function get() {\n      return totalEchoes;\n    }\n  },\n  newPSD: newScope,\n  usePSD: usePSD,\n  scheduler: {\n    get: function get() {\n      return asap;\n    },\n    set: function set(value) {\n      asap = value;\n    }\n  },\n  rejectionMapper: {\n    get: function get() {\n      return rejectionMapper;\n    },\n    set: function set(value) {\n      rejectionMapper = value;\n    }\n  },\n  follow: function follow(fn, zoneProps) {\n    return new DexiePromise(function (resolve, reject) {\n      return newScope(function (resolve, reject) {\n        var psd = PSD;\n        psd.unhandleds = [];\n        psd.onunhandled = reject;\n        psd.finalize = callBoth(function () {\n          var _this3 = this;\n\n          run_at_end_of_this_or_next_physical_tick(function () {\n            _this3.unhandleds.length === 0 ? resolve() : reject(_this3.unhandleds[0]);\n          });\n        }, psd.finalize);\n        fn();\n      }, zoneProps, resolve, reject);\n    });\n  }\n});\n\nif (NativePromise) {\n  if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function () {\n    var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve) {\n      if (possiblePromises.length === 0) resolve([]);\n      var remaining = possiblePromises.length;\n      var results = new Array(remaining);\n      possiblePromises.forEach(function (p, i) {\n        return DexiePromise.resolve(p).then(function (value) {\n          return results[i] = {\n            status: \"fulfilled\",\n            value: value\n          };\n        }, function (reason) {\n          return results[i] = {\n            status: \"rejected\",\n            reason: reason\n          };\n        }).then(function () {\n          return --remaining || resolve(results);\n        });\n      });\n    });\n  });\n  if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, \"any\", function () {\n    var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve, reject) {\n      if (possiblePromises.length === 0) reject(new AggregateError([]));\n      var remaining = possiblePromises.length;\n      var failures = new Array(remaining);\n      possiblePromises.forEach(function (p, i) {\n        return DexiePromise.resolve(p).then(function (value) {\n          return resolve(value);\n        }, function (failure) {\n          failures[i] = failure;\n          if (! --remaining) reject(new AggregateError(failures));\n        });\n      });\n    });\n  });\n}\n\nfunction executePromiseTask(promise, fn) {\n  try {\n    fn(function (value) {\n      if (promise._state !== null) return;\n      if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');\n      var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\n      if (value && typeof value.then === 'function') {\n        executePromiseTask(promise, function (resolve, reject) {\n          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n        });\n      } else {\n        promise._state = true;\n        promise._value = value;\n        propagateAllListeners(promise);\n      }\n\n      if (shouldExecuteTick) endMicroTickScope();\n    }, handleRejection.bind(null, promise));\n  } catch (ex) {\n    handleRejection(promise, ex);\n  }\n}\n\nfunction handleRejection(promise, reason) {\n  rejectingErrors.push(reason);\n  if (promise._state !== null) return;\n  var shouldExecuteTick = promise._lib && beginMicroTickScope();\n  reason = rejectionMapper(reason);\n  promise._state = false;\n  promise._value = reason;\n  debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {\n    var origProp = getPropertyDescriptor(reason, \"stack\");\n    reason._promise = promise;\n    setProp(reason, \"stack\", {\n      get: function get() {\n        return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;\n      }\n    });\n  });\n  addPossiblyUnhandledError(promise);\n  propagateAllListeners(promise);\n  if (shouldExecuteTick) endMicroTickScope();\n}\n\nfunction propagateAllListeners(promise) {\n  var listeners = promise._listeners;\n  promise._listeners = [];\n\n  for (var i = 0, len = listeners.length; i < len; ++i) {\n    propagateToListener(promise, listeners[i]);\n  }\n\n  var psd = promise._PSD;\n  --psd.ref || psd.finalize();\n\n  if (numScheduledCalls === 0) {\n    ++numScheduledCalls;\n    asap(function () {\n      if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n  }\n}\n\nfunction propagateToListener(promise, listener) {\n  if (promise._state === null) {\n    promise._listeners.push(listener);\n\n    return;\n  }\n\n  var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n\n  if (cb === null) {\n    return (promise._state ? listener.resolve : listener.reject)(promise._value);\n  }\n\n  ++listener.psd.ref;\n  ++numScheduledCalls;\n  asap(callListener, [cb, promise, listener]);\n}\n\nfunction callListener(cb, promise, listener) {\n  try {\n    currentFulfiller = promise;\n    var ret,\n        value = promise._value;\n\n    if (promise._state) {\n      ret = cb(value);\n    } else {\n      if (rejectingErrors.length) rejectingErrors = [];\n      ret = cb(value);\n      if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n    }\n\n    listener.resolve(ret);\n  } catch (e) {\n    listener.reject(e);\n  } finally {\n    currentFulfiller = null;\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n    --listener.psd.ref || listener.psd.finalize();\n  }\n}\n\nfunction getStack(promise, stacks, limit) {\n  if (stacks.length === limit) return stacks;\n  var stack = \"\";\n\n  if (promise._state === false) {\n    var failure = promise._value,\n        errorName,\n        message;\n\n    if (failure != null) {\n      errorName = failure.name || \"Error\";\n      message = failure.message || failure;\n      stack = prettyStack(failure, 0);\n    } else {\n      errorName = failure;\n      message = \"\";\n    }\n\n    stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n  }\n\n  if (debug) {\n    stack = prettyStack(promise._stackHolder, 2);\n    if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n    if (promise._prev) getStack(promise._prev, stacks, limit);\n  }\n\n  return stacks;\n}\n\nfunction linkToPreviousPromise(promise, prev) {\n  var numPrev = prev ? prev._numPrev + 1 : 0;\n\n  if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n    promise._prev = prev;\n    promise._numPrev = numPrev;\n  }\n}\n\nfunction physicalTick() {\n  beginMicroTickScope() && endMicroTickScope();\n}\n\nfunction beginMicroTickScope() {\n  var wasRootExec = isOutsideMicroTick;\n  isOutsideMicroTick = false;\n  needsNewPhysicalTick = false;\n  return wasRootExec;\n}\n\nfunction endMicroTickScope() {\n  var callbacks, i, l;\n\n  do {\n    while (microtickQueue.length > 0) {\n      callbacks = microtickQueue;\n      microtickQueue = [];\n      l = callbacks.length;\n\n      for (i = 0; i < l; ++i) {\n        var item = callbacks[i];\n        item[0].apply(null, item[1]);\n      }\n    }\n  } while (microtickQueue.length > 0);\n\n  isOutsideMicroTick = true;\n  needsNewPhysicalTick = true;\n}\n\nfunction finalizePhysicalTick() {\n  var unhandledErrs = unhandledErrors;\n  unhandledErrors = [];\n  unhandledErrs.forEach(function (p) {\n    p._PSD.onunhandled.call(null, p._value, p);\n  });\n  var finalizers = tickFinalizers.slice(0);\n  var i = finalizers.length;\n\n  while (i) {\n    finalizers[--i]();\n  }\n}\n\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n  function finalizer() {\n    fn();\n    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n  }\n\n  tickFinalizers.push(finalizer);\n  ++numScheduledCalls;\n  asap(function () {\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n  }, []);\n}\n\nfunction addPossiblyUnhandledError(promise) {\n  if (!unhandledErrors.some(function (p) {\n    return p._value === promise._value;\n  })) unhandledErrors.push(promise);\n}\n\nfunction markErrorAsHandled(promise) {\n  var i = unhandledErrors.length;\n\n  while (i) {\n    if (unhandledErrors[--i]._value === promise._value) {\n      unhandledErrors.splice(i, 1);\n      return;\n    }\n  }\n}\n\nfunction PromiseReject(reason) {\n  return new DexiePromise(INTERNAL, false, reason);\n}\n\nfunction wrap(fn, errorCatcher) {\n  var psd = PSD;\n  return function () {\n    var wasRootExec = beginMicroTickScope(),\n        outerScope = PSD;\n\n    try {\n      switchToZone(psd, true);\n      return fn.apply(this, arguments);\n    } catch (e) {\n      errorCatcher && errorCatcher(e);\n    } finally {\n      switchToZone(outerScope, false);\n      if (wasRootExec) endMicroTickScope();\n    }\n  };\n}\n\nvar task = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\n\nfunction newScope(fn, props, a1, a2) {\n  var parent = PSD,\n      psd = Object.create(parent);\n  psd.parent = parent;\n  psd.ref = 0;\n  psd.global = false;\n  psd.id = ++zone_id_counter;\n  var globalEnv = globalPSD.env;\n  psd.env = patchGlobalPromise ? {\n    Promise: DexiePromise,\n    PromiseProp: {\n      value: DexiePromise,\n      configurable: true,\n      writable: true\n    },\n    all: DexiePromise.all,\n    race: DexiePromise.race,\n    allSettled: DexiePromise.allSettled,\n    any: DexiePromise.any,\n    resolve: DexiePromise.resolve,\n    reject: DexiePromise.reject,\n    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n  } : {};\n  if (props) extend(psd, props);\n  ++parent.ref;\n\n  psd.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n\n  var rv = usePSD(psd, fn, a1, a2);\n  if (psd.ref === 0) psd.finalize();\n  return rv;\n}\n\nfunction incrementExpectedAwaits() {\n  if (!task.id) task.id = ++taskCounter;\n  ++task.awaits;\n  task.echoes += ZONE_ECHO_LIMIT;\n  return task.id;\n}\n\nfunction decrementExpectedAwaits() {\n  if (!task.awaits) return false;\n  if (--task.awaits === 0) task.id = 0;\n  task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n  return true;\n}\n\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n  incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\n\nfunction onPossibleParallellAsync(possiblePromise) {\n  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n    incrementExpectedAwaits();\n    return possiblePromise.then(function (x) {\n      decrementExpectedAwaits();\n      return x;\n    }, function (e) {\n      decrementExpectedAwaits();\n      return rejection(e);\n    });\n  }\n\n  return possiblePromise;\n}\n\nfunction zoneEnterEcho(targetZone) {\n  ++totalEchoes;\n\n  if (!task.echoes || --task.echoes === 0) {\n    task.echoes = task.id = 0;\n  }\n\n  zoneStack.push(PSD);\n  switchToZone(targetZone, true);\n}\n\nfunction zoneLeaveEcho() {\n  var zone = zoneStack[zoneStack.length - 1];\n  zoneStack.pop();\n  switchToZone(zone, false);\n}\n\nfunction switchToZone(targetZone, bEnteringZone) {\n  var currentZone = PSD;\n\n  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {\n    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n  }\n\n  if (targetZone === PSD) return;\n  PSD = targetZone;\n  if (currentZone === globalPSD) globalPSD.env = snapShot();\n\n  if (patchGlobalPromise) {\n    var GlobalPromise = globalPSD.env.Promise;\n    var targetEnv = targetZone.env;\n    nativePromiseProto.then = targetEnv.nthen;\n    GlobalPromise.prototype.then = targetEnv.gthen;\n\n    if (currentZone.global || targetZone.global) {\n      Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n      GlobalPromise.all = targetEnv.all;\n      GlobalPromise.race = targetEnv.race;\n      GlobalPromise.resolve = targetEnv.resolve;\n      GlobalPromise.reject = targetEnv.reject;\n      if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n      if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n    }\n  }\n}\n\nfunction snapShot() {\n  var GlobalPromise = _global.Promise;\n  return patchGlobalPromise ? {\n    Promise: GlobalPromise,\n    PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n    all: GlobalPromise.all,\n    race: GlobalPromise.race,\n    allSettled: GlobalPromise.allSettled,\n    any: GlobalPromise.any,\n    resolve: GlobalPromise.resolve,\n    reject: GlobalPromise.reject,\n    nthen: nativePromiseProto.then,\n    gthen: GlobalPromise.prototype.then\n  } : {};\n}\n\nfunction usePSD(psd, fn, a1, a2, a3) {\n  var outerScope = PSD;\n\n  try {\n    switchToZone(psd, true);\n    return fn(a1, a2, a3);\n  } finally {\n    switchToZone(outerScope, false);\n  }\n}\n\nfunction enqueueNativeMicroTask(job) {\n  nativePromiseThen.call(resolvedNativePromise, job);\n}\n\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n  return typeof fn !== 'function' ? fn : function () {\n    var outerZone = PSD;\n    if (possibleAwait) incrementExpectedAwaits();\n    switchToZone(zone, true);\n\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      switchToZone(outerZone, false);\n      if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n    }\n  };\n}\n\nfunction getPatchedPromiseThen(origThen, zone) {\n  return function (onResolved, onRejected) {\n    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n  };\n}\n\nvar UNHANDLEDREJECTION = \"unhandledrejection\";\n\nfunction globalError(err, promise) {\n  var rv;\n\n  try {\n    rv = promise.onuncatched(err);\n  } catch (e) {}\n\n  if (rv !== false) try {\n    var event,\n        eventData = {\n      promise: promise,\n      reason: err\n    };\n\n    if (_global.document && document.createEvent) {\n      event = document.createEvent('Event');\n      event.initEvent(UNHANDLEDREJECTION, true, true);\n      extend(event, eventData);\n    } else if (_global.CustomEvent) {\n      event = new CustomEvent(UNHANDLEDREJECTION, {\n        detail: eventData\n      });\n      extend(event, eventData);\n    }\n\n    if (event && _global.dispatchEvent) {\n      dispatchEvent(event);\n      if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n        _global.onunhandledrejection(event);\n      } catch (_) {}\n    }\n\n    if (debug && event && !event.defaultPrevented) {\n      console.warn(\"Unhandled rejection: \".concat(err.stack || err));\n    }\n  } catch (e) {}\n}\n\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n  if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n    if (db._state.openComplete) {\n      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n    }\n\n    if (!db._state.isBeingOpened) {\n      if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n      db.open().catch(nop);\n    }\n\n    return db._state.dbReadyPromise.then(function () {\n      return tempTransaction(db, mode, storeNames, fn);\n    });\n  } else {\n    var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n\n    try {\n      trans.create();\n      db._state.PR1398_maxLoop = 3;\n    } catch (ex) {\n      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n        console.warn('Dexie: Need to reopen db');\n\n        db._close();\n\n        return db.open().then(function () {\n          return tempTransaction(db, mode, storeNames, fn);\n        });\n      }\n\n      return rejection(ex);\n    }\n\n    return trans._promise(mode, function (resolve, reject) {\n      return newScope(function () {\n        PSD.trans = trans;\n        return fn(resolve, reject, trans);\n      });\n    }).then(function (result) {\n      return trans._completion.then(function () {\n        return result;\n      });\n    });\n  }\n}\n\nvar DEXIE_VERSION = '3.2.1';\nvar maxString = String.fromCharCode(65535);\nvar minKey = -Infinity;\nvar INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nvar STRING_EXPECTED = \"String expected.\";\nvar connections = [];\nvar isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nvar hasIEDeleteObjectStoreBug = isIEOrEdge;\nvar hangsOnDeleteLargeKeyRange = isIEOrEdge;\n\nvar dexieStackFrameFilter = function dexieStackFrameFilter(frame) {\n  return !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\n};\n\nvar DBNAMES_DB = '__dbnames';\nvar READONLY = 'readonly';\nvar READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n  return filter1 ? filter2 ? function () {\n    return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n  } : filter1 : filter2;\n}\n\nvar AnyRange = {\n  type: 3,\n  lower: -Infinity,\n  lowerOpen: false,\n  upper: [[]],\n  upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n  return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? function (obj) {\n    if (obj[keyPath] === undefined && keyPath in obj) {\n      obj = deepClone(obj);\n      delete obj[keyPath];\n    }\n\n    return obj;\n  } : function (obj) {\n    return obj;\n  };\n}\n\nvar Table = /*#__PURE__*/function () {\n  function Table() {\n    _classCallCheck(this, Table);\n  }\n\n  _createClass(Table, [{\n    key: \"_trans\",\n    value: function _trans(mode, fn, writeLocked) {\n      var trans = this._tx || PSD.trans;\n      var tableName = this.name;\n\n      function checkTableInTransaction(resolve, reject, trans) {\n        if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        return fn(trans.idbtrans, trans);\n      }\n\n      var wasRootExec = beginMicroTickScope();\n\n      try {\n        return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function () {\n          return trans._promise(mode, checkTableInTransaction, writeLocked);\n        }, {\n          trans: trans,\n          transless: PSD.transless || PSD\n        }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n      } finally {\n        if (wasRootExec) endMicroTickScope();\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(keyOrCrit, cb) {\n      var _this4 = this;\n\n      if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n      return this._trans('readonly', function (trans) {\n        return _this4.core.get({\n          trans: trans,\n          key: keyOrCrit\n        }).then(function (res) {\n          return _this4.hook.reading.fire(res);\n        });\n      }).then(cb);\n    }\n  }, {\n    key: \"where\",\n    value: function where(indexOrCrit) {\n      if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);\n      if (isArray(indexOrCrit)) return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n      var keyPaths = keys(indexOrCrit);\n      if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n      var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n        return ix.compound && keyPaths.every(function (keyPath) {\n          return ix.keyPath.indexOf(keyPath) >= 0;\n        }) && ix.keyPath.every(function (keyPath) {\n          return keyPaths.indexOf(keyPath) >= 0;\n        });\n      })[0];\n      if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function (kp) {\n        return indexOrCrit[kp];\n      }));\n      if (!compoundIndex && debug) console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit of a \") + \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n      var idxByName = this.schema.idxByName;\n      var idb = this.db._deps.indexedDB;\n\n      function equals(a, b) {\n        try {\n          return idb.cmp(a, b) === 0;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      var _keyPaths$reduce = keyPaths.reduce(function (_ref4, keyPath) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            prevIndex = _ref5[0],\n            prevFilterFn = _ref5[1];\n\n        var index = idxByName[keyPath];\n        var value = indexOrCrit[keyPath];\n        return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function (x) {\n          var prop = getByKeyPath(x, keyPath);\n          return isArray(prop) && prop.some(function (item) {\n            return equals(value, item);\n          });\n        } : function (x) {\n          return equals(value, getByKeyPath(x, keyPath));\n        }) : prevFilterFn];\n      }, [null, null]),\n          _keyPaths$reduce2 = _slicedToArray(_keyPaths$reduce, 2),\n          idx = _keyPaths$reduce2[0],\n          filterFunction = _keyPaths$reduce2[1];\n\n      return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(filterFunction) {\n      return this.toCollection().and(filterFunction);\n    }\n  }, {\n    key: \"count\",\n    value: function count(thenShortcut) {\n      return this.toCollection().count(thenShortcut);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(_offset) {\n      return this.toCollection().offset(_offset);\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(numRows) {\n      return this.toCollection().limit(numRows);\n    }\n  }, {\n    key: \"each\",\n    value: function each(callback) {\n      return this.toCollection().each(callback);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(thenShortcut) {\n      return this.toCollection().toArray(thenShortcut);\n    }\n  }, {\n    key: \"toCollection\",\n    value: function toCollection() {\n      return new this.db.Collection(new this.db.WhereClause(this));\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(index) {\n      return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? \"[\".concat(index.join('+'), \"]\") : index));\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      return this.toCollection().reverse();\n    }\n  }, {\n    key: \"mapToClass\",\n    value: function mapToClass(constructor) {\n      this.schema.mappedClass = constructor;\n\n      var readHook = function readHook(obj) {\n        if (!obj) return obj;\n        var res = Object.create(constructor.prototype);\n\n        for (var m in obj) {\n          if (hasOwn(obj, m)) try {\n            res[m] = obj[m];\n          } catch (_) {}\n        }\n\n        return res;\n      };\n\n      if (this.schema.readHook) {\n        this.hook.reading.unsubscribe(this.schema.readHook);\n      }\n\n      this.schema.readHook = readHook;\n      this.hook(\"reading\", readHook);\n      return constructor;\n    }\n  }, {\n    key: \"defineClass\",\n    value: function defineClass() {\n      function Class(content) {\n        extend(this, content);\n      }\n\n      return this.mapToClass(Class);\n    }\n  }, {\n    key: \"add\",\n    value: function add(obj, key) {\n      var _this5 = this;\n\n      var _this$schema$primKey = this.schema.primKey,\n          auto = _this$schema$primKey.auto,\n          keyPath = _this$schema$primKey.keyPath;\n      var objToAdd = obj;\n\n      if (keyPath && auto) {\n        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n      }\n\n      return this._trans('readwrite', function (trans) {\n        return _this5.core.mutate({\n          trans: trans,\n          type: 'add',\n          keys: key != null ? [key] : null,\n          values: [objToAdd]\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;\n      }).then(function (lastResult) {\n        if (keyPath) {\n          try {\n            setByKeyPath(obj, keyPath, lastResult);\n          } catch (_) {}\n        }\n\n        return lastResult;\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(keyOrObject, modifications) {\n      if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n        var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n        if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n\n        try {\n          if (typeof modifications !== \"function\") {\n            keys(modifications).forEach(function (keyPath) {\n              setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n            });\n          } else {\n            modifications(keyOrObject, {\n              value: keyOrObject,\n              primKey: key\n            });\n          }\n        } catch (_a) {}\n\n        return this.where(\":id\").equals(key).modify(modifications);\n      } else {\n        return this.where(\":id\").equals(keyOrObject).modify(modifications);\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(obj, key) {\n      var _this6 = this;\n\n      var _this$schema$primKey2 = this.schema.primKey,\n          auto = _this$schema$primKey2.auto,\n          keyPath = _this$schema$primKey2.keyPath;\n      var objToAdd = obj;\n\n      if (keyPath && auto) {\n        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n      }\n\n      return this._trans('readwrite', function (trans) {\n        return _this6.core.mutate({\n          trans: trans,\n          type: 'put',\n          values: [objToAdd],\n          keys: key != null ? [key] : null\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;\n      }).then(function (lastResult) {\n        if (keyPath) {\n          try {\n            setByKeyPath(obj, keyPath, lastResult);\n          } catch (_) {}\n        }\n\n        return lastResult;\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var _this7 = this;\n\n      return this._trans('readwrite', function (trans) {\n        return _this7.core.mutate({\n          trans: trans,\n          type: 'delete',\n          keys: [key]\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this8 = this;\n\n      return this._trans('readwrite', function (trans) {\n        return _this8.core.mutate({\n          trans: trans,\n          type: 'deleteRange',\n          range: AnyRange\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;\n      });\n    }\n  }, {\n    key: \"bulkGet\",\n    value: function bulkGet(keys) {\n      var _this9 = this;\n\n      return this._trans('readonly', function (trans) {\n        return _this9.core.getMany({\n          keys: keys,\n          trans: trans\n        }).then(function (result) {\n          return result.map(function (res) {\n            return _this9.hook.reading.fire(res);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"bulkAdd\",\n    value: function bulkAdd(objects, keysOrOptions, options) {\n      var _this10 = this;\n\n      var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n      options = options || (keys ? undefined : keysOrOptions);\n      var wantResults = options ? options.allKeys : undefined;\n      return this._trans('readwrite', function (trans) {\n        var _this10$schema$primKe = _this10.schema.primKey,\n            auto = _this10$schema$primKe.auto,\n            keyPath = _this10$schema$primKe.keyPath;\n        if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n        if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n        var numObjects = objects.length;\n        var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n        return _this10.core.mutate({\n          trans: trans,\n          type: 'add',\n          keys: keys,\n          values: objectsToAdd,\n          wantResults: wantResults\n        }).then(function (_ref6) {\n          var numFailures = _ref6.numFailures,\n              results = _ref6.results,\n              lastResult = _ref6.lastResult,\n              failures = _ref6.failures;\n          var result = wantResults ? results : lastResult;\n          if (numFailures === 0) return result;\n          throw new BulkError(\"\".concat(_this10.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n        });\n      });\n    }\n  }, {\n    key: \"bulkPut\",\n    value: function bulkPut(objects, keysOrOptions, options) {\n      var _this11 = this;\n\n      var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n      options = options || (keys ? undefined : keysOrOptions);\n      var wantResults = options ? options.allKeys : undefined;\n      return this._trans('readwrite', function (trans) {\n        var _this11$schema$primKe = _this11.schema.primKey,\n            auto = _this11$schema$primKe.auto,\n            keyPath = _this11$schema$primKe.keyPath;\n        if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n        if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n        var numObjects = objects.length;\n        var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n        return _this11.core.mutate({\n          trans: trans,\n          type: 'put',\n          keys: keys,\n          values: objectsToPut,\n          wantResults: wantResults\n        }).then(function (_ref7) {\n          var numFailures = _ref7.numFailures,\n              results = _ref7.results,\n              lastResult = _ref7.lastResult,\n              failures = _ref7.failures;\n          var result = wantResults ? results : lastResult;\n          if (numFailures === 0) return result;\n          throw new BulkError(\"\".concat(_this11.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n        });\n      });\n    }\n  }, {\n    key: \"bulkDelete\",\n    value: function bulkDelete(keys) {\n      var _this12 = this;\n\n      var numKeys = keys.length;\n      return this._trans('readwrite', function (trans) {\n        return _this12.core.mutate({\n          trans: trans,\n          type: 'delete',\n          keys: keys\n        });\n      }).then(function (_ref8) {\n        var numFailures = _ref8.numFailures,\n            lastResult = _ref8.lastResult,\n            failures = _ref8.failures;\n        if (numFailures === 0) return lastResult;\n        throw new BulkError(\"\".concat(_this12.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n      });\n    }\n  }]);\n\n  return Table;\n}();\n\nfunction Events(ctx) {\n  var evs = {};\n\n  var rv = function rv(eventName, subscriber) {\n    if (subscriber) {\n      var i = arguments.length,\n          args = new Array(i - 1);\n\n      while (--i) {\n        args[i - 1] = arguments[i];\n      }\n\n      evs[eventName].subscribe.apply(null, args);\n      return ctx;\n    } else if (typeof eventName === 'string') {\n      return evs[eventName];\n    }\n  };\n\n  rv.addEventType = add;\n\n  for (var i = 1, l = arguments.length; i < l; ++i) {\n    add(arguments[i]);\n  }\n\n  return rv;\n\n  function add(eventName, chainFunction, defaultFunction) {\n    if (typeof eventName === 'object') return addConfiguredEvents(eventName);\n    if (!chainFunction) chainFunction = reverseStoppableEventChain;\n    if (!defaultFunction) defaultFunction = nop;\n    var context = {\n      subscribers: [],\n      fire: defaultFunction,\n      subscribe: function subscribe(cb) {\n        if (context.subscribers.indexOf(cb) === -1) {\n          context.subscribers.push(cb);\n          context.fire = chainFunction(context.fire, cb);\n        }\n      },\n      unsubscribe: function unsubscribe(cb) {\n        context.subscribers = context.subscribers.filter(function (fn) {\n          return fn !== cb;\n        });\n        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n      }\n    };\n    evs[eventName] = rv[eventName] = context;\n    return context;\n  }\n\n  function addConfiguredEvents(cfg) {\n    keys(cfg).forEach(function (eventName) {\n      var args = cfg[eventName];\n\n      if (isArray(args)) {\n        add(eventName, cfg[eventName][0], cfg[eventName][1]);\n      } else if (args === 'asap') {\n        var context = add(eventName, mirror, function fire() {\n          var i = arguments.length,\n              args = new Array(i);\n\n          while (i--) {\n            args[i] = arguments[i];\n          }\n\n          context.subscribers.forEach(function (fn) {\n            asap$1(function fireEvent() {\n              fn.apply(null, args);\n            });\n          });\n        });\n      } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n    });\n  }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n  derive(constructor).from({\n    prototype: prototype\n  });\n  return constructor;\n}\n\nfunction createTableConstructor(db) {\n  return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n    this.db = db;\n    this._tx = trans;\n    this.name = name;\n    this.schema = tableSchema;\n    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n      \"creating\": [hookCreatingChain, nop],\n      \"reading\": [pureFunctionChain, mirror],\n      \"updating\": [hookUpdatingChain, nop],\n      \"deleting\": [hookDeletingChain, nop]\n    });\n  });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\n\nfunction addFilter(ctx, fn) {\n  ctx.filter = combine(ctx.filter, fn);\n}\n\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n  var curr = ctx.replayFilter;\n  ctx.replayFilter = curr ? function () {\n    return combine(curr(), factory());\n  } : factory;\n  ctx.justLimit = isLimitFilter && !curr;\n}\n\nfunction addMatchFilter(ctx, fn) {\n  ctx.isMatch = combine(ctx.isMatch, fn);\n}\n\nfunction getIndexOrStore(ctx, coreSchema) {\n  if (ctx.isPrimKey) return coreSchema.primaryKey;\n  var index = coreSchema.getIndexByKeyPath(ctx.index);\n  if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n  return index;\n}\n\nfunction openCursor(ctx, coreTable, trans) {\n  var index = getIndexOrStore(ctx, coreTable.schema);\n  return coreTable.openCursor({\n    trans: trans,\n    values: !ctx.keysOnly,\n    reverse: ctx.dir === 'prev',\n    unique: !!ctx.unique,\n    query: {\n      index: index,\n      range: ctx.range\n    }\n  });\n}\n\nfunction iter(ctx, fn, coreTrans, coreTable) {\n  var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n\n  if (!ctx.or) {\n    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n  } else {\n    var set = {};\n\n    var union = function union(item, cursor, advance) {\n      if (!filter || filter(cursor, advance, function (result) {\n        return cursor.stop(result);\n      }, function (err) {\n        return cursor.fail(err);\n      })) {\n        var primaryKey = cursor.primaryKey;\n        var key = '' + primaryKey;\n        if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);\n\n        if (!hasOwn(set, key)) {\n          set[key] = true;\n          fn(item, cursor, advance);\n        }\n      }\n    };\n\n    return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);\n  }\n}\n\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n  var mappedFn = valueMapper ? function (x, c, a) {\n    return fn(valueMapper(x), c, a);\n  } : fn;\n  var wrappedFn = wrap(mappedFn);\n  return cursorPromise.then(function (cursor) {\n    if (cursor) {\n      return cursor.start(function () {\n        var c = function c() {\n          return cursor.continue();\n        };\n\n        if (!filter || filter(cursor, function (advancer) {\n          return c = advancer;\n        }, function (val) {\n          cursor.stop(val);\n          c = nop;\n        }, function (e) {\n          cursor.fail(e);\n          c = nop;\n        })) wrappedFn(cursor.value, cursor, function (advancer) {\n          return c = advancer;\n        });\n        c();\n      });\n    }\n  });\n}\n\nfunction cmp(a, b) {\n  try {\n    var ta = type(a);\n    var tb = type(b);\n\n    if (ta !== tb) {\n      if (ta === 'Array') return 1;\n      if (tb === 'Array') return -1;\n      if (ta === 'binary') return 1;\n      if (tb === 'binary') return -1;\n      if (ta === 'string') return 1;\n      if (tb === 'string') return -1;\n      if (ta === 'Date') return 1;\n      if (tb !== 'Date') return NaN;\n      return -1;\n    }\n\n    switch (ta) {\n      case 'number':\n      case 'Date':\n      case 'string':\n        return a > b ? 1 : a < b ? -1 : 0;\n\n      case 'binary':\n        {\n          return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n        }\n\n      case 'Array':\n        return compareArrays(a, b);\n    }\n  } catch (_a) {}\n\n  return NaN;\n}\n\nfunction compareArrays(a, b) {\n  var al = a.length;\n  var bl = b.length;\n  var l = al < bl ? al : bl;\n\n  for (var i = 0; i < l; ++i) {\n    var res = cmp(a[i], b[i]);\n    if (res !== 0) return res;\n  }\n\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nfunction compareUint8Arrays(a, b) {\n  var al = a.length;\n  var bl = b.length;\n  var l = al < bl ? al : bl;\n\n  for (var i = 0; i < l; ++i) {\n    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n  }\n\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nfunction type(x) {\n  var t = typeof x;\n  if (t !== 'object') return t;\n  if (ArrayBuffer.isView(x)) return 'binary';\n  var tsTag = toStringTag(x);\n  return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\n\nfunction getUint8Array(a) {\n  if (a instanceof Uint8Array) return a;\n  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return new Uint8Array(a);\n}\n\nvar Collection = /*#__PURE__*/function () {\n  function Collection() {\n    _classCallCheck(this, Collection);\n  }\n\n  _createClass(Collection, [{\n    key: \"_read\",\n    value: function _read(fn, cb) {\n      var ctx = this._ctx;\n      return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(fn) {\n      var ctx = this._ctx;\n      return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, \"locked\");\n    }\n  }, {\n    key: \"_addAlgorithm\",\n    value: function _addAlgorithm(fn) {\n      var ctx = this._ctx;\n      ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(fn, coreTrans) {\n      return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(props) {\n      var rv = Object.create(this.constructor.prototype),\n          ctx = Object.create(this._ctx);\n      if (props) extend(ctx, props);\n      rv._ctx = ctx;\n      return rv;\n    }\n  }, {\n    key: \"raw\",\n    value: function raw() {\n      this._ctx.valueMapper = null;\n      return this;\n    }\n  }, {\n    key: \"each\",\n    value: function each(fn) {\n      var ctx = this._ctx;\n      return this._read(function (trans) {\n        return iter(ctx, fn, trans, ctx.table.core);\n      });\n    }\n  }, {\n    key: \"count\",\n    value: function count(cb) {\n      var _this13 = this;\n\n      return this._read(function (trans) {\n        var ctx = _this13._ctx;\n        var coreTable = ctx.table.core;\n\n        if (isPlainKeyRange(ctx, true)) {\n          return coreTable.count({\n            trans: trans,\n            query: {\n              index: getIndexOrStore(ctx, coreTable.schema),\n              range: ctx.range\n            }\n          }).then(function (count) {\n            return Math.min(count, ctx.limit);\n          });\n        } else {\n          var count = 0;\n          return iter(ctx, function () {\n            ++count;\n            return false;\n          }, trans, coreTable).then(function () {\n            return count;\n          });\n        }\n      }).then(cb);\n    }\n  }, {\n    key: \"sortBy\",\n    value: function sortBy(keyPath, cb) {\n      var parts = keyPath.split('.').reverse(),\n          lastPart = parts[0],\n          lastIndex = parts.length - 1;\n\n      function getval(obj, i) {\n        if (i) return getval(obj[parts[i]], i - 1);\n        return obj[lastPart];\n      }\n\n      var order = this._ctx.dir === \"next\" ? 1 : -1;\n\n      function sorter(a, b) {\n        var aVal = getval(a, lastIndex),\n            bVal = getval(b, lastIndex);\n        return aVal < bVal ? -order : aVal > bVal ? order : 0;\n      }\n\n      return this.toArray(function (a) {\n        return a.sort(sorter);\n      }).then(cb);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(cb) {\n      var _this14 = this;\n\n      return this._read(function (trans) {\n        var ctx = _this14._ctx;\n\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n          var valueMapper = ctx.valueMapper;\n          var index = getIndexOrStore(ctx, ctx.table.core.schema);\n          return ctx.table.core.query({\n            trans: trans,\n            limit: ctx.limit,\n            values: true,\n            query: {\n              index: index,\n              range: ctx.range\n            }\n          }).then(function (_ref9) {\n            var result = _ref9.result;\n            return valueMapper ? result.map(valueMapper) : result;\n          });\n        } else {\n          var a = [];\n          return iter(ctx, function (item) {\n            return a.push(item);\n          }, trans, ctx.table.core).then(function () {\n            return a;\n          });\n        }\n      }, cb);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(_offset2) {\n      var ctx = this._ctx;\n      if (_offset2 <= 0) return this;\n      ctx.offset += _offset2;\n\n      if (isPlainKeyRange(ctx)) {\n        addReplayFilter(ctx, function () {\n          var offsetLeft = _offset2;\n          return function (cursor, advance) {\n            if (offsetLeft === 0) return true;\n\n            if (offsetLeft === 1) {\n              --offsetLeft;\n              return false;\n            }\n\n            advance(function () {\n              cursor.advance(offsetLeft);\n              offsetLeft = 0;\n            });\n            return false;\n          };\n        });\n      } else {\n        addReplayFilter(ctx, function () {\n          var offsetLeft = _offset2;\n          return function () {\n            return --offsetLeft < 0;\n          };\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(numRows) {\n      this._ctx.limit = Math.min(this._ctx.limit, numRows);\n      addReplayFilter(this._ctx, function () {\n        var rowsLeft = numRows;\n        return function (cursor, advance, resolve) {\n          if (--rowsLeft <= 0) advance(resolve);\n          return rowsLeft >= 0;\n        };\n      }, true);\n      return this;\n    }\n  }, {\n    key: \"until\",\n    value: function until(filterFunction, bIncludeStopEntry) {\n      addFilter(this._ctx, function (cursor, advance, resolve) {\n        if (filterFunction(cursor.value)) {\n          advance(resolve);\n          return bIncludeStopEntry;\n        } else {\n          return true;\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"first\",\n    value: function first(cb) {\n      return this.limit(1).toArray(function (a) {\n        return a[0];\n      }).then(cb);\n    }\n  }, {\n    key: \"last\",\n    value: function last(cb) {\n      return this.reverse().first(cb);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(filterFunction) {\n      addFilter(this._ctx, function (cursor) {\n        return filterFunction(cursor.value);\n      });\n      addMatchFilter(this._ctx, filterFunction);\n      return this;\n    }\n  }, {\n    key: \"and\",\n    value: function and(filter) {\n      return this.filter(filter);\n    }\n  }, {\n    key: \"or\",\n    value: function or(indexName) {\n      return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n      if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n      return this;\n    }\n  }, {\n    key: \"desc\",\n    value: function desc() {\n      return this.reverse();\n    }\n  }, {\n    key: \"eachKey\",\n    value: function eachKey(cb) {\n      var ctx = this._ctx;\n      ctx.keysOnly = !ctx.isMatch;\n      return this.each(function (val, cursor) {\n        cb(cursor.key, cursor);\n      });\n    }\n  }, {\n    key: \"eachUniqueKey\",\n    value: function eachUniqueKey(cb) {\n      this._ctx.unique = \"unique\";\n      return this.eachKey(cb);\n    }\n  }, {\n    key: \"eachPrimaryKey\",\n    value: function eachPrimaryKey(cb) {\n      var ctx = this._ctx;\n      ctx.keysOnly = !ctx.isMatch;\n      return this.each(function (val, cursor) {\n        cb(cursor.primaryKey, cursor);\n      });\n    }\n  }, {\n    key: \"keys\",\n    value: function keys(cb) {\n      var ctx = this._ctx;\n      ctx.keysOnly = !ctx.isMatch;\n      var a = [];\n      return this.each(function (item, cursor) {\n        a.push(cursor.key);\n      }).then(function () {\n        return a;\n      }).then(cb);\n    }\n  }, {\n    key: \"primaryKeys\",\n    value: function primaryKeys(cb) {\n      var ctx = this._ctx;\n\n      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n        return this._read(function (trans) {\n          var index = getIndexOrStore(ctx, ctx.table.core.schema);\n          return ctx.table.core.query({\n            trans: trans,\n            values: false,\n            limit: ctx.limit,\n            query: {\n              index: index,\n              range: ctx.range\n            }\n          });\n        }).then(function (_ref10) {\n          var result = _ref10.result;\n          return result;\n        }).then(cb);\n      }\n\n      ctx.keysOnly = !ctx.isMatch;\n      var a = [];\n      return this.each(function (item, cursor) {\n        a.push(cursor.primaryKey);\n      }).then(function () {\n        return a;\n      }).then(cb);\n    }\n  }, {\n    key: \"uniqueKeys\",\n    value: function uniqueKeys(cb) {\n      this._ctx.unique = \"unique\";\n      return this.keys(cb);\n    }\n  }, {\n    key: \"firstKey\",\n    value: function firstKey(cb) {\n      return this.limit(1).keys(function (a) {\n        return a[0];\n      }).then(cb);\n    }\n  }, {\n    key: \"lastKey\",\n    value: function lastKey(cb) {\n      return this.reverse().firstKey(cb);\n    }\n  }, {\n    key: \"distinct\",\n    value: function distinct() {\n      var ctx = this._ctx,\n          idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n      if (!idx || !idx.multi) return this;\n      var set = {};\n      addFilter(this._ctx, function (cursor) {\n        var strKey = cursor.primaryKey.toString();\n        var found = hasOwn(set, strKey);\n        set[strKey] = true;\n        return !found;\n      });\n      return this;\n    }\n  }, {\n    key: \"modify\",\n    value: function modify(changes) {\n      var _this15 = this;\n\n      var ctx = this._ctx;\n      return this._write(function (trans) {\n        var modifyer;\n\n        if (typeof changes === 'function') {\n          modifyer = changes;\n        } else {\n          var keyPaths = keys(changes);\n          var numKeys = keyPaths.length;\n\n          modifyer = function modifyer(item) {\n            var anythingModified = false;\n\n            for (var i = 0; i < numKeys; ++i) {\n              var keyPath = keyPaths[i],\n                  val = changes[keyPath];\n\n              if (getByKeyPath(item, keyPath) !== val) {\n                setByKeyPath(item, keyPath, val);\n                anythingModified = true;\n              }\n            }\n\n            return anythingModified;\n          };\n        }\n\n        var coreTable = ctx.table.core;\n        var _coreTable$schema$pri = coreTable.schema.primaryKey,\n            outbound = _coreTable$schema$pri.outbound,\n            extractKey = _coreTable$schema$pri.extractKey;\n        var limit = _this15.db._options.modifyChunkSize || 200;\n        var totalFailures = [];\n        var successCount = 0;\n        var failedKeys = [];\n\n        var applyMutateResult = function applyMutateResult(expectedCount, res) {\n          var failures = res.failures,\n              numFailures = res.numFailures;\n          successCount += expectedCount - numFailures;\n\n          var _iterator = _createForOfIteratorHelper(keys(failures)),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var pos = _step.value;\n              totalFailures.push(failures[pos]);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        };\n\n        return _this15.clone().primaryKeys().then(function (keys) {\n          var nextChunk = function nextChunk(offset) {\n            var count = Math.min(limit, keys.length - offset);\n            return coreTable.getMany({\n              trans: trans,\n              keys: keys.slice(offset, offset + count),\n              cache: \"immutable\"\n            }).then(function (values) {\n              var addValues = [];\n              var putValues = [];\n              var putKeys = outbound ? [] : null;\n              var deleteKeys = [];\n\n              for (var i = 0; i < count; ++i) {\n                var origValue = values[i];\n                var _ctx = {\n                  value: deepClone(origValue),\n                  primKey: keys[offset + i]\n                };\n\n                if (modifyer.call(_ctx, _ctx.value, _ctx) !== false) {\n                  if (_ctx.value == null) {\n                    deleteKeys.push(keys[offset + i]);\n                  } else if (!outbound && cmp(extractKey(origValue), extractKey(_ctx.value)) !== 0) {\n                    deleteKeys.push(keys[offset + i]);\n                    addValues.push(_ctx.value);\n                  } else {\n                    putValues.push(_ctx.value);\n                    if (outbound) putKeys.push(keys[offset + i]);\n                  }\n                }\n              }\n\n              var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || changes === deleteCallback) && {\n                index: ctx.index,\n                range: ctx.range\n              };\n              return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n                trans: trans,\n                type: 'add',\n                values: addValues\n              }).then(function (res) {\n                for (var pos in res.failures) {\n                  deleteKeys.splice(parseInt(pos), 1);\n                }\n\n                applyMutateResult(addValues.length, res);\n              })).then(function () {\n                return (putValues.length > 0 || criteria && typeof changes === 'object') && coreTable.mutate({\n                  trans: trans,\n                  type: 'put',\n                  keys: putKeys,\n                  values: putValues,\n                  criteria: criteria,\n                  changeSpec: typeof changes !== 'function' && changes\n                }).then(function (res) {\n                  return applyMutateResult(putValues.length, res);\n                });\n              }).then(function () {\n                return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n                  trans: trans,\n                  type: 'delete',\n                  keys: deleteKeys,\n                  criteria: criteria\n                }).then(function (res) {\n                  return applyMutateResult(deleteKeys.length, res);\n                });\n              }).then(function () {\n                return keys.length > offset + count && nextChunk(offset + limit);\n              });\n            });\n          };\n\n          return nextChunk(0).then(function () {\n            if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n            return keys.length;\n          });\n        });\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var ctx = this._ctx,\n          range = ctx.range;\n\n      if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n        return this._write(function (trans) {\n          var primaryKey = ctx.table.core.schema.primaryKey;\n          var coreRange = range;\n          return ctx.table.core.count({\n            trans: trans,\n            query: {\n              index: primaryKey,\n              range: coreRange\n            }\n          }).then(function (count) {\n            return ctx.table.core.mutate({\n              trans: trans,\n              type: 'deleteRange',\n              range: coreRange\n            }).then(function (_ref11) {\n              var failures = _ref11.failures,\n                  lastResult = _ref11.lastResult,\n                  results = _ref11.results,\n                  numFailures = _ref11.numFailures;\n              if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) {\n                return failures[pos];\n              }), count - numFailures);\n              return count - numFailures;\n            });\n          });\n        });\n      }\n\n      return this.modify(deleteCallback);\n    }\n  }]);\n\n  return Collection;\n}();\n\nvar deleteCallback = function deleteCallback(value, ctx) {\n  return ctx.value = null;\n};\n\nfunction createCollectionConstructor(db) {\n  return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n    this.db = db;\n    var keyRange = AnyRange,\n        error = null;\n    if (keyRangeGenerator) try {\n      keyRange = keyRangeGenerator();\n    } catch (ex) {\n      error = ex;\n    }\n    var whereCtx = whereClause._ctx;\n    var table = whereCtx.table;\n    var readingHook = table.hook.reading.fire;\n    this._ctx = {\n      table: table,\n      index: whereCtx.index,\n      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n      range: keyRange,\n      keysOnly: false,\n      dir: \"next\",\n      unique: \"\",\n      algorithm: null,\n      filter: null,\n      replayFilter: null,\n      justLimit: true,\n      isMatch: null,\n      offset: 0,\n      limit: Infinity,\n      error: error,\n      or: whereCtx.or,\n      valueMapper: readingHook !== mirror ? readingHook : null\n    };\n  });\n}\n\nfunction simpleCompare(a, b) {\n  return a < b ? -1 : a === b ? 0 : 1;\n}\n\nfunction simpleCompareReverse(a, b) {\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n  collection._ctx.error = T ? new T(err) : new TypeError(err);\n  return collection;\n}\n\nfunction emptyCollection(whereClause) {\n  return new whereClause.Collection(whereClause, function () {\n    return rangeEqual(\"\");\n  }).limit(0);\n}\n\nfunction upperFactory(dir) {\n  return dir === \"next\" ? function (s) {\n    return s.toUpperCase();\n  } : function (s) {\n    return s.toLowerCase();\n  };\n}\n\nfunction lowerFactory(dir) {\n  return dir === \"next\" ? function (s) {\n    return s.toLowerCase();\n  } : function (s) {\n    return s.toUpperCase();\n  };\n}\n\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n  var length = Math.min(key.length, lowerNeedle.length);\n  var llp = -1;\n\n  for (var i = 0; i < length; ++i) {\n    var lwrKeyChar = lowerKey[i];\n\n    if (lwrKeyChar !== lowerNeedle[i]) {\n      if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n      if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n      if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n      return null;\n    }\n\n    if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n  }\n\n  if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n  if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\n\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n  var upper,\n      lower,\n      compare,\n      upperNeedles,\n      lowerNeedles,\n      direction,\n      nextKeySuffix,\n      needlesLen = needles.length;\n\n  if (!needles.every(function (s) {\n    return typeof s === 'string';\n  })) {\n    return fail(whereClause, STRING_EXPECTED);\n  }\n\n  function initDirection(dir) {\n    upper = upperFactory(dir);\n    lower = lowerFactory(dir);\n    compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n    var needleBounds = needles.map(function (needle) {\n      return {\n        lower: lower(needle),\n        upper: upper(needle)\n      };\n    }).sort(function (a, b) {\n      return compare(a.lower, b.lower);\n    });\n    upperNeedles = needleBounds.map(function (nb) {\n      return nb.upper;\n    });\n    lowerNeedles = needleBounds.map(function (nb) {\n      return nb.lower;\n    });\n    direction = dir;\n    nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n  }\n\n  initDirection(\"next\");\n  var c = new whereClause.Collection(whereClause, function () {\n    return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);\n  });\n\n  c._ondirectionchange = function (direction) {\n    initDirection(direction);\n  };\n\n  var firstPossibleNeedle = 0;\n\n  c._addAlgorithm(function (cursor, advance, resolve) {\n    var key = cursor.key;\n    if (typeof key !== 'string') return false;\n    var lowerKey = lower(key);\n\n    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n      return true;\n    } else {\n      var lowestPossibleCasing = null;\n\n      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n          lowestPossibleCasing = casing;\n        }\n      }\n\n      if (lowestPossibleCasing !== null) {\n        advance(function () {\n          cursor.continue(lowestPossibleCasing + nextKeySuffix);\n        });\n      } else {\n        advance(resolve);\n      }\n\n      return false;\n    }\n  });\n\n  return c;\n}\n\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n  return {\n    type: 2,\n    lower: lower,\n    upper: upper,\n    lowerOpen: lowerOpen,\n    upperOpen: upperOpen\n  };\n}\n\nfunction rangeEqual(value) {\n  return {\n    type: 1,\n    lower: value,\n    upper: value\n  };\n}\n\nvar WhereClause = /*#__PURE__*/function () {\n  function WhereClause() {\n    _classCallCheck(this, WhereClause);\n  }\n\n  _createClass(WhereClause, [{\n    key: \"Collection\",\n    get: function get() {\n      return this._ctx.table.db.Collection;\n    }\n  }, {\n    key: \"between\",\n    value: function between(lower, upper, includeLower, includeUpper) {\n      includeLower = includeLower !== false;\n      includeUpper = includeUpper === true;\n\n      try {\n        if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n        return new this.Collection(this, function () {\n          return createRange(lower, upper, !includeLower, !includeUpper);\n        });\n      } catch (e) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return rangeEqual(value);\n      });\n    }\n  }, {\n    key: \"above\",\n    value: function above(value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(value, undefined, true);\n      });\n    }\n  }, {\n    key: \"aboveOrEqual\",\n    value: function aboveOrEqual(value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(value, undefined, false);\n      });\n    }\n  }, {\n    key: \"below\",\n    value: function below(value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(undefined, value, false, true);\n      });\n    }\n  }, {\n    key: \"belowOrEqual\",\n    value: function belowOrEqual(value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(undefined, value);\n      });\n    }\n  }, {\n    key: \"startsWith\",\n    value: function startsWith(str) {\n      if (typeof str !== 'string') return fail(this, STRING_EXPECTED);\n      return this.between(str, str + maxString, true, true);\n    }\n  }, {\n    key: \"startsWithIgnoreCase\",\n    value: function startsWithIgnoreCase(str) {\n      if (str === \"\") return this.startsWith(str);\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return x.indexOf(a[0]) === 0;\n      }, [str], maxString);\n    }\n  }, {\n    key: \"equalsIgnoreCase\",\n    value: function equalsIgnoreCase(str) {\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return x === a[0];\n      }, [str], \"\");\n    }\n  }, {\n    key: \"anyOfIgnoreCase\",\n    value: function anyOfIgnoreCase() {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (set.length === 0) return emptyCollection(this);\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return a.indexOf(x) !== -1;\n      }, set, \"\");\n    }\n  }, {\n    key: \"startsWithAnyOfIgnoreCase\",\n    value: function startsWithAnyOfIgnoreCase() {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (set.length === 0) return emptyCollection(this);\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return a.some(function (n) {\n          return x.indexOf(n) === 0;\n        });\n      }, set, maxString);\n    }\n  }, {\n    key: \"anyOf\",\n    value: function anyOf() {\n      var _this16 = this;\n\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      var compare = this._cmp;\n\n      try {\n        set.sort(compare);\n      } catch (e) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n\n      if (set.length === 0) return emptyCollection(this);\n      var c = new this.Collection(this, function () {\n        return createRange(set[0], set[set.length - 1]);\n      });\n\n      c._ondirectionchange = function (direction) {\n        compare = direction === \"next\" ? _this16._ascending : _this16._descending;\n        set.sort(compare);\n      };\n\n      var i = 0;\n\n      c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n\n        while (compare(key, set[i]) > 0) {\n          ++i;\n\n          if (i === set.length) {\n            advance(resolve);\n            return false;\n          }\n        }\n\n        if (compare(key, set[i]) === 0) {\n          return true;\n        } else {\n          advance(function () {\n            cursor.continue(set[i]);\n          });\n          return false;\n        }\n      });\n\n      return c;\n    }\n  }, {\n    key: \"notEqual\",\n    value: function notEqual(value) {\n      return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {\n        includeLowers: false,\n        includeUppers: false\n      });\n    }\n  }, {\n    key: \"noneOf\",\n    value: function noneOf() {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (set.length === 0) return new this.Collection(this);\n\n      try {\n        set.sort(this._ascending);\n      } catch (e) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n\n      var ranges = set.reduce(function (res, val) {\n        return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];\n      }, null);\n      ranges.push([set[set.length - 1], this.db._maxKey]);\n      return this.inAnyRange(ranges, {\n        includeLowers: false,\n        includeUppers: false\n      });\n    }\n  }, {\n    key: \"inAnyRange\",\n    value: function inAnyRange(ranges, options) {\n      var _this17 = this;\n\n      var cmp = this._cmp,\n          ascending = this._ascending,\n          descending = this._descending,\n          min = this._min,\n          max = this._max;\n      if (ranges.length === 0) return emptyCollection(this);\n\n      if (!ranges.every(function (range) {\n        return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;\n      })) {\n        return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n      }\n\n      var includeLowers = !options || options.includeLowers !== false;\n      var includeUppers = options && options.includeUppers === true;\n\n      function addRange(ranges, newRange) {\n        var i = 0,\n            l = ranges.length;\n\n        for (; i < l; ++i) {\n          var range = ranges[i];\n\n          if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n            range[0] = min(range[0], newRange[0]);\n            range[1] = max(range[1], newRange[1]);\n            break;\n          }\n        }\n\n        if (i === l) ranges.push(newRange);\n        return ranges;\n      }\n\n      var sortDirection = ascending;\n\n      function rangeSorter(a, b) {\n        return sortDirection(a[0], b[0]);\n      }\n\n      var set;\n\n      try {\n        set = ranges.reduce(addRange, []);\n        set.sort(rangeSorter);\n      } catch (ex) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n\n      var rangePos = 0;\n      var keyIsBeyondCurrentEntry = includeUppers ? function (key) {\n        return ascending(key, set[rangePos][1]) > 0;\n      } : function (key) {\n        return ascending(key, set[rangePos][1]) >= 0;\n      };\n      var keyIsBeforeCurrentEntry = includeLowers ? function (key) {\n        return descending(key, set[rangePos][0]) > 0;\n      } : function (key) {\n        return descending(key, set[rangePos][0]) >= 0;\n      };\n\n      function keyWithinCurrentRange(key) {\n        return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n      }\n\n      var checkKey = keyIsBeyondCurrentEntry;\n      var c = new this.Collection(this, function () {\n        return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);\n      });\n\n      c._ondirectionchange = function (direction) {\n        if (direction === \"next\") {\n          checkKey = keyIsBeyondCurrentEntry;\n          sortDirection = ascending;\n        } else {\n          checkKey = keyIsBeforeCurrentEntry;\n          sortDirection = descending;\n        }\n\n        set.sort(rangeSorter);\n      };\n\n      c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n\n        while (checkKey(key)) {\n          ++rangePos;\n\n          if (rangePos === set.length) {\n            advance(resolve);\n            return false;\n          }\n        }\n\n        if (keyWithinCurrentRange(key)) {\n          return true;\n        } else if (_this17._cmp(key, set[rangePos][1]) === 0 || _this17._cmp(key, set[rangePos][0]) === 0) {\n          return false;\n        } else {\n          advance(function () {\n            if (sortDirection === ascending) cursor.continue(set[rangePos][0]);else cursor.continue(set[rangePos][1]);\n          });\n          return false;\n        }\n      });\n\n      return c;\n    }\n  }, {\n    key: \"startsWithAnyOf\",\n    value: function startsWithAnyOf() {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\n      if (!set.every(function (s) {\n        return typeof s === 'string';\n      })) {\n        return fail(this, \"startsWithAnyOf() only works with strings\");\n      }\n\n      if (set.length === 0) return emptyCollection(this);\n      return this.inAnyRange(set.map(function (str) {\n        return [str, str + maxString];\n      }));\n    }\n  }]);\n\n  return WhereClause;\n}();\n\nfunction createWhereClauseConstructor(db) {\n  return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n    this.db = db;\n    this._ctx = {\n      table: table,\n      index: index === \":id\" ? null : index,\n      or: orCollection\n    };\n    var indexedDB = db._deps.indexedDB;\n    if (!indexedDB) throw new exceptions.MissingAPI();\n    this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n\n    this._descending = function (a, b) {\n      return indexedDB.cmp(b, a);\n    };\n\n    this._max = function (a, b) {\n      return indexedDB.cmp(a, b) > 0 ? a : b;\n    };\n\n    this._min = function (a, b) {\n      return indexedDB.cmp(a, b) < 0 ? a : b;\n    };\n\n    this._IDBKeyRange = db._deps.IDBKeyRange;\n  });\n}\n\nfunction eventRejectHandler(reject) {\n  return wrap(function (event) {\n    preventDefault(event);\n    reject(event.target.error);\n    return false;\n  });\n}\n\nfunction preventDefault(event) {\n  if (event.stopPropagation) event.stopPropagation();\n  if (event.preventDefault) event.preventDefault();\n}\n\nvar DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nvar STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nvar globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nvar Transaction = /*#__PURE__*/function () {\n  function Transaction() {\n    _classCallCheck(this, Transaction);\n  }\n\n  _createClass(Transaction, [{\n    key: \"_lock\",\n    value: function _lock() {\n      assert(!PSD.global);\n      ++this._reculock;\n      if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n      return this;\n    }\n  }, {\n    key: \"_unlock\",\n    value: function _unlock() {\n      assert(!PSD.global);\n\n      if (--this._reculock === 0) {\n        if (!PSD.global) PSD.lockOwnerFor = null;\n\n        while (this._blockedFuncs.length > 0 && !this._locked()) {\n          var fnAndPSD = this._blockedFuncs.shift();\n\n          try {\n            usePSD(fnAndPSD[1], fnAndPSD[0]);\n          } catch (e) {}\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_locked\",\n    value: function _locked() {\n      return this._reculock && PSD.lockOwnerFor !== this;\n    }\n  }, {\n    key: \"create\",\n    value: function create(idbtrans) {\n      var _this18 = this;\n\n      if (!this.mode) return this;\n      var idbdb = this.db.idbdb;\n      var dbOpenError = this.db._state.dbOpenError;\n      assert(!this.idbtrans);\n\n      if (!idbtrans && !idbdb) {\n        switch (dbOpenError && dbOpenError.name) {\n          case \"DatabaseClosedError\":\n            throw new exceptions.DatabaseClosed(dbOpenError);\n\n          case \"MissingAPIError\":\n            throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n\n          default:\n            throw new exceptions.OpenFailed(dbOpenError);\n        }\n      }\n\n      if (!this.active) throw new exceptions.TransactionInactive();\n      assert(this._completion._state === null);\n      idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n        durability: this.chromeTransactionDurability\n      }) : idbdb.transaction(this.storeNames, this.mode, {\n        durability: this.chromeTransactionDurability\n      }));\n      idbtrans.onerror = wrap(function (ev) {\n        preventDefault(ev);\n\n        _this18._reject(idbtrans.error);\n      });\n      idbtrans.onabort = wrap(function (ev) {\n        preventDefault(ev);\n        _this18.active && _this18._reject(new exceptions.Abort(idbtrans.error));\n        _this18.active = false;\n\n        _this18.on(\"abort\").fire(ev);\n      });\n      idbtrans.oncomplete = wrap(function () {\n        _this18.active = false;\n\n        _this18._resolve();\n\n        if ('mutatedParts' in idbtrans) {\n          globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"_promise\",\n    value: function _promise(mode, fn, bWriteLock) {\n      var _this19 = this;\n\n      if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n      if (!this.active) return rejection(new exceptions.TransactionInactive());\n\n      if (this._locked()) {\n        return new DexiePromise(function (resolve, reject) {\n          _this19._blockedFuncs.push([function () {\n            _this19._promise(mode, fn, bWriteLock).then(resolve, reject);\n          }, PSD]);\n        });\n      } else if (bWriteLock) {\n        return newScope(function () {\n          var p = new DexiePromise(function (resolve, reject) {\n            _this19._lock();\n\n            var rv = fn(resolve, reject, _this19);\n            if (rv && rv.then) rv.then(resolve, reject);\n          });\n          p.finally(function () {\n            return _this19._unlock();\n          });\n          p._lib = true;\n          return p;\n        });\n      } else {\n        var p = new DexiePromise(function (resolve, reject) {\n          var rv = fn(resolve, reject, _this19);\n          if (rv && rv.then) rv.then(resolve, reject);\n        });\n        p._lib = true;\n        return p;\n      }\n    }\n  }, {\n    key: \"_root\",\n    value: function _root() {\n      return this.parent ? this.parent._root() : this;\n    }\n  }, {\n    key: \"waitFor\",\n    value: function waitFor(promiseLike) {\n      var root = this._root();\n\n      var promise = DexiePromise.resolve(promiseLike);\n\n      if (root._waitingFor) {\n        root._waitingFor = root._waitingFor.then(function () {\n          return promise;\n        });\n      } else {\n        root._waitingFor = promise;\n        root._waitingQueue = [];\n        var store = root.idbtrans.objectStore(root.storeNames[0]);\n\n        (function spin() {\n          ++root._spinCount;\n\n          while (root._waitingQueue.length) {\n            root._waitingQueue.shift()();\n          }\n\n          if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n        })();\n      }\n\n      var currentWaitPromise = root._waitingFor;\n      return new DexiePromise(function (resolve, reject) {\n        promise.then(function (res) {\n          return root._waitingQueue.push(wrap(resolve.bind(null, res)));\n        }, function (err) {\n          return root._waitingQueue.push(wrap(reject.bind(null, err)));\n        }).finally(function () {\n          if (root._waitingFor === currentWaitPromise) {\n            root._waitingFor = null;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (this.active) {\n        this.active = false;\n        if (this.idbtrans) this.idbtrans.abort();\n\n        this._reject(new exceptions.Abort());\n      }\n    }\n  }, {\n    key: \"table\",\n    value: function table(tableName) {\n      var memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n      if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n      var tableSchema = this.schema[tableName];\n\n      if (!tableSchema) {\n        throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n      }\n\n      var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n      transactionBoundTable.core = this.db.core.table(tableName);\n      memoizedTables[tableName] = transactionBoundTable;\n      return transactionBoundTable;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nfunction createTransactionConstructor(db) {\n  return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n    var _this20 = this;\n\n    this.db = db;\n    this.mode = mode;\n    this.storeNames = storeNames;\n    this.schema = dbschema;\n    this.chromeTransactionDurability = chromeTransactionDurability;\n    this.idbtrans = null;\n    this.on = Events(this, \"complete\", \"error\", \"abort\");\n    this.parent = parent || null;\n    this.active = true;\n    this._reculock = 0;\n    this._blockedFuncs = [];\n    this._resolve = null;\n    this._reject = null;\n    this._waitingFor = null;\n    this._waitingQueue = null;\n    this._spinCount = 0;\n    this._completion = new DexiePromise(function (resolve, reject) {\n      _this20._resolve = resolve;\n      _this20._reject = reject;\n    });\n\n    this._completion.then(function () {\n      _this20.active = false;\n\n      _this20.on.complete.fire();\n    }, function (e) {\n      var wasActive = _this20.active;\n      _this20.active = false;\n\n      _this20.on.error.fire(e);\n\n      _this20.parent ? _this20.parent._reject(e) : wasActive && _this20.idbtrans && _this20.idbtrans.abort();\n      return rejection(e);\n    });\n  });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n  return {\n    name: name,\n    keyPath: keyPath,\n    unique: unique,\n    multi: multi,\n    auto: auto,\n    compound: compound,\n    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n  };\n}\n\nfunction nameFromKeyPath(keyPath) {\n  return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n  return {\n    name: name,\n    primKey: primKey,\n    indexes: indexes,\n    mappedClass: null,\n    idxByName: arrayToObject(indexes, function (index) {\n      return [index.name, index];\n    })\n  };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n  return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\n\nvar _getMaxKey = function getMaxKey(IdbKeyRange) {\n  try {\n    IdbKeyRange.only([[]]);\n\n    _getMaxKey = function getMaxKey() {\n      return [[]];\n    };\n\n    return [[]];\n  } catch (e) {\n    _getMaxKey = function getMaxKey() {\n      return maxString;\n    };\n\n    return maxString;\n  }\n};\n\nfunction getKeyExtractor(keyPath) {\n  if (keyPath == null) {\n    return function () {\n      return undefined;\n    };\n  } else if (typeof keyPath === 'string') {\n    return getSinglePathKeyExtractor(keyPath);\n  } else {\n    return function (obj) {\n      return getByKeyPath(obj, keyPath);\n    };\n  }\n}\n\nfunction getSinglePathKeyExtractor(keyPath) {\n  var split = keyPath.split('.');\n\n  if (split.length === 1) {\n    return function (obj) {\n      return obj[keyPath];\n    };\n  } else {\n    return function (obj) {\n      return getByKeyPath(obj, keyPath);\n    };\n  }\n}\n\nfunction arrayify(arrayLike) {\n  return [].slice.call(arrayLike);\n}\n\nvar _id_counter = 0;\n\nfunction getKeyPathAlias(keyPath) {\n  return keyPath == null ? \":id\" : typeof keyPath === 'string' ? keyPath : \"[\".concat(keyPath.join('+'), \"]\");\n}\n\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n  function extractSchema(db, trans) {\n    var tables = arrayify(db.objectStoreNames);\n    return {\n      schema: {\n        name: db.name,\n        tables: tables.map(function (table) {\n          return trans.objectStore(table);\n        }).map(function (store) {\n          var keyPath = store.keyPath,\n              autoIncrement = store.autoIncrement;\n          var compound = isArray(keyPath);\n          var outbound = keyPath == null;\n          var indexByKeyPath = {};\n          var result = {\n            name: store.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: true,\n              outbound: outbound,\n              compound: compound,\n              keyPath: keyPath,\n              autoIncrement: autoIncrement,\n              unique: true,\n              extractKey: getKeyExtractor(keyPath)\n            },\n            indexes: arrayify(store.indexNames).map(function (indexName) {\n              return store.index(indexName);\n            }).map(function (index) {\n              var name = index.name,\n                  unique = index.unique,\n                  multiEntry = index.multiEntry,\n                  keyPath = index.keyPath;\n              var compound = isArray(keyPath);\n              var result = {\n                name: name,\n                compound: compound,\n                keyPath: keyPath,\n                unique: unique,\n                multiEntry: multiEntry,\n                extractKey: getKeyExtractor(keyPath)\n              };\n              indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n              return result;\n            }),\n            getIndexByKeyPath: function getIndexByKeyPath(keyPath) {\n              return indexByKeyPath[getKeyPathAlias(keyPath)];\n            }\n          };\n          indexByKeyPath[\":id\"] = result.primaryKey;\n\n          if (keyPath != null) {\n            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n          }\n\n          return result;\n        })\n      },\n      hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n    };\n  }\n\n  function makeIDBKeyRange(range) {\n    if (range.type === 3) return null;\n    if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    var lower = range.lower,\n        upper = range.upper,\n        lowerOpen = range.lowerOpen,\n        upperOpen = range.upperOpen;\n    var idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n    return idbRange;\n  }\n\n  function createDbCoreTable(tableSchema) {\n    var tableName = tableSchema.name;\n\n    function mutate(_ref12) {\n      var trans = _ref12.trans,\n          type = _ref12.type,\n          keys = _ref12.keys,\n          values = _ref12.values,\n          range = _ref12.range;\n      return new Promise(function (resolve, reject) {\n        resolve = wrap(resolve);\n        var store = trans.objectStore(tableName);\n        var outbound = store.keyPath == null;\n        var isAddOrPut = type === \"put\" || type === \"add\";\n        if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error(\"Invalid operation type: \" + type);\n\n        var _ref13 = keys || values || {\n          length: 1\n        },\n            length = _ref13.length;\n\n        if (keys && values && keys.length !== values.length) {\n          throw new Error(\"Given keys array must have same length as given values array.\");\n        }\n\n        if (length === 0) return resolve({\n          numFailures: 0,\n          failures: {},\n          results: [],\n          lastResult: undefined\n        });\n        var req;\n        var reqs = [];\n        var failures = [];\n        var numFailures = 0;\n\n        var errorHandler = function errorHandler(event) {\n          ++numFailures;\n          preventDefault(event);\n        };\n\n        if (type === 'deleteRange') {\n          if (range.type === 4) return resolve({\n            numFailures: numFailures,\n            failures: failures,\n            results: [],\n            lastResult: undefined\n          });\n          if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n        } else {\n          var _ref14 = isAddOrPut ? outbound ? [values, keys] : [values, null] : [keys, null],\n              _ref15 = _slicedToArray(_ref14, 2),\n              args1 = _ref15[0],\n              args2 = _ref15[1];\n\n          if (isAddOrPut) {\n            for (var i = 0; i < length; ++i) {\n              reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n              req.onerror = errorHandler;\n            }\n          } else {\n            for (var _i = 0; _i < length; ++_i) {\n              reqs.push(req = store[type](args1[_i]));\n              req.onerror = errorHandler;\n            }\n          }\n        }\n\n        var done = function done(event) {\n          var lastResult = event.target.result;\n          reqs.forEach(function (req, i) {\n            return req.error != null && (failures[i] = req.error);\n          });\n          resolve({\n            numFailures: numFailures,\n            failures: failures,\n            results: type === \"delete\" ? keys : reqs.map(function (req) {\n              return req.result;\n            }),\n            lastResult: lastResult\n          });\n        };\n\n        req.onerror = function (event) {\n          errorHandler(event);\n          done(event);\n        };\n\n        req.onsuccess = done;\n      });\n    }\n\n    function openCursor(_ref16) {\n      var trans = _ref16.trans,\n          values = _ref16.values,\n          query = _ref16.query,\n          reverse = _ref16.reverse,\n          unique = _ref16.unique;\n      return new Promise(function (resolve, reject) {\n        resolve = wrap(resolve);\n        var index = query.index,\n            range = query.range;\n        var store = trans.objectStore(tableName);\n        var source = index.isPrimaryKey ? store : store.index(index.name);\n        var direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n        var req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n        req.onerror = eventRejectHandler(reject);\n        req.onsuccess = wrap(function (ev) {\n          var cursor = req.result;\n\n          if (!cursor) {\n            resolve(null);\n            return;\n          }\n\n          cursor.___id = ++_id_counter;\n          cursor.done = false;\n\n          var _cursorContinue = cursor.continue.bind(cursor);\n\n          var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n\n          var _cursorAdvance = cursor.advance.bind(cursor);\n\n          var doThrowCursorIsNotStarted = function doThrowCursorIsNotStarted() {\n            throw new Error(\"Cursor not started\");\n          };\n\n          var doThrowCursorIsStopped = function doThrowCursorIsStopped() {\n            throw new Error(\"Cursor not stopped\");\n          };\n\n          cursor.trans = trans;\n          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n          cursor.fail = wrap(reject);\n\n          cursor.next = function () {\n            var _this21 = this;\n\n            var gotOne = 1;\n            return this.start(function () {\n              return gotOne-- ? _this21.continue() : _this21.stop();\n            }).then(function () {\n              return _this21;\n            });\n          };\n\n          cursor.start = function (callback) {\n            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n              resolveIteration = wrap(resolveIteration);\n              req.onerror = eventRejectHandler(rejectIteration);\n              cursor.fail = rejectIteration;\n\n              cursor.stop = function (value) {\n                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                resolveIteration(value);\n              };\n            });\n\n            var guardedCallback = function guardedCallback() {\n              if (req.result) {\n                try {\n                  callback();\n                } catch (err) {\n                  cursor.fail(err);\n                }\n              } else {\n                cursor.done = true;\n\n                cursor.start = function () {\n                  throw new Error(\"Cursor behind last entry\");\n                };\n\n                cursor.stop();\n              }\n            };\n\n            req.onsuccess = wrap(function (ev) {\n              req.onsuccess = guardedCallback;\n              guardedCallback();\n            });\n            cursor.continue = _cursorContinue;\n            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n            cursor.advance = _cursorAdvance;\n            guardedCallback();\n            return iterationPromise;\n          };\n\n          resolve(cursor);\n        }, reject);\n      });\n    }\n\n    function query(hasGetAll) {\n      return function (request) {\n        return new Promise(function (resolve, reject) {\n          resolve = wrap(resolve);\n          var trans = request.trans,\n              values = request.values,\n              limit = request.limit,\n              query = request.query;\n          var nonInfinitLimit = limit === Infinity ? undefined : limit;\n          var index = query.index,\n              range = query.range;\n          var store = trans.objectStore(tableName);\n          var source = index.isPrimaryKey ? store : store.index(index.name);\n          var idbKeyRange = makeIDBKeyRange(range);\n          if (limit === 0) return resolve({\n            result: []\n          });\n\n          if (hasGetAll) {\n            var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n\n            req.onsuccess = function (event) {\n              return resolve({\n                result: event.target.result\n              });\n            };\n\n            req.onerror = eventRejectHandler(reject);\n          } else {\n            var count = 0;\n\n            var _req = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n\n            var result = [];\n\n            _req.onsuccess = function (event) {\n              var cursor = _req.result;\n              if (!cursor) return resolve({\n                result: result\n              });\n              result.push(values ? cursor.value : cursor.primaryKey);\n              if (++count === limit) return resolve({\n                result: result\n              });\n              cursor.continue();\n            };\n\n            _req.onerror = eventRejectHandler(reject);\n          }\n        });\n      };\n    }\n\n    return {\n      name: tableName,\n      schema: tableSchema,\n      mutate: mutate,\n      getMany: function getMany(_ref17) {\n        var trans = _ref17.trans,\n            keys = _ref17.keys;\n        return new Promise(function (resolve, reject) {\n          resolve = wrap(resolve);\n          var store = trans.objectStore(tableName);\n          var length = keys.length;\n          var result = new Array(length);\n          var keyCount = 0;\n          var callbackCount = 0;\n          var req;\n\n          var successHandler = function successHandler(event) {\n            var req = event.target;\n            if ((result[req._pos] = req.result) != null) ;\n            if (++callbackCount === keyCount) resolve(result);\n          };\n\n          var errorHandler = eventRejectHandler(reject);\n\n          for (var i = 0; i < length; ++i) {\n            var key = keys[i];\n\n            if (key != null) {\n              req = store.get(keys[i]);\n              req._pos = i;\n              req.onsuccess = successHandler;\n              req.onerror = errorHandler;\n              ++keyCount;\n            }\n          }\n\n          if (keyCount === 0) resolve(result);\n        });\n      },\n      get: function get(_ref18) {\n        var trans = _ref18.trans,\n            key = _ref18.key;\n        return new Promise(function (resolve, reject) {\n          resolve = wrap(resolve);\n          var store = trans.objectStore(tableName);\n          var req = store.get(key);\n\n          req.onsuccess = function (event) {\n            return resolve(event.target.result);\n          };\n\n          req.onerror = eventRejectHandler(reject);\n        });\n      },\n      query: query(hasGetAll),\n      openCursor: openCursor,\n      count: function count(_ref19) {\n        var query = _ref19.query,\n            trans = _ref19.trans;\n        var index = query.index,\n            range = query.range;\n        return new Promise(function (resolve, reject) {\n          var store = trans.objectStore(tableName);\n          var source = index.isPrimaryKey ? store : store.index(index.name);\n          var idbKeyRange = makeIDBKeyRange(range);\n          var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n          req.onsuccess = wrap(function (ev) {\n            return resolve(ev.target.result);\n          });\n          req.onerror = eventRejectHandler(reject);\n        });\n      }\n    };\n  }\n\n  var _extractSchema = extractSchema(db, tmpTrans),\n      schema = _extractSchema.schema,\n      hasGetAll = _extractSchema.hasGetAll;\n\n  var tables = schema.tables.map(function (tableSchema) {\n    return createDbCoreTable(tableSchema);\n  });\n  var tableMap = {};\n  tables.forEach(function (table) {\n    return tableMap[table.name] = table;\n  });\n  return {\n    stack: \"dbcore\",\n    transaction: db.transaction.bind(db),\n    table: function table(name) {\n      var result = tableMap[name];\n      if (!result) throw new Error(\"Table '\".concat(name, \"' not found\"));\n      return tableMap[name];\n    },\n    MIN_KEY: -Infinity,\n    MAX_KEY: _getMaxKey(IdbKeyRange),\n    schema: schema\n  };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n  return middlewares.reduce(function (down, _ref20) {\n    var create = _ref20.create;\n    return _objectSpread(_objectSpread({}, down), create(down));\n  }, stackImpl);\n}\n\nfunction createMiddlewareStacks(middlewares, idbdb, _ref21, tmpTrans) {\n  var IDBKeyRange = _ref21.IDBKeyRange,\n      indexedDB = _ref21.indexedDB;\n  var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n  return {\n    dbcore: dbcore\n  };\n}\n\nfunction generateMiddlewareStacks(_ref22, tmpTrans) {\n  var db = _ref22._novip;\n  var idbdb = tmpTrans.db;\n  var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n  db.core = stacks.dbcore;\n  db.tables.forEach(function (table) {\n    var tableName = table.name;\n\n    if (db.core.schema.tables.some(function (tbl) {\n      return tbl.name === tableName;\n    })) {\n      table.core = db.core.table(tableName);\n\n      if (db[tableName] instanceof db.Table) {\n        db[tableName].core = table.core;\n      }\n    }\n  });\n}\n\nfunction setApiOnPlace(_ref23, objs, tableNames, dbschema) {\n  var db = _ref23._novip;\n  tableNames.forEach(function (tableName) {\n    var schema = dbschema[tableName];\n    objs.forEach(function (obj) {\n      var propDesc = getPropertyDescriptor(obj, tableName);\n\n      if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n          setProp(obj, tableName, {\n            get: function get() {\n              return this.table(tableName);\n            },\n            set: function set(value) {\n              defineProperty(this, tableName, {\n                value: value,\n                writable: true,\n                configurable: true,\n                enumerable: true\n              });\n            }\n          });\n        } else {\n          obj[tableName] = new db.Table(tableName, schema);\n        }\n      }\n    });\n  });\n}\n\nfunction removeTablesApi(_ref24, objs) {\n  var db = _ref24._novip;\n  objs.forEach(function (obj) {\n    for (var key in obj) {\n      if (obj[key] instanceof db.Table) delete obj[key];\n    }\n  });\n}\n\nfunction lowerVersionFirst(a, b) {\n  return a._cfg.version - b._cfg.version;\n}\n\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n  var globalSchema = db._dbSchema;\n\n  var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n\n  trans.create(idbUpgradeTrans);\n\n  trans._completion.catch(reject);\n\n  var rejectTransaction = trans._reject.bind(trans);\n\n  var transless = PSD.transless || PSD;\n  newScope(function () {\n    PSD.trans = trans;\n    PSD.transless = transless;\n\n    if (oldVersion === 0) {\n      keys(globalSchema).forEach(function (tableName) {\n        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n      });\n      generateMiddlewareStacks(db, idbUpgradeTrans);\n      DexiePromise.follow(function () {\n        return db.on.populate.fire(trans);\n      }).catch(rejectTransaction);\n    } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n  });\n}\n\nfunction updateTablesAndIndexes(_ref25, oldVersion, trans, idbUpgradeTrans) {\n  var db = _ref25._novip;\n  var queue = [];\n  var versions = db._versions;\n  var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n  var anyContentUpgraderHasRun = false;\n  var versToRun = versions.filter(function (v) {\n    return v._cfg.version >= oldVersion;\n  });\n  versToRun.forEach(function (version) {\n    queue.push(function () {\n      var oldSchema = globalSchema;\n      var newSchema = version._cfg.dbschema;\n      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n      globalSchema = db._dbSchema = newSchema;\n      var diff = getSchemaDiff(oldSchema, newSchema);\n      diff.add.forEach(function (tuple) {\n        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n      });\n      diff.change.forEach(function (change) {\n        if (change.recreate) {\n          throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n        } else {\n          var store = idbUpgradeTrans.objectStore(change.name);\n          change.add.forEach(function (idx) {\n            return addIndex(store, idx);\n          });\n          change.change.forEach(function (idx) {\n            store.deleteIndex(idx.name);\n            addIndex(store, idx);\n          });\n          change.del.forEach(function (idxName) {\n            return store.deleteIndex(idxName);\n          });\n        }\n      });\n      var contentUpgrade = version._cfg.contentUpgrade;\n\n      if (contentUpgrade && version._cfg.version > oldVersion) {\n        generateMiddlewareStacks(db, idbUpgradeTrans);\n        trans._memoizedTables = {};\n        anyContentUpgraderHasRun = true;\n        var upgradeSchema = shallowClone(newSchema);\n        diff.del.forEach(function (table) {\n          upgradeSchema[table] = oldSchema[table];\n        });\n        removeTablesApi(db, [db.Transaction.prototype]);\n        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n        trans.schema = upgradeSchema;\n        var contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n\n        if (contentUpgradeIsAsync) {\n          incrementExpectedAwaits();\n        }\n\n        var returnValue;\n        var promiseFollowed = DexiePromise.follow(function () {\n          returnValue = contentUpgrade(trans);\n\n          if (returnValue) {\n            if (contentUpgradeIsAsync) {\n              var decrementor = decrementExpectedAwaits.bind(null, null);\n              returnValue.then(decrementor, decrementor);\n            }\n          }\n        });\n        return returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue) : promiseFollowed.then(function () {\n          return returnValue;\n        });\n      }\n    });\n    queue.push(function (idbtrans) {\n      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n        var newSchema = version._cfg.dbschema;\n        deleteRemovedTables(newSchema, idbtrans);\n      }\n\n      removeTablesApi(db, [db.Transaction.prototype]);\n      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n      trans.schema = db._dbSchema;\n    });\n  });\n\n  function runQueue() {\n    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n  }\n\n  return runQueue().then(function () {\n    createMissingTables(globalSchema, idbUpgradeTrans);\n  });\n}\n\nfunction getSchemaDiff(oldSchema, newSchema) {\n  var diff = {\n    del: [],\n    add: [],\n    change: []\n  };\n  var table;\n\n  for (table in oldSchema) {\n    if (!newSchema[table]) diff.del.push(table);\n  }\n\n  for (table in newSchema) {\n    var oldDef = oldSchema[table],\n        newDef = newSchema[table];\n\n    if (!oldDef) {\n      diff.add.push([table, newDef]);\n    } else {\n      var change = {\n        name: table,\n        def: newDef,\n        recreate: false,\n        del: [],\n        add: [],\n        change: []\n      };\n\n      if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n        change.recreate = true;\n        diff.change.push(change);\n      } else {\n        var oldIndexes = oldDef.idxByName;\n        var newIndexes = newDef.idxByName;\n        var idxName = void 0;\n\n        for (idxName in oldIndexes) {\n          if (!newIndexes[idxName]) change.del.push(idxName);\n        }\n\n        for (idxName in newIndexes) {\n          var oldIdx = oldIndexes[idxName],\n              newIdx = newIndexes[idxName];\n          if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n        }\n\n        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n          diff.change.push(change);\n        }\n      }\n    }\n  }\n\n  return diff;\n}\n\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n  var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n    keyPath: primKey.keyPath,\n    autoIncrement: primKey.auto\n  } : {\n    autoIncrement: primKey.auto\n  });\n  indexes.forEach(function (idx) {\n    return addIndex(store, idx);\n  });\n  return store;\n}\n\nfunction createMissingTables(newSchema, idbtrans) {\n  keys(newSchema).forEach(function (tableName) {\n    if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n    }\n  });\n}\n\nfunction deleteRemovedTables(newSchema, idbtrans) {\n  [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n    return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n  });\n}\n\nfunction addIndex(store, idx) {\n  store.createIndex(idx.name, idx.keyPath, {\n    unique: idx.unique,\n    multiEntry: idx.multi\n  });\n}\n\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n  var globalSchema = {};\n  var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n  dbStoreNames.forEach(function (storeName) {\n    var store = tmpTrans.objectStore(storeName);\n    var keyPath = store.keyPath;\n    var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n    var indexes = [];\n\n    for (var j = 0; j < store.indexNames.length; ++j) {\n      var idbindex = store.index(store.indexNames[j]);\n      keyPath = idbindex.keyPath;\n      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n      indexes.push(index);\n    }\n\n    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n  });\n  return globalSchema;\n}\n\nfunction readGlobalSchema(_ref26, idbdb, tmpTrans) {\n  var db = _ref26._novip;\n  db.verno = idbdb.version / 10;\n  var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n  db._storeNames = slice(idbdb.objectStoreNames, 0);\n  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\n\nfunction verifyInstalledSchema(db, tmpTrans) {\n  var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n  var diff = getSchemaDiff(installedSchema, db._dbSchema);\n  return !(diff.add.length || diff.change.some(function (ch) {\n    return ch.add.length || ch.change.length;\n  }));\n}\n\nfunction adjustToExistingIndexNames(_ref27, schema, idbtrans) {\n  var db = _ref27._novip;\n  var storeNames = idbtrans.db.objectStoreNames;\n\n  for (var i = 0; i < storeNames.length; ++i) {\n    var storeName = storeNames[i];\n    var store = idbtrans.objectStore(storeName);\n    db._hasGetAll = 'getAll' in store;\n\n    for (var j = 0; j < store.indexNames.length; ++j) {\n      var indexName = store.indexNames[j];\n      var keyPath = store.index(indexName).keyPath;\n      var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n\n      if (schema[storeName]) {\n        var indexSpec = schema[storeName].idxByName[dexieName];\n\n        if (indexSpec) {\n          indexSpec.name = indexName;\n          delete schema[storeName].idxByName[dexieName];\n          schema[storeName].idxByName[indexName] = indexSpec;\n        }\n      }\n    }\n  }\n\n  if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n    db._hasGetAll = false;\n  }\n}\n\nfunction parseIndexSyntax(primKeyAndIndexes) {\n  return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n    index = index.trim();\n    var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n    var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n    return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n  });\n}\n\nvar Version = /*#__PURE__*/function () {\n  function Version() {\n    _classCallCheck(this, Version);\n  }\n\n  _createClass(Version, [{\n    key: \"_parseStoresSpec\",\n    value: function _parseStoresSpec(stores, outSchema) {\n      keys(stores).forEach(function (tableName) {\n        if (stores[tableName] !== null) {\n          var indexes = parseIndexSyntax(stores[tableName]);\n          var primKey = indexes.shift();\n          if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n          indexes.forEach(function (idx) {\n            if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n            if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n          });\n          outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n        }\n      });\n    }\n  }, {\n    key: \"stores\",\n    value: function stores(_stores) {\n      var db = this.db;\n      this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, _stores) : _stores;\n      var versions = db._versions;\n      var storesSpec = {};\n      var dbschema = {};\n      versions.forEach(function (version) {\n        extend(storesSpec, version._cfg.storesSource);\n        dbschema = version._cfg.dbschema = {};\n\n        version._parseStoresSpec(storesSpec, dbschema);\n      });\n      db._dbSchema = dbschema;\n      removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n      setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n      db._storeNames = keys(dbschema);\n      return this;\n    }\n  }, {\n    key: \"upgrade\",\n    value: function upgrade(upgradeFunction) {\n      this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n      return this;\n    }\n  }]);\n\n  return Version;\n}();\n\nfunction createVersionConstructor(db) {\n  return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n    this.db = db;\n    this._cfg = {\n      version: versionNumber,\n      storesSource: null,\n      dbschema: {},\n      tables: {},\n      contentUpgrade: null\n    };\n  });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n  var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n\n  if (!dbNamesDB) {\n    dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n      addons: [],\n      indexedDB: indexedDB,\n      IDBKeyRange: IDBKeyRange\n    });\n    dbNamesDB.version(1).stores({\n      dbnames: \"name\"\n    });\n  }\n\n  return dbNamesDB.table(\"dbnames\");\n}\n\nfunction hasDatabasesNative(indexedDB) {\n  return indexedDB && typeof indexedDB.databases === \"function\";\n}\n\nfunction _getDatabaseNames(_ref28) {\n  var indexedDB = _ref28.indexedDB,\n      IDBKeyRange = _ref28.IDBKeyRange;\n  return hasDatabasesNative(indexedDB) ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n    return infos.map(function (info) {\n      return info.name;\n    }).filter(function (name) {\n      return name !== DBNAMES_DB;\n    });\n  }) : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\n\nfunction _onDatabaseCreated(_ref29, name) {\n  var indexedDB = _ref29.indexedDB,\n      IDBKeyRange = _ref29.IDBKeyRange;\n  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).put({\n    name: name\n  }).catch(nop);\n}\n\nfunction _onDatabaseDeleted(_ref30, name) {\n  var indexedDB = _ref30.indexedDB,\n      IDBKeyRange = _ref30.IDBKeyRange;\n  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n  return newScope(function () {\n    PSD.letThrough = true;\n    return fn();\n  });\n}\n\nfunction idbReady() {\n  var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n  var intervalId;\n  return new Promise(function (resolve) {\n    var tryIdb = function tryIdb() {\n      return indexedDB.databases().finally(resolve);\n    };\n\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(function () {\n    return clearInterval(intervalId);\n  });\n}\n\nfunction dexieOpen(db) {\n  var state = db._state;\n  var indexedDB = db._deps.indexedDB;\n  if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(function () {\n    return state.dbOpenError ? rejection(state.dbOpenError) : db;\n  });\n  debug && (state.openCanceller._stackHolder = getErrorWithStack());\n  state.isBeingOpened = true;\n  state.dbOpenError = null;\n  state.openComplete = false;\n  var openCanceller = state.openCanceller;\n\n  function throwIfCancelled() {\n    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');\n  }\n\n  var resolveDbReady = state.dbReadyResolve,\n      upgradeTransaction = null,\n      wasCreated = false;\n  return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(function () {\n    return new DexiePromise(function (resolve, reject) {\n      throwIfCancelled();\n      if (!indexedDB) throw new exceptions.MissingAPI();\n      var dbName = db.name;\n      var req = state.autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\n      if (!req) throw new exceptions.MissingAPI();\n      req.onerror = eventRejectHandler(reject);\n      req.onblocked = wrap(db._fireOnBlocked);\n      req.onupgradeneeded = wrap(function (e) {\n        upgradeTransaction = req.transaction;\n\n        if (state.autoSchema && !db._options.allowEmptyDB) {\n          req.onerror = preventDefault;\n          upgradeTransaction.abort();\n          req.result.close();\n          var delreq = indexedDB.deleteDatabase(dbName);\n          delreq.onsuccess = delreq.onerror = wrap(function () {\n            reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n          });\n        } else {\n          upgradeTransaction.onerror = eventRejectHandler(reject);\n          var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n          wasCreated = oldVer < 1;\n          db._novip.idbdb = req.result;\n          runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n        }\n      }, reject);\n      req.onsuccess = wrap(function () {\n        upgradeTransaction = null;\n        var idbdb = db._novip.idbdb = req.result;\n        var objectStoreNames = slice(idbdb.objectStoreNames);\n        if (objectStoreNames.length > 0) try {\n          var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n          if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {\n            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n\n            if (!verifyInstalledSchema(db, tmpTrans)) {\n              console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\");\n            }\n          }\n          generateMiddlewareStacks(db, tmpTrans);\n        } catch (e) {}\n        connections.push(db);\n        idbdb.onversionchange = wrap(function (ev) {\n          state.vcFired = true;\n          db.on(\"versionchange\").fire(ev);\n        });\n        idbdb.onclose = wrap(function (ev) {\n          db.on(\"close\").fire(ev);\n        });\n        if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n        resolve();\n      }, reject);\n    });\n  })]).then(function () {\n    throwIfCancelled();\n    state.onReadyBeingFired = [];\n    return DexiePromise.resolve(vip(function () {\n      return db.on.ready.fire(db.vip);\n    })).then(function fireRemainders() {\n      if (state.onReadyBeingFired.length > 0) {\n        var remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(function () {\n          return remainders(db.vip);\n        })).then(fireRemainders);\n      }\n    });\n  }).finally(function () {\n    state.onReadyBeingFired = null;\n    state.isBeingOpened = false;\n  }).then(function () {\n    return db;\n  }).catch(function (err) {\n    state.dbOpenError = err;\n\n    try {\n      upgradeTransaction && upgradeTransaction.abort();\n    } catch (_a) {}\n\n    if (openCanceller === state.openCanceller) {\n      db._close();\n    }\n\n    return rejection(err);\n  }).finally(function () {\n    state.openComplete = true;\n    resolveDbReady();\n  });\n}\n\nfunction awaitIterator(iterator) {\n  var callNext = function callNext(result) {\n    return iterator.next(result);\n  },\n      doThrow = function doThrow(error) {\n    return iterator.throw(error);\n  },\n      onSuccess = step(callNext),\n      onError = step(doThrow);\n\n  function step(getNext) {\n    return function (val) {\n      var next = getNext(val),\n          value = next.value;\n      return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n    };\n  }\n\n  return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n  var i = arguments.length;\n  if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n  var args = new Array(i - 1);\n\n  while (--i) {\n    args[i - 1] = arguments[i];\n  }\n\n  scopeFunc = args.pop();\n  var tables = flatten(args);\n  return [mode, tables, scopeFunc];\n}\n\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n  return DexiePromise.resolve().then(function () {\n    var transless = PSD.transless || PSD;\n\n    var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n\n    var zoneProps = {\n      trans: trans,\n      transless: transless\n    };\n\n    if (parentTransaction) {\n      trans.idbtrans = parentTransaction.idbtrans;\n    } else {\n      try {\n        trans.create();\n        db._state.PR1398_maxLoop = 3;\n      } catch (ex) {\n        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n          console.warn('Dexie: Need to reopen db');\n\n          db._close();\n\n          return db.open().then(function () {\n            return enterTransactionScope(db, mode, storeNames, null, scopeFunc);\n          });\n        }\n\n        return rejection(ex);\n      }\n    }\n\n    var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n\n    if (scopeFuncIsAsync) {\n      incrementExpectedAwaits();\n    }\n\n    var returnValue;\n    var promiseFollowed = DexiePromise.follow(function () {\n      returnValue = scopeFunc.call(trans, trans);\n\n      if (returnValue) {\n        if (scopeFuncIsAsync) {\n          var decrementor = decrementExpectedAwaits.bind(null, null);\n          returnValue.then(decrementor, decrementor);\n        } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n          returnValue = awaitIterator(returnValue);\n        }\n      }\n    }, zoneProps);\n    return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(function (x) {\n      return trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"));\n    }) : promiseFollowed.then(function () {\n      return returnValue;\n    })).then(function (x) {\n      if (parentTransaction) trans._resolve();\n      return trans._completion.then(function () {\n        return x;\n      });\n    }).catch(function (e) {\n      trans._reject(e);\n\n      return rejection(e);\n    });\n  });\n}\n\nfunction pad(a, value, count) {\n  var result = isArray(a) ? a.slice() : [a];\n\n  for (var i = 0; i < count; ++i) {\n    result.push(value);\n  }\n\n  return result;\n}\n\nfunction createVirtualIndexMiddleware(down) {\n  return _objectSpread(_objectSpread({}, down), {}, {\n    table: function table(tableName) {\n      var table = down.table(tableName);\n      var schema = table.schema;\n      var indexLookup = {};\n      var allVirtualIndexes = [];\n\n      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n        var keyPathAlias = getKeyPathAlias(keyPath);\n        var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n        var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n        var isVirtual = keyTail > 0;\n\n        var virtualIndex = _objectSpread(_objectSpread({}, lowLevelIndex), {}, {\n          isVirtual: isVirtual,\n          keyTail: keyTail,\n          keyLength: keyLength,\n          extractKey: getKeyExtractor(keyPath),\n          unique: !isVirtual && lowLevelIndex.unique\n        });\n\n        indexList.push(virtualIndex);\n\n        if (!virtualIndex.isPrimaryKey) {\n          allVirtualIndexes.push(virtualIndex);\n        }\n\n        if (keyLength > 1) {\n          var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n        }\n\n        indexList.sort(function (a, b) {\n          return a.keyTail - b.keyTail;\n        });\n        return virtualIndex;\n      }\n\n      var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n      indexLookup[\":id\"] = [primaryKey];\n\n      var _iterator2 = _createForOfIteratorHelper(schema.indexes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var index = _step2.value;\n          addVirtualIndexes(index.keyPath, 0, index);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      function findBestIndex(keyPath) {\n        var result = indexLookup[getKeyPathAlias(keyPath)];\n        return result && result[0];\n      }\n\n      function translateRange(range, keyTail) {\n        return {\n          type: range.type === 1 ? 2 : range.type,\n          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n          lowerOpen: true,\n          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n          upperOpen: true\n        };\n      }\n\n      function translateRequest(req) {\n        var index = req.query.index;\n        return index.isVirtual ? _objectSpread(_objectSpread({}, req), {}, {\n          query: {\n            index: index,\n            range: translateRange(req.query.range, index.keyTail)\n          }\n        }) : req;\n      }\n\n      var result = _objectSpread(_objectSpread({}, table), {}, {\n        schema: _objectSpread(_objectSpread({}, schema), {}, {\n          primaryKey: primaryKey,\n          indexes: allVirtualIndexes,\n          getIndexByKeyPath: findBestIndex\n        }),\n        count: function count(req) {\n          return table.count(translateRequest(req));\n        },\n        query: function query(req) {\n          return table.query(translateRequest(req));\n        },\n        openCursor: function openCursor(req) {\n          var _req$query$index = req.query.index,\n              keyTail = _req$query$index.keyTail,\n              isVirtual = _req$query$index.isVirtual,\n              keyLength = _req$query$index.keyLength;\n          if (!isVirtual) return table.openCursor(req);\n\n          function createVirtualCursor(cursor) {\n            function _continue(key) {\n              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n            }\n\n            var virtualCursor = Object.create(cursor, {\n              continue: {\n                value: _continue\n              },\n              continuePrimaryKey: {\n                value: function value(key, primaryKey) {\n                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                }\n              },\n              primaryKey: {\n                get: function get() {\n                  return cursor.primaryKey;\n                }\n              },\n              key: {\n                get: function get() {\n                  var key = cursor.key;\n                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                }\n              },\n              value: {\n                get: function get() {\n                  return cursor.value;\n                }\n              }\n            });\n            return virtualCursor;\n          }\n\n          return table.openCursor(translateRequest(req)).then(function (cursor) {\n            return cursor && createVirtualCursor(cursor);\n          });\n        }\n      });\n\n      return result;\n    }\n  });\n}\n\nvar virtualIndexMiddleware = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n  rv = rv || {};\n  prfx = prfx || '';\n  keys(a).forEach(function (prop) {\n    if (!hasOwn(b, prop)) {\n      rv[prfx + prop] = undefined;\n    } else {\n      var ap = a[prop],\n          bp = b[prop];\n\n      if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n        var apTypeName = toStringTag(ap);\n        var bpTypeName = toStringTag(bp);\n\n        if (apTypeName !== bpTypeName) {\n          rv[prfx + prop] = b[prop];\n        } else if (apTypeName === 'Object') {\n          getObjectDiff(ap, bp, rv, prfx + prop + '.');\n        } else if (ap !== bp) {\n          rv[prfx + prop] = b[prop];\n        }\n      } else if (ap !== bp) rv[prfx + prop] = b[prop];\n    }\n  });\n  keys(b).forEach(function (prop) {\n    if (!hasOwn(a, prop)) {\n      rv[prfx + prop] = b[prop];\n    }\n  });\n  return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n  if (req.type === 'delete') return req.keys;\n  return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nvar hooksMiddleware = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: function create(downCore) {\n    return _objectSpread(_objectSpread({}, downCore), {}, {\n      table: function table(tableName) {\n        var downTable = downCore.table(tableName);\n        var primaryKey = downTable.schema.primaryKey;\n\n        var tableMiddleware = _objectSpread(_objectSpread({}, downTable), {}, {\n          mutate: function mutate(req) {\n            var dxTrans = PSD.trans;\n            var _dxTrans$table$hook = dxTrans.table(tableName).hook,\n                deleting = _dxTrans$table$hook.deleting,\n                creating = _dxTrans$table$hook.creating,\n                updating = _dxTrans$table$hook.updating;\n\n            switch (req.type) {\n              case 'add':\n                if (creating.fire === nop) break;\n                return dxTrans._promise('readwrite', function () {\n                  return addPutOrDelete(req);\n                }, true);\n\n              case 'put':\n                if (creating.fire === nop && updating.fire === nop) break;\n                return dxTrans._promise('readwrite', function () {\n                  return addPutOrDelete(req);\n                }, true);\n\n              case 'delete':\n                if (deleting.fire === nop) break;\n                return dxTrans._promise('readwrite', function () {\n                  return addPutOrDelete(req);\n                }, true);\n\n              case 'deleteRange':\n                if (deleting.fire === nop) break;\n                return dxTrans._promise('readwrite', function () {\n                  return deleteRange(req);\n                }, true);\n            }\n\n            return downTable.mutate(req);\n\n            function addPutOrDelete(req) {\n              var dxTrans = PSD.trans;\n              var keys = req.keys || getEffectiveKeys(primaryKey, req);\n              if (!keys) throw new Error(\"Keys missing\");\n              req = req.type === 'add' || req.type === 'put' ? _objectSpread(_objectSpread({}, req), {}, {\n                keys: keys\n              }) : _objectSpread({}, req);\n              if (req.type !== 'delete') req.values = _toConsumableArray(req.values);\n              if (req.keys) req.keys = _toConsumableArray(req.keys);\n              return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                var contexts = keys.map(function (key, i) {\n                  var existingValue = existingValues[i];\n                  var ctx = {\n                    onerror: null,\n                    onsuccess: null\n                  };\n\n                  if (req.type === 'delete') {\n                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                  } else if (req.type === 'add' || existingValue === undefined) {\n                    var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n\n                    if (key == null && generatedPrimaryKey != null) {\n                      key = generatedPrimaryKey;\n                      req.keys[i] = key;\n\n                      if (!primaryKey.outbound) {\n                        setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                      }\n                    }\n                  } else {\n                    var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                    var additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n\n                    if (additionalChanges) {\n                      var requestedValue = req.values[i];\n                      Object.keys(additionalChanges).forEach(function (keyPath) {\n                        if (hasOwn(requestedValue, keyPath)) {\n                          requestedValue[keyPath] = additionalChanges[keyPath];\n                        } else {\n                          setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                        }\n                      });\n                    }\n                  }\n\n                  return ctx;\n                });\n                return downTable.mutate(req).then(function (_ref31) {\n                  var failures = _ref31.failures,\n                      results = _ref31.results,\n                      numFailures = _ref31.numFailures,\n                      lastResult = _ref31.lastResult;\n\n                  for (var i = 0; i < keys.length; ++i) {\n                    var primKey = results ? results[i] : keys[i];\n                    var ctx = contexts[i];\n\n                    if (primKey == null) {\n                      ctx.onerror && ctx.onerror(failures[i]);\n                    } else {\n                      ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);\n                    }\n                  }\n\n                  return {\n                    failures: failures,\n                    results: results,\n                    numFailures: numFailures,\n                    lastResult: lastResult\n                  };\n                }).catch(function (error) {\n                  contexts.forEach(function (ctx) {\n                    return ctx.onerror && ctx.onerror(error);\n                  });\n                  return Promise.reject(error);\n                });\n              });\n            }\n\n            function deleteRange(req) {\n              return deleteNextChunk(req.trans, req.range, 10000);\n            }\n\n            function deleteNextChunk(trans, range, limit) {\n              return downTable.query({\n                trans: trans,\n                values: false,\n                query: {\n                  index: primaryKey,\n                  range: range\n                },\n                limit: limit\n              }).then(function (_ref32) {\n                var result = _ref32.result;\n                return addPutOrDelete({\n                  type: 'delete',\n                  keys: result,\n                  trans: trans\n                }).then(function (res) {\n                  if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n\n                  if (result.length < limit) {\n                    return {\n                      failures: [],\n                      numFailures: 0,\n                      lastResult: undefined\n                    };\n                  } else {\n                    return deleteNextChunk(trans, _objectSpread(_objectSpread({}, range), {}, {\n                      lower: result[result.length - 1],\n                      lowerOpen: true\n                    }), limit);\n                  }\n                });\n              });\n            }\n          }\n        });\n\n        return tableMiddleware;\n      }\n    });\n  }\n};\n\nfunction getExistingValues(table, req, effectiveKeys) {\n  return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n    trans: req.trans,\n    keys: effectiveKeys,\n    cache: \"immutable\"\n  });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n  try {\n    if (!cache) return null;\n    if (cache.keys.length < keys.length) return null;\n    var result = [];\n\n    for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n      if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n      ++j;\n    }\n\n    return result.length === keys.length ? result : null;\n  } catch (_a) {\n    return null;\n  }\n}\n\nvar cacheExistingValuesMiddleware = {\n  stack: \"dbcore\",\n  level: -1,\n  create: function create(core) {\n    return {\n      table: function table(tableName) {\n        var table = core.table(tableName);\n        return _objectSpread(_objectSpread({}, table), {}, {\n          getMany: function getMany(req) {\n            if (!req.cache) {\n              return table.getMany(req);\n            }\n\n            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n\n            if (cachedResult) {\n              return DexiePromise.resolve(cachedResult);\n            }\n\n            return table.getMany(req).then(function (res) {\n              req.trans[\"_cache\"] = {\n                keys: req.keys,\n                values: req.cache === \"clone\" ? deepClone(res) : res\n              };\n              return res;\n            });\n          },\n          mutate: function mutate(req) {\n            if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n            return table.mutate(req);\n          }\n        });\n      }\n    };\n  }\n};\n\nfunction isEmptyRange(node) {\n  return !(\"from\" in node);\n}\n\nvar RangeSet = function RangeSet(fromOrTree, to) {\n  if (this) {\n    extend(this, arguments.length ? {\n      d: 1,\n      from: fromOrTree,\n      to: arguments.length > 1 ? to : fromOrTree\n    } : {\n      d: 0\n    });\n  } else {\n    var rv = new RangeSet();\n\n    if (fromOrTree && \"d\" in fromOrTree) {\n      extend(rv, fromOrTree);\n    }\n\n    return rv;\n  }\n};\n\nprops(RangeSet.prototype, _defineProperty({\n  add: function add(rangeSet) {\n    mergeRanges(this, rangeSet);\n    return this;\n  },\n  addKey: function addKey(key) {\n    addRange(this, key, key);\n    return this;\n  },\n  addKeys: function addKeys(keys) {\n    var _this22 = this;\n\n    keys.forEach(function (key) {\n      return addRange(_this22, key, key);\n    });\n    return this;\n  }\n}, iteratorSymbol, function () {\n  return getRangeSetIterator(this);\n}));\n\nfunction addRange(target, from, to) {\n  var diff = cmp(from, to);\n  if (isNaN(diff)) return;\n  if (diff > 0) throw RangeError();\n  if (isEmptyRange(target)) return extend(target, {\n    from: from,\n    to: to,\n    d: 1\n  });\n  var left = target.l;\n  var right = target.r;\n\n  if (cmp(to, target.from) < 0) {\n    left ? addRange(left, from, to) : target.l = {\n      from: from,\n      to: to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n\n  if (cmp(from, target.to) > 0) {\n    right ? addRange(right, from, to) : target.r = {\n      from: from,\n      to: to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n\n  if (cmp(from, target.from) < 0) {\n    target.from = from;\n    target.l = null;\n    target.d = right ? right.d + 1 : 1;\n  }\n\n  if (cmp(to, target.to) > 0) {\n    target.to = to;\n    target.r = null;\n    target.d = target.l ? target.l.d + 1 : 1;\n  }\n\n  var rightWasCutOff = !target.r;\n\n  if (left && !target.l) {\n    mergeRanges(target, left);\n  }\n\n  if (right && rightWasCutOff) {\n    mergeRanges(target, right);\n  }\n}\n\nfunction mergeRanges(target, newSet) {\n  function _addRangeSet(target, _ref33) {\n    var from = _ref33.from,\n        to = _ref33.to,\n        l = _ref33.l,\n        r = _ref33.r;\n    addRange(target, from, to);\n    if (l) _addRangeSet(target, l);\n    if (r) _addRangeSet(target, r);\n  }\n\n  if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\n\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n  var i1 = getRangeSetIterator(rangeSet2);\n  var nextResult1 = i1.next();\n  if (nextResult1.done) return false;\n  var a = nextResult1.value;\n  var i2 = getRangeSetIterator(rangeSet1);\n  var nextResult2 = i2.next(a.from);\n  var b = nextResult2.value;\n\n  while (!nextResult1.done && !nextResult2.done) {\n    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n  }\n\n  return false;\n}\n\nfunction getRangeSetIterator(node) {\n  var state = isEmptyRange(node) ? null : {\n    s: 0,\n    n: node\n  };\n  return {\n    next: function next(key) {\n      var keyProvided = arguments.length > 0;\n\n      while (state) {\n        switch (state.s) {\n          case 0:\n            state.s = 1;\n\n            if (keyProvided) {\n              while (state.n.l && cmp(key, state.n.from) < 0) {\n                state = {\n                  up: state,\n                  n: state.n.l,\n                  s: 1\n                };\n              }\n            } else {\n              while (state.n.l) {\n                state = {\n                  up: state,\n                  n: state.n.l,\n                  s: 1\n                };\n              }\n            }\n\n          case 1:\n            state.s = 2;\n            if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n              value: state.n,\n              done: false\n            };\n\n          case 2:\n            if (state.n.r) {\n              state.s = 3;\n              state = {\n                up: state,\n                n: state.n.r,\n                s: 0\n              };\n              continue;\n            }\n\n          case 3:\n            state = state.up;\n        }\n      }\n\n      return {\n        done: true\n      };\n    }\n  };\n}\n\nfunction rebalance(target) {\n  var _a, _b;\n\n  var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n  var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n\n  if (r) {\n    var l = r === \"r\" ? \"l\" : \"r\";\n\n    var rootClone = _objectSpread({}, target);\n\n    var oldRootRight = target[r];\n    target.from = oldRootRight.from;\n    target.to = oldRootRight.to;\n    target[r] = oldRootRight[r];\n    rootClone[r] = oldRootRight[l];\n    target[l] = rootClone;\n    rootClone.d = computeDepth(rootClone);\n  }\n\n  target.d = computeDepth(target);\n}\n\nfunction computeDepth(_ref34) {\n  var r = _ref34.r,\n      l = _ref34.l;\n  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\n\nvar observabilityMiddleware = {\n  stack: \"dbcore\",\n  level: 0,\n  create: function create(core) {\n    var dbName = core.schema.name;\n    var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n    return _objectSpread(_objectSpread({}, core), {}, {\n      table: function table(tableName) {\n        var table = core.table(tableName);\n        var schema = table.schema;\n        var primaryKey = schema.primaryKey;\n        var extractKey = primaryKey.extractKey,\n            outbound = primaryKey.outbound;\n\n        var tableClone = _objectSpread(_objectSpread({}, table), {}, {\n          mutate: function mutate(req) {\n            var trans = req.trans;\n            var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n\n            var getRangeSet = function getRangeSet(indexName) {\n              var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n            };\n\n            var pkRangeSet = getRangeSet(\"\");\n            var delsRangeSet = getRangeSet(\":dels\");\n            var type = req.type;\n\n            var _ref35 = req.type === \"deleteRange\" ? [req.range] : req.type === \"delete\" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [],\n                _ref36 = _slicedToArray(_ref35, 2),\n                keys = _ref36[0],\n                newObjs = _ref36[1];\n\n            var oldCache = req.trans[\"_cache\"];\n            return table.mutate(req).then(function (res) {\n              if (isArray(keys)) {\n                if (type !== \"delete\") keys = res.results;\n                pkRangeSet.addKeys(keys);\n                var oldObjs = getFromTransactionCache(keys, oldCache);\n\n                if (!oldObjs && type !== \"add\") {\n                  delsRangeSet.addKeys(keys);\n                }\n\n                if (oldObjs || newObjs) {\n                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                }\n              } else if (keys) {\n                var range = {\n                  from: keys.lower,\n                  to: keys.upper\n                };\n                delsRangeSet.add(range);\n                pkRangeSet.add(range);\n              } else {\n                pkRangeSet.add(FULL_RANGE);\n                delsRangeSet.add(FULL_RANGE);\n                schema.indexes.forEach(function (idx) {\n                  return getRangeSet(idx.name).add(FULL_RANGE);\n                });\n              }\n\n              return res;\n            });\n          }\n        });\n\n        var getRange = function getRange(_ref37) {\n          var _ref37$query = _ref37.query,\n              index = _ref37$query.index,\n              range = _ref37$query.range;\n\n          var _a, _b;\n\n          return [index, new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)];\n        };\n\n        var readSubscribers = {\n          get: function get(req) {\n            return [primaryKey, new RangeSet(req.key)];\n          },\n          getMany: function getMany(req) {\n            return [primaryKey, new RangeSet().addKeys(req.keys)];\n          },\n          count: getRange,\n          query: getRange,\n          openCursor: getRange\n        };\n        keys(readSubscribers).forEach(function (method) {\n          tableClone[method] = function (req) {\n            var _PSD = PSD,\n                subscr = _PSD.subscr;\n\n            if (subscr) {\n              var getRangeSet = function getRangeSet(indexName) {\n                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                return subscr[part] || (subscr[part] = new RangeSet());\n              };\n\n              var pkRangeSet = getRangeSet(\"\");\n              var delsRangeSet = getRangeSet(\":dels\");\n\n              var _readSubscribers$meth = readSubscribers[method](req),\n                  _readSubscribers$meth2 = _slicedToArray(_readSubscribers$meth, 2),\n                  queriedIndex = _readSubscribers$meth2[0],\n                  queriedRanges = _readSubscribers$meth2[1];\n\n              getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n\n              if (!queriedIndex.isPrimaryKey) {\n                if (method === \"count\") {\n                  delsRangeSet.add(FULL_RANGE);\n                } else {\n                  var keysPromise = method === \"query\" && outbound && req.values && table.query(_objectSpread(_objectSpread({}, req), {}, {\n                    values: false\n                  }));\n                  return table[method].apply(this, arguments).then(function (res) {\n                    if (method === \"query\") {\n                      if (outbound && req.values) {\n                        return keysPromise.then(function (_ref38) {\n                          var resultingKeys = _ref38.result;\n                          pkRangeSet.addKeys(resultingKeys);\n                          return res;\n                        });\n                      }\n\n                      var pKeys = req.values ? res.result.map(extractKey) : res.result;\n\n                      if (req.values) {\n                        pkRangeSet.addKeys(pKeys);\n                      } else {\n                        delsRangeSet.addKeys(pKeys);\n                      }\n                    } else if (method === \"openCursor\") {\n                      var cursor = res;\n                      var wantValues = req.values;\n                      return cursor && Object.create(cursor, {\n                        key: {\n                          get: function get() {\n                            delsRangeSet.addKey(cursor.primaryKey);\n                            return cursor.key;\n                          }\n                        },\n                        primaryKey: {\n                          get: function get() {\n                            var pkey = cursor.primaryKey;\n                            delsRangeSet.addKey(pkey);\n                            return pkey;\n                          }\n                        },\n                        value: {\n                          get: function get() {\n                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                            return cursor.value;\n                          }\n                        }\n                      });\n                    }\n\n                    return res;\n                  });\n                }\n              }\n            }\n\n            return table[method].apply(this, arguments);\n          };\n        });\n        return tableClone;\n      }\n    });\n  }\n};\n\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n  function addAffectedIndex(ix) {\n    var rangeSet = getRangeSet(ix.name || \"\");\n\n    function extractKey(obj) {\n      return obj != null ? ix.extractKey(obj) : null;\n    }\n\n    var addKeyOrKeys = function addKeyOrKeys(key) {\n      return ix.multiEntry && isArray(key) ? key.forEach(function (key) {\n        return rangeSet.addKey(key);\n      }) : rangeSet.addKey(key);\n    };\n\n    (oldObjs || newObjs).forEach(function (_, i) {\n      var oldKey = oldObjs && extractKey(oldObjs[i]);\n      var newKey = newObjs && extractKey(newObjs[i]);\n\n      if (cmp(oldKey, newKey) !== 0) {\n        if (oldKey != null) addKeyOrKeys(oldKey);\n        if (newKey != null) addKeyOrKeys(newKey);\n      }\n    });\n  }\n\n  schema.indexes.forEach(addAffectedIndex);\n}\n\nvar Dexie$1 = /*#__PURE__*/function () {\n  function Dexie$1(name, options) {\n    var _this23 = this;\n\n    _classCallCheck(this, Dexie$1);\n\n    this._middlewares = {};\n    this.verno = 0;\n    var deps = Dexie$1.dependencies;\n    this._options = options = _objectSpread({\n      addons: Dexie$1.addons,\n      autoOpen: true,\n      indexedDB: deps.indexedDB,\n      IDBKeyRange: deps.IDBKeyRange\n    }, options);\n    this._deps = {\n      indexedDB: options.indexedDB,\n      IDBKeyRange: options.IDBKeyRange\n    };\n    var _options = options,\n        addons = _options.addons;\n    this._dbSchema = {};\n    this._versions = [];\n    this._storeNames = [];\n    this._allTables = {};\n    this.idbdb = null;\n    this._novip = this;\n    var state = {\n      dbOpenError: null,\n      isBeingOpened: false,\n      onReadyBeingFired: null,\n      openComplete: false,\n      dbReadyResolve: nop,\n      dbReadyPromise: null,\n      cancelOpen: nop,\n      openCanceller: null,\n      autoSchema: true,\n      PR1398_maxLoop: 3\n    };\n    state.dbReadyPromise = new DexiePromise(function (resolve) {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise(function (_, reject) {\n      state.cancelOpen = reject;\n    });\n    this._state = state;\n    this.name = name;\n    this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [promisableChain, nop]\n    });\n    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n      return function (subscriber, bSticky) {\n        Dexie$1.vip(function () {\n          var state = _this23._state;\n\n          if (state.openComplete) {\n            if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else if (state.onReadyBeingFired) {\n            state.onReadyBeingFired.push(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else {\n            subscribe(subscriber);\n            var db = _this23;\n            if (!bSticky) subscribe(function unsubscribe() {\n              db.on.ready.unsubscribe(subscriber);\n              db.on.ready.unsubscribe(unsubscribe);\n            });\n          }\n        });\n      };\n    });\n    this.Collection = createCollectionConstructor(this);\n    this.Table = createTableConstructor(this);\n    this.Transaction = createTransactionConstructor(this);\n    this.Version = createVersionConstructor(this);\n    this.WhereClause = createWhereClauseConstructor(this);\n    this.on(\"versionchange\", function (ev) {\n      if (ev.newVersion > 0) console.warn(\"Another connection wants to upgrade database '\".concat(_this23.name, \"'. Closing db now to resume the upgrade.\"));else console.warn(\"Another connection wants to delete database '\".concat(_this23.name, \"'. Closing db now to resume the delete request.\"));\n\n      _this23.close();\n    });\n    this.on(\"blocked\", function (ev) {\n      if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(\"Dexie.delete('\".concat(_this23.name, \"') was blocked\"));else console.warn(\"Upgrade '\".concat(_this23.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n    });\n    this._maxKey = _getMaxKey(options.IDBKeyRange);\n\n    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {\n      return new _this23.Transaction(mode, storeNames, dbschema, _this23._options.chromeTransactionDurability, parentTransaction);\n    };\n\n    this._fireOnBlocked = function (ev) {\n      _this23.on(\"blocked\").fire(ev);\n\n      connections.filter(function (c) {\n        return c.name === _this23.name && c !== _this23 && !c._state.vcFired;\n      }).map(function (c) {\n        return c.on(\"versionchange\").fire(ev);\n      });\n    };\n\n    this.use(virtualIndexMiddleware);\n    this.use(hooksMiddleware);\n    this.use(observabilityMiddleware);\n    this.use(cacheExistingValuesMiddleware);\n    this.vip = Object.create(this, {\n      _vip: {\n        value: true\n      }\n    });\n    addons.forEach(function (addon) {\n      return addon(_this23);\n    });\n  }\n\n  _createClass(Dexie$1, [{\n    key: \"version\",\n    value: function version(versionNumber) {\n      if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(\"Given version is not a positive number\");\n      versionNumber = Math.round(versionNumber * 10) / 10;\n      if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n      this.verno = Math.max(this.verno, versionNumber);\n      var versions = this._versions;\n      var versionInstance = versions.filter(function (v) {\n        return v._cfg.version === versionNumber;\n      })[0];\n      if (versionInstance) return versionInstance;\n      versionInstance = new this.Version(versionNumber);\n      versions.push(versionInstance);\n      versions.sort(lowerVersionFirst);\n      versionInstance.stores({});\n      this._state.autoSchema = false;\n      return versionInstance;\n    }\n  }, {\n    key: \"_whenReady\",\n    value: function _whenReady(fn) {\n      var _this24 = this;\n\n      return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function (resolve, reject) {\n        if (_this24._state.openComplete) {\n          return reject(new exceptions.DatabaseClosed(_this24._state.dbOpenError));\n        }\n\n        if (!_this24._state.isBeingOpened) {\n          if (!_this24._options.autoOpen) {\n            reject(new exceptions.DatabaseClosed());\n            return;\n          }\n\n          _this24.open().catch(nop);\n        }\n\n        _this24._state.dbReadyPromise.then(resolve, reject);\n      }).then(fn);\n    }\n  }, {\n    key: \"use\",\n    value: function use(_ref39) {\n      var stack = _ref39.stack,\n          create = _ref39.create,\n          level = _ref39.level,\n          name = _ref39.name;\n      if (name) this.unuse({\n        stack: stack,\n        name: name\n      });\n      var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n      middlewares.push({\n        stack: stack,\n        create: create,\n        level: level == null ? 10 : level,\n        name: name\n      });\n      middlewares.sort(function (a, b) {\n        return a.level - b.level;\n      });\n      return this;\n    }\n  }, {\n    key: \"unuse\",\n    value: function unuse(_ref40) {\n      var stack = _ref40.stack,\n          name = _ref40.name,\n          create = _ref40.create;\n\n      if (stack && this._middlewares[stack]) {\n        this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n          return create ? mw.create !== create : name ? mw.name !== name : false;\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"open\",\n    value: function open() {\n      return dexieOpen(this);\n    }\n  }, {\n    key: \"_close\",\n    value: function _close() {\n      var state = this._state;\n      var idx = connections.indexOf(this);\n      if (idx >= 0) connections.splice(idx, 1);\n\n      if (this.idbdb) {\n        try {\n          this.idbdb.close();\n        } catch (e) {}\n\n        this._novip.idbdb = null;\n      }\n\n      state.dbReadyPromise = new DexiePromise(function (resolve) {\n        state.dbReadyResolve = resolve;\n      });\n      state.openCanceller = new DexiePromise(function (_, reject) {\n        state.cancelOpen = reject;\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._close();\n\n      var state = this._state;\n      this._options.autoOpen = false;\n      state.dbOpenError = new exceptions.DatabaseClosed();\n      if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _this25 = this;\n\n      var hasArguments = arguments.length > 0;\n      var state = this._state;\n      return new DexiePromise(function (resolve, reject) {\n        var doDelete = function doDelete() {\n          _this25.close();\n\n          var req = _this25._deps.indexedDB.deleteDatabase(_this25.name);\n\n          req.onsuccess = wrap(function () {\n            _onDatabaseDeleted(_this25._deps, _this25.name);\n\n            resolve();\n          });\n          req.onerror = eventRejectHandler(reject);\n          req.onblocked = _this25._fireOnBlocked;\n        };\n\n        if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n\n        if (state.isBeingOpened) {\n          state.dbReadyPromise.then(doDelete);\n        } else {\n          doDelete();\n        }\n      });\n    }\n  }, {\n    key: \"backendDB\",\n    value: function backendDB() {\n      return this.idbdb;\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this.idbdb !== null;\n    }\n  }, {\n    key: \"hasBeenClosed\",\n    value: function hasBeenClosed() {\n      var dbOpenError = this._state.dbOpenError;\n      return dbOpenError && dbOpenError.name === 'DatabaseClosed';\n    }\n  }, {\n    key: \"hasFailed\",\n    value: function hasFailed() {\n      return this._state.dbOpenError !== null;\n    }\n  }, {\n    key: \"dynamicallyOpened\",\n    value: function dynamicallyOpened() {\n      return this._state.autoSchema;\n    }\n  }, {\n    key: \"tables\",\n    get: function get() {\n      var _this26 = this;\n\n      return keys(this._allTables).map(function (name) {\n        return _this26._allTables[name];\n      });\n    }\n  }, {\n    key: \"transaction\",\n    value: function transaction() {\n      var args = extractTransactionArgs.apply(this, arguments);\n      return this._transaction.apply(this, args);\n    }\n  }, {\n    key: \"_transaction\",\n    value: function _transaction(mode, tables, scopeFunc) {\n      var _this27 = this;\n\n      var parentTransaction = PSD.trans;\n      if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;\n      var onlyIfCompatible = mode.indexOf('?') !== -1;\n      mode = mode.replace('!', '').replace('?', '');\n      var idbMode, storeNames;\n\n      try {\n        storeNames = tables.map(function (table) {\n          var storeName = table instanceof _this27.Table ? table.name : table;\n          if (typeof storeName !== 'string') throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n          return storeName;\n        });\n        if (mode == \"r\" || mode === READONLY) idbMode = READONLY;else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\n        if (parentTransaction) {\n          if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n            if (onlyIfCompatible) {\n              parentTransaction = null;\n            } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n          }\n\n          if (parentTransaction) {\n            storeNames.forEach(function (storeName) {\n              if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                if (onlyIfCompatible) {\n                  parentTransaction = null;\n                } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n              }\n            });\n          }\n\n          if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n            parentTransaction = null;\n          }\n        }\n      } catch (e) {\n        return parentTransaction ? parentTransaction._promise(null, function (_, reject) {\n          reject(e);\n        }) : rejection(e);\n      }\n\n      var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n      return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, function () {\n        return _this27._whenReady(enterTransaction);\n      }) : this._whenReady(enterTransaction);\n    }\n  }, {\n    key: \"table\",\n    value: function table(tableName) {\n      if (!hasOwn(this._allTables, tableName)) {\n        throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n      }\n\n      return this._allTables[tableName];\n    }\n  }]);\n\n  return Dexie$1;\n}();\n\nvar symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscribe) {\n    _classCallCheck(this, Observable);\n\n    this._subscribe = subscribe;\n  }\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(x, error, complete) {\n      return this._subscribe(!x || typeof x === \"function\" ? {\n        next: x,\n        error: error,\n        complete: complete\n      } : x);\n    }\n  }, {\n    key: symbolObservable,\n    value: function value() {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nfunction extendObservabilitySet(target, newSet) {\n  keys(newSet).forEach(function (part) {\n    var rangeSet = target[part] || (target[part] = new RangeSet());\n    mergeRanges(rangeSet, newSet[part]);\n  });\n  return target;\n}\n\nfunction liveQuery(querier) {\n  return new Observable(function (observer) {\n    var scopeFuncIsAsync = isAsyncFunction(querier);\n\n    function execute(subscr) {\n      if (scopeFuncIsAsync) {\n        incrementExpectedAwaits();\n      }\n\n      var exec = function exec() {\n        return newScope(querier, {\n          subscr: subscr,\n          trans: null\n        });\n      };\n\n      var rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n\n      if (scopeFuncIsAsync) {\n        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n      }\n\n      return rv;\n    }\n\n    var closed = false;\n    var accumMuts = {};\n    var currentObs = {};\n    var subscription = {\n      get closed() {\n        return closed;\n      },\n\n      unsubscribe: function unsubscribe() {\n        closed = true;\n        globalEvents.storagemutated.unsubscribe(mutationListener);\n      }\n    };\n    observer.start && observer.start(subscription);\n    var querying = false,\n        startedListening = false;\n\n    function shouldNotify() {\n      return keys(currentObs).some(function (key) {\n        return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);\n      });\n    }\n\n    var mutationListener = function mutationListener(parts) {\n      extendObservabilitySet(accumMuts, parts);\n\n      if (shouldNotify()) {\n        doQuery();\n      }\n    };\n\n    var doQuery = function doQuery() {\n      if (querying || closed) return;\n      accumMuts = {};\n      var subscr = {};\n      var ret = execute(subscr);\n\n      if (!startedListening) {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n        startedListening = true;\n      }\n\n      querying = true;\n      Promise.resolve(ret).then(function (result) {\n        querying = false;\n        if (closed) return;\n\n        if (shouldNotify()) {\n          doQuery();\n        } else {\n          accumMuts = {};\n          currentObs = subscr;\n          observer.next && observer.next(result);\n        }\n      }, function (err) {\n        querying = false;\n        observer.error && observer.error(err);\n        subscription.unsubscribe();\n      });\n    };\n\n    doQuery();\n    return subscription;\n  });\n}\n\nvar domDeps;\n\ntry {\n  domDeps = {\n    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n  };\n} catch (e) {\n  domDeps = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\n\nvar Dexie = Dexie$1;\nprops(Dexie, _objectSpread(_objectSpread({}, fullNameExceptions), {}, {\n  delete: function _delete(databaseName) {\n    var db = new Dexie(databaseName, {\n      addons: []\n    });\n    return db.delete();\n  },\n  exists: function exists(name) {\n    return new Dexie(name, {\n      addons: []\n    }).open().then(function (db) {\n      db.close();\n      return true;\n    }).catch('NoSuchDatabaseError', function () {\n      return false;\n    });\n  },\n  getDatabaseNames: function getDatabaseNames(cb) {\n    try {\n      return _getDatabaseNames(Dexie.dependencies).then(cb);\n    } catch (_a) {\n      return rejection(new exceptions.MissingAPI());\n    }\n  },\n  defineClass: function defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n\n    return Class;\n  },\n  ignoreTransaction: function ignoreTransaction(scopeFunc) {\n    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n  },\n  vip: vip,\n  async: function async(generatorFn) {\n    return function () {\n      try {\n        var rv = awaitIterator(generatorFn.apply(this, arguments));\n        if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n        return rv;\n      } catch (e) {\n        return rejection(e);\n      }\n    };\n  },\n  spawn: function spawn(generatorFn, args, thiz) {\n    try {\n      var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n      if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n      return rv;\n    } catch (e) {\n      return rejection(e);\n    }\n  },\n  currentTransaction: {\n    get: function get() {\n      return PSD.trans || null;\n    }\n  },\n  waitFor: function waitFor(promiseOrFunction, optionalTimeout) {\n    var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n    return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n  },\n  Promise: DexiePromise,\n  debug: {\n    get: function get() {\n      return debug;\n    },\n    set: function set(value) {\n      setDebug(value, value === 'dexie' ? function () {\n        return true;\n      } : dexieStackFrameFilter);\n    }\n  },\n  derive: derive,\n  extend: extend,\n  props: props,\n  override: override,\n  Events: Events,\n  on: globalEvents,\n  liveQuery: liveQuery,\n  extendObservabilitySet: extendObservabilitySet,\n  getByKeyPath: getByKeyPath,\n  setByKeyPath: setByKeyPath,\n  delByKeyPath: delByKeyPath,\n  shallowClone: shallowClone,\n  deepClone: deepClone,\n  getObjectDiff: getObjectDiff,\n  cmp: cmp,\n  asap: asap$1,\n  minKey: minKey,\n  addons: [],\n  connections: connections,\n  errnames: errnames,\n  dependencies: domDeps,\n  semVer: DEXIE_VERSION,\n  version: DEXIE_VERSION.split('.').map(function (n) {\n    return parseInt(n);\n  }).reduce(function (p, c, i) {\n    return p + c / Math.pow(10, i * 2);\n  })\n}));\nDexie.maxKey = _getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n    if (!propagatingLocally) {\n      var event;\n\n      if (isIEOrEdge) {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n      } else {\n        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n          detail: updatedParts\n        });\n      }\n\n      propagatingLocally = true;\n      dispatchEvent(event);\n      propagatingLocally = false;\n    }\n  });\n  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_ref41) {\n    var detail = _ref41.detail;\n\n    if (!propagatingLocally) {\n      propagateLocally(detail);\n    }\n  });\n}\n\nfunction propagateLocally(updateParts) {\n  var wasMe = propagatingLocally;\n\n  try {\n    propagatingLocally = true;\n    globalEvents.storagemutated.fire(updateParts);\n  } finally {\n    propagatingLocally = wasMe;\n  }\n}\n\nvar propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n  var bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n    if (!propagatingLocally) {\n      bc.postMessage(changedParts);\n    }\n  });\n\n  bc.onmessage = function (ev) {\n    if (ev.data) propagateLocally(ev.data);\n  };\n} else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n    try {\n      if (!propagatingLocally) {\n        if (typeof localStorage !== 'undefined') {\n          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n            trig: Math.random(),\n            changedParts: changedParts\n          }));\n        }\n\n        if (typeof self['clients'] === 'object') {\n          _toConsumableArray(self['clients'].matchAll({\n            includeUncontrolled: true\n          })).forEach(function (client) {\n            return client.postMessage({\n              type: STORAGE_MUTATED_DOM_EVENT_NAME,\n              changedParts: changedParts\n            });\n          });\n        }\n      }\n    } catch (_a) {}\n  });\n  addEventListener('storage', function (ev) {\n    if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n      var data = JSON.parse(ev.newValue);\n      if (data) propagateLocally(data.changedParts);\n    }\n  });\n  var swContainer = self.document && navigator.serviceWorker;\n\n  if (swContainer) {\n    swContainer.addEventListener('message', propagateMessageLocally);\n  }\n}\n\nfunction propagateMessageLocally(_ref42) {\n  var data = _ref42.data;\n\n  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n    propagateLocally(data.changedParts);\n  }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap }; //# sourceMappingURL=dexie.mjs.map","map":null,"metadata":{},"sourceType":"module"}