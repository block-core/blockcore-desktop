{"ast":null,"code":"import _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\n\n/* eslint-disable */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar _a;\n\nimport { Component, ViewEncapsulation, HostBinding, ViewChild, ChangeDetectorRef } from '@angular/core';\nimport { FormBuilder, Validators } from '@angular/forms';\nimport { WalletService } from '../../services/wallet.service';\nimport { ApplicationStateService } from '../../services/application-state.service';\nimport { DetailsService } from '../../services/details.service';\nimport { Router } from '@angular/router';\nimport { GlobalService } from '../../services/global.service';\nimport { ApiService } from '../../services/api.service';\nimport { MatDialog } from '@angular/material/dialog';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatSort } from '@angular/material/sort';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { AppModes } from '../../shared/app-modes';\nimport { WalletInfo } from '@models/wallet-info';\nimport { Logger } from 'src/app/services/logger.service';\nimport { TransactionSending } from '@models/transaction-sending';\n\nvar StakingComponent = /*#__PURE__*/function () {\n  function StakingComponent(apiService, globalService, walletService, router, appState, detailsService, wallet, appModes, dialog, log, fb, ref) {\n    _classCallCheck(this, StakingComponent);\n\n    this.apiService = apiService;\n    this.globalService = globalService;\n    this.walletService = walletService;\n    this.router = router;\n    this.appState = appState;\n    this.detailsService = detailsService;\n    this.wallet = wallet;\n    this.appModes = appModes;\n    this.dialog = dialog;\n    this.log = log;\n    this.fb = fb;\n    this.ref = ref;\n    this.hostClass = true;\n    this.walletInfo = 'When you send, balance can\\ntemporarily go from confirmed\\nto unconfirmed.';\n    this.displayedColumns = ['transactionType', 'transactionAmount', 'transactionTimestamp'];\n    this.dataSource = new MatTableDataSource();\n    this.delegatedStakingAddress = '';\n    this.coldStakingAddress = '';\n    this.links = [{\n      title: 'All',\n      filter: ''\n    }, {\n      title: 'Received',\n      filter: 'received'\n    }, {\n      title: 'Sent',\n      filter: 'sent'\n    }];\n    this.activeLink = this.links[0];\n    this.localOnlineColdStakingAccounts = [];\n    this.hasHotColdStakingBalance = false;\n    this.hasOfflineColdStakingBalance = false;\n    this.mode = '';\n    this.buildStakingForm();\n    this.appState.pageMode = false;\n  }\n\n  _createClass(StakingComponent, [{\n    key: \"buildStakingForm\",\n    value: function buildStakingForm() {\n      this.stakingForm = this.fb.group({\n        walletPassword: ['', Validators.required]\n      });\n      this.delegatedForm = this.fb.group({\n        walletPassword: ['', Validators.required]\n      });\n      this.offlineForm = this.fb.group({\n        walletPassword: ['', Validators.required],\n        onlineColdStakingAddress: ['', Validators.required],\n        amount: ['', Validators.required],\n        fee: ['0.002', Validators.required]\n      });\n      this.coldStakingForm = this.fb.group({\n        walletPassword: ['', Validators.required]\n      });\n    }\n  }, {\n    key: \"onAccountChanged\",\n    value: function onAccountChanged(event) {\n      this.offlineForm.controls['onlineColdStakingAddress'].setValue(event.value);\n    }\n  }, {\n    key: \"getMaxAmount\",\n    value: function getMaxAmount() {\n      var balance = this.globalService.transform(this.wallet.confirmedBalance);\n      this.offlineForm.controls[\"amount\"].setValue(balance);\n    } // TODO: All of this code is a flying spaghetti monster mess!\n    // A proper manager to get state in correct order, etc. must be made, so do some refactoring later!\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this = this;\n\n      this.localOnlineColdStakingAccounts = []; // Discover all online cold staking wallets:\n\n      this.appState.accounts.forEach(function (account) {\n        // \n        _this.apiService.getColdStakingAddress(account.name, false, true).subscribe(function (address) {\n          _this.localOnlineColdStakingAccounts.push({\n            name: account.name,\n            address: address.address\n          });\n\n          console.log(_this.localOnlineColdStakingAccounts);\n        });\n      });\n      var walletInfo = new WalletInfo(this.globalService.getWalletName(), 'coldStakingHotAddresses');\n      var walletInfoOffline = new WalletInfo(this.globalService.getWalletName(), 'coldStakingColdAddresses');\n      this.apiService.getWalletHistory(walletInfo).subscribe(function (response) {\n        console.log(response);\n        _this.coldStakingHistory = response.history[0].transactionsHistory;\n      }, function (error) {\n        console.error(error);\n\n        _this.apiService.handleError(error);\n      });\n      this.apiService.getWalletBalance(walletInfo).subscribe(function (response) {\n        _this.log.info('Get hot cold staking wallet balance:', response);\n\n        var balanceResponse = response;\n        _this.confirmedBalance = balanceResponse.balances[0].amountConfirmed;\n        _this.unconfirmedBalance = balanceResponse.balances[0].amountUnconfirmed;\n\n        if (_this.confirmedBalance + _this.unconfirmedBalance > 0) {\n          _this.hasHotColdStakingBalance = true;\n        } else {\n          _this.hasHotColdStakingBalance = false;\n        }\n      }, function (error) {\n        _this.apiService.handleException(error);\n      });\n      this.apiService.getWalletHistory(walletInfoOffline).subscribe(function (response) {\n        console.log(response);\n        _this.coldStakingOfflineHistory = response.history[0].transactionsHistory;\n      }, function (error) {\n        console.error(error);\n\n        _this.apiService.handleError(error);\n      });\n      this.apiService.getWalletBalance(walletInfoOffline).subscribe(function (response) {\n        _this.log.info('Get offline cold staking wallet balance:', response);\n\n        var balanceResponse = response;\n        _this.confirmedOfflineBalance = balanceResponse.balances[0].amountConfirmed;\n        _this.unconfirmedOfflineBalance = balanceResponse.balances[0].amountUnconfirmed;\n\n        if (_this.confirmedOfflineBalance + _this.unconfirmedOfflineBalance > 0) {\n          _this.hasOfflineColdStakingBalance = true;\n        } else {\n          _this.hasOfflineColdStakingBalance = false;\n        }\n      }, function (error) {\n        _this.apiService.handleException(error);\n      });\n      this.dataSource.paginator = this.paginator;\n      this.dataSource.sort = this.sort; // \"Cannot read property 'length' of undefined\" error when setting to empty value.\n\n      if (this.wallet.transactionArray != null) {\n        this.parseHistory(this.wallet.transactionArray); // this.dataSource.data = this.wallet.transactionArray;\n      } // We will only retrieve UTXOs statistics if user has enable advanced mode.\n\n\n      if (this.appModes.enabled('staking')) {\n        var _walletInfo = new WalletInfo(this.globalService.getWalletName());\n\n        this.apiService.getWalletStatistics(_walletInfo).subscribe(function (data) {\n          console.log(data);\n          _this.walletStatistics = data;\n\n          _this.ref.detectChanges();\n        });\n      }\n\n      this.walletServiceSubscription = this.wallet.history$.subscribe(function (items) {\n        _this.dataSource.paginator = _this.paginator;\n        _this.dataSource.sort = _this.sort;\n\n        _this.parseHistory(items);\n\n        _this.ref.detectChanges(); // this.dataSource.paginator = this.paginator;\n        // this.dataSource.sort = this.sort;\n\n      });\n      this.coldStakingSubscription = this.apiService.getColdStakingInfo(this.globalService.getWalletName()).subscribe(function (data) {\n        console.log('Cold Staking Info: ', data);\n        _this.coldStakingInfo = data;\n\n        if (_this.coldStakingInfo && _this.coldStakingInfo.coldWalletAccountExists || _this.coldStakingInfo.hotWalletAccountExists) {\n          _this.mode = 'enabled';\n        }\n\n        if (_this.coldStakingInfo.coldWalletAccountExists) {\n          _this.apiService.getColdStakingAddress(_this.globalService.getWalletName(), true, true).subscribe(function (data) {\n            console.log('Delegated Staking Address: ', data);\n            _this.delegatedStakingAddress = data.address;\n          });\n        }\n\n        if (_this.coldStakingInfo.hotWalletAccountExists) {\n          _this.apiService.getColdStakingAddress(_this.globalService.getWalletName(), false, true).subscribe(function (data) {\n            console.log('Cold Staking Address: ', data);\n            _this.coldStakingAddress = data.address;\n          });\n        }\n      }); // We probably need to figure out what flag to look for to see if segwit is required. We can't allow user to select this.\n      // (this.appState.addressType === 'Segwit')\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.walletServiceSubscription) {\n        this.walletServiceSubscription.unsubscribe();\n      }\n\n      if (this.coldStakingSubscription) {\n        this.coldStakingSubscription.unsubscribe();\n      }\n    }\n  }, {\n    key: \"selectRow\",\n    value: function selectRow(row) {\n      console.log(row);\n    }\n  }, {\n    key: \"filterHistory\",\n    value: function filterHistory(link) {\n      this.activeLink = link;\n      this.applyFilter(this.activeLink.filter);\n    }\n  }, {\n    key: \"applyFilter\",\n    value: function applyFilter(filterValue) {\n      this.dataSource.filter = filterValue.trim().toLowerCase();\n\n      if (this.dataSource.paginator) {\n        this.dataSource.paginator.firstPage();\n      }\n    }\n  }, {\n    key: \"setMode\",\n    value: function setMode(mode) {\n      this.mode = mode;\n\n      if (!this.mode) {\n        this.stakingForm.reset();\n        this.coldStakingForm.reset();\n        this.offlineForm.reset();\n        this.delegatedForm.reset();\n      }\n    }\n  }, {\n    key: \"setupStaking\",\n    value: function setupStaking() {\n      var _this2 = this;\n\n      this.invalidPassword = false;\n      var amount = +this.offlineForm.get('amount').value;\n      var confirmedBalance = +this.globalService.transform(this.wallet.confirmedBalance);\n      var fee = +this.offlineForm.get('fee').value; // Basic protection against mistakes.\n\n      if (fee > amount) {\n        throw Error('You cannot have a fee that is larger than the amount.');\n      } // If the amount and fee is larger than balance, remove fee from amount.\n\n\n      if (amount + fee > confirmedBalance) {\n        amount = amount - fee;\n      }\n\n      this.apiService.setupOfflineColdStaking(this.globalService.getWalletName(), this.offlineForm.get('walletPassword').value, 'account 0', this.delegatedStakingAddress, this.offlineForm.get('onlineColdStakingAddress').value, amount, fee, true, // segwit change address\n      true // paytoscript\n      ).subscribe(function (response) {\n        _this2.log.info('offline cold staking transaction hex:', response.transactionHex); // Broadcast transaction:\n\n\n        _this2.apiService.sendTransaction(new TransactionSending(response.transactionHex)).subscribe(function (response) {\n          _this2.log.info('Transaction broadcasted successfully and cold staking activated!', response);\n        }, function (error) {\n          console.error(error);\n\n          _this2.apiService.handleException(error);\n        });\n      }, function (error) {\n        var _a;\n\n        if (((_a = error.error.errors[0]) === null || _a === void 0 ? void 0 : _a.message.indexOf('Invalid password')) > -1) {\n          _this2.invalidPassword = true;\n        }\n\n        _this2.apiService.handleException(error);\n      });\n    }\n  }, {\n    key: \"enableDelegatedStaking\",\n    value: function enableDelegatedStaking() {\n      var _this3 = this;\n\n      this.apiService.enableColdStaking(this.globalService.getWalletName(), this.delegatedForm.get('walletPassword').value, true).subscribe(function (response) {\n        _this3.log.info('delegated staking enabled:', response);\n      }, function (error) {\n        _this3.apiService.handleException(error);\n      });\n      this.delegatedForm.patchValue({\n        walletPassword: ''\n      });\n    }\n  }, {\n    key: \"enableColdStaking\",\n    value: function enableColdStaking() {\n      var _this4 = this;\n\n      this.apiService.enableColdStaking(this.globalService.getWalletName(), this.coldStakingForm.get('walletPassword').value, false).subscribe(function (response) {\n        _this4.log.info('cold staking enabled:', response);\n      }, function (error) {\n        _this4.apiService.handleException(error);\n      });\n      this.coldStakingForm.patchValue({\n        walletPassword: ''\n      });\n    }\n  }, {\n    key: \"parseHistory\",\n    value: function parseHistory(items) {\n      this.dataSource.data = items;\n\n      if (items.length > 0) {\n        var firstTransaction = items[items.length - 1];\n        this.firstTransactionDate = new Date(firstTransaction.transactionTimestamp * 1000);\n        this.countSent = items.filter(function (i) {\n          return i.transactionType === 'sent';\n        }).length;\n        this.countReceived = items.filter(function (i) {\n          return i.transactionType === 'received';\n        }).length;\n        this.links[0].title = 'All (' + items.length + ')';\n        this.links[1].title = 'Received (' + this.countReceived + ')';\n        this.links[2].title = 'Sent (' + this.countSent + ')';\n      }\n    }\n  }, {\n    key: \"stopStaking\",\n    value: function stopStaking() {\n      this.wallet.stopStaking();\n    }\n  }, {\n    key: \"startStaking\",\n    value: function startStaking() {\n      this.wallet.startStaking(this.stakingForm.get('walletPassword').value);\n      this.stakingForm.patchValue({\n        walletPassword: ''\n      });\n    }\n  }, {\n    key: \"openTransactionDetails\",\n    value: function openTransactionDetails(transaction) {\n      this.detailsService.show(transaction);\n    }\n  }]);\n\n  return StakingComponent;\n}();\n\n__decorate([HostBinding('class.wallet'), __metadata(\"design:type\", Object)], StakingComponent.prototype, \"hostClass\", void 0);\n\n__decorate([ViewChild(MatPaginator, {\n  static: true\n}), __metadata(\"design:type\", MatPaginator)], StakingComponent.prototype, \"paginator\", void 0);\n\n__decorate([ViewChild(MatSort, {\n  static: true\n}), __metadata(\"design:type\", MatSort)], StakingComponent.prototype, \"sort\", void 0);\n\nStakingComponent = __decorate([Component({\n  selector: 'app-staking',\n  templateUrl: './staking.component.html',\n  styleUrls: ['./staking.component.scss'],\n  encapsulation: ViewEncapsulation.None\n}), __metadata(\"design:paramtypes\", [ApiService, GlobalService, WalletService, Router, ApplicationStateService, DetailsService, WalletService, AppModes, MatDialog, typeof (_a = typeof Logger !== \"undefined\" && Logger) === \"function\" ? _a : Object, FormBuilder, ChangeDetectorRef])], StakingComponent);\nexport { StakingComponent };","map":null,"metadata":{},"sourceType":"module"}