{"ast":null,"code":"/* eslint-disable */\nexport function isUndefined(value) {\n  return typeof value === 'undefined';\n}\nexport function isNull(value) {\n  return value === null;\n}\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\nexport function isNumberFinite(value) {\n  return isNumber(value) && isFinite(value);\n} // Not strict positive\n\nexport function isPositive(value) {\n  return value >= 0;\n}\nexport function isInteger(value) {\n  // No rest, is an integer\n  return value % 1 === 0;\n}\nexport function isNil(value) {\n  return value === null || typeof value === 'undefined';\n}\nexport function isString(value) {\n  return typeof value === 'string';\n}\nexport function isObject(value) {\n  return value !== null && typeof value === 'object';\n}\nexport function isArray(value) {\n  return Array.isArray(value);\n}\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\nexport function toDecimal(value, decimal) {\n  return Math.round(value * Math.pow(10, decimal)) / Math.pow(10, decimal);\n}\nexport function upperFirst(value) {\n  return value.slice(0, 1).toUpperCase() + value.slice(1);\n}\nexport function createRound(method) {\n  // <any>Math to suppress error\n  const func = Math[method];\n  return function (value, precision = 0) {\n    if (typeof value === 'string') {\n      throw new TypeError('Rounding method needs a number');\n    }\n\n    if (typeof precision !== 'number' || isNaN(precision)) {\n      precision = 0;\n    }\n\n    if (precision) {\n      let pair = `${value}e`.split('e');\n      const val = func(`${pair[0]}e` + (+pair[1] + precision));\n      pair = `${val}e`.split('e');\n      return +(pair[0] + 'e' + (+pair[1] - precision));\n    }\n\n    return func(value);\n  };\n}\nexport function leftPad(str, len = 0, ch = ' ') {\n  str = String(str);\n  ch = toString(ch);\n  let i = -1;\n  const length = len - str.length;\n\n  while (++i < length && str.length + ch.length <= len) {\n    str = ch + str;\n  }\n\n  return str;\n}\nexport function rightPad(str, len = 0, ch = ' ') {\n  str = String(str);\n  ch = toString(ch);\n  let i = -1;\n  const length = len - str.length;\n\n  while (++i < length && str.length + ch.length <= len) {\n    str += ch;\n  }\n\n  return str;\n}\nexport function toString(value) {\n  return `${value}`;\n}\nexport function pad(str, len = 0, ch = ' ') {\n  str = String(str);\n  ch = toString(ch);\n  let i = -1;\n  const length = len - str.length;\n  let left = true;\n\n  while (++i < length) {\n    const l = str.length + ch.length <= len ? str.length + ch.length : str.length + 1;\n\n    if (left) {\n      str = leftPad(str, l, ch);\n    } else {\n      str = rightPad(str, l, ch);\n    }\n\n    left = !left;\n  }\n\n  return str;\n}\nexport function flatten(input, index = 0) {\n  if (index >= input.length) {\n    return input;\n  }\n\n  if (isArray(input[index])) {\n    return flatten(input.slice(0, index).concat(input[index], input.slice(index + 1)), index);\n  }\n\n  return flatten(input, index + 1);\n}\nexport function getProperty(value, key) {\n  if (isNil(value) || !isObject(value)) {\n    return undefined;\n  }\n\n  const keys = key.split('.');\n  let result = value[keys.shift()];\n\n  for (const key of keys) {\n    if (isNil(result) || !isObject(result)) {\n      return undefined;\n    }\n\n    result = result[key];\n  }\n\n  return result;\n}\nexport function sum(input, initial = 0) {\n  return input.reduce((previous, current) => previous + current, initial);\n} // http://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array-in-javascript\n\nexport function shuffle(input) {\n  if (!isArray(input)) {\n    return input;\n  }\n\n  const copy = [...input];\n\n  for (let i = copy.length; i; --i) {\n    const j = Math.floor(Math.random() * i);\n    const x = copy[i - 1];\n    copy[i - 1] = copy[j];\n    copy[j] = x;\n  }\n\n  return copy;\n}\nexport function deepIndexOf(collection, value) {\n  let index = -1;\n  const length = collection.length;\n\n  while (++index < length) {\n    if (deepEqual(value, collection[index])) {\n      return index;\n    }\n  }\n\n  return -1;\n}\nexport function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!(typeof a === 'object' && typeof b === 'object')) {\n    return a === b;\n  }\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  for (let i = 0; i < keysA.length; i++) {\n    const key = keysA[i];\n\n    if (!hasOwn.call(b, keysA[i]) || !deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function isDeepObject(object) {\n  return object.__isDeepObject__;\n}\nexport function wrapDeep(object) {\n  return new DeepWrapper(object);\n}\nexport function unwrapDeep(object) {\n  if (isDeepObject(object)) {\n    return object.data;\n  }\n\n  return object;\n}\nexport class DeepWrapper {\n  data;\n  __isDeepObject__ = true;\n\n  constructor(data) {\n    this.data = data;\n  }\n\n}\nexport function count(input) {\n  if (!isArray(input) && !isObject(input) && !isString(input)) {\n    return input;\n  }\n\n  if (isObject(input)) {\n    return Object.keys(input).map(value => input[value]).length;\n  }\n\n  return input.length;\n}\nexport function empty(input) {\n  if (!isArray(input)) {\n    return input;\n  }\n\n  return input.length === 0;\n}\nexport function every(input, predicate) {\n  if (!isArray(input) || !predicate) {\n    return input;\n  }\n\n  let result = true;\n  let i = -1;\n\n  while (++i < input.length && result) {\n    result = predicate(input[i], i, input);\n  }\n\n  return result;\n}\nexport function takeUntil(input, predicate) {\n  let i = -1;\n  const result = [];\n\n  while (++i < input.length && !predicate(input[i], i, input)) {\n    result[i] = input[i];\n  }\n\n  return result;\n}\nexport function takeWhile(input, predicate) {\n  return takeUntil(input, (item, index, collection) => !predicate(item, index, collection));\n}","map":null,"metadata":{},"sourceType":"module"}