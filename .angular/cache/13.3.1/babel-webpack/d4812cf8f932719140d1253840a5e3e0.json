{"ast":null,"code":"import _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\n\n/* eslint-disable */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar _a, _b;\n\nimport { Component, ViewEncapsulation, HostBinding, NgZone, ChangeDetectorRef } from '@angular/core';\nimport { AuthenticationService } from '../../services/authentication.service';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { ApplicationStateService } from '../../services/application-state.service';\nimport * as signalR from '@aspnet/signalr';\nimport { ApiService } from '../../services/api.service';\nimport { delay, retryWhen, tap } from 'rxjs/operators';\nimport { Logger } from '../../services/logger.service';\nimport { HttpClient } from '@angular/common/http';\nimport { ElectronService } from 'ngx-electron';\nimport { environment } from 'src/environments/environment';\nimport { ChainService } from 'src/app/services/chain.service';\nimport { StorageService } from 'src/app/services/storage.service';\n\nvar LoadComponent = /*#__PURE__*/function () {\n  function LoadComponent(route, http, authService, electronService, router, chains, log, zone, cd, apiService, storage, appState) {\n    var _this = this;\n\n    _classCallCheck(this, LoadComponent);\n\n    this.route = route;\n    this.http = http;\n    this.authService = authService;\n    this.electronService = electronService;\n    this.router = router;\n    this.chains = chains;\n    this.log = log;\n    this.zone = zone;\n    this.cd = cd;\n    this.apiService = apiService;\n    this.storage = storage;\n    this.appState = appState;\n    this.hostClass = true;\n    this.hasWallet = false;\n    this.modes = [];\n    this.networks = [];\n    this.delayed = false; // dataFolder: string;\n    // nodePath: string;\n\n    this.downloading = false;\n    this.unpacking = false;\n    this.unpacked = false;\n    this.TryDelayMilliseconds = 3000;\n    this.MaxRetryCount = 50;\n    this.loadingFailed = false;\n    this.apiConnected = false;\n    this.modes = [{\n      id: 'full',\n      name: 'Full'\n    }];\n\n    if (!environment.production) {\n      this.modes.push( // { id: 'demo', name: 'Demo' }, // Auto-wallet creation, etc.\n      {\n        id: 'local',\n        name: 'Custom'\n      }, // Launches the daemon by specifying path to .dll file.\n      {\n        id: 'manual',\n        name: 'Manual'\n      }, // Manual startup of daemon, does not send shutdown messages. Useful when you debug node with Visual Studio.\n      {\n        id: 'simple',\n        name: 'Mobile'\n      }); // API Wallet mode.\n      // { id: 'light', name: 'Light' }, // Full Node in Purge mode and other features disabled.\n      // { id: 'pos', name: 'Point-of-Sale (POS)' },\n      // { id: 'readonly', name: 'Read-only' });\n    }\n\n    this.selectedMode = this.modes.find(function (mode) {\n      return mode.id === _this.appState.daemon.mode;\n    });\n\n    if (this.appState.isChangingToChain) {\n      // If the user has selected a new chain to change to, just do it automatically.\n      this.appState.activeChain = this.appState.changeToChain; // Important to update this, it will be used by API Service to initialize the correct node daemon.\n\n      this.appState.daemon.network = this.appState.activeChain.network; // this.appState.changeToChain = null;\n      // if (this.appState.changeToChain) {\n      //     this.appState.changeToChain = null;\n      // }\n    } else {\n      // Make sure that the chain setup is available in the appstate.\n      this.appState.activeChain = this.chains.availableChains.find(function (network) {\n        return network.network === _this.appState.daemon.network;\n      });\n    }\n\n    this.remember = true;\n    this.log.info('Mode:', this.selectedMode);\n    this.log.info('Network:', this.appState.activeChain);\n    this.log.info('Daemon App State:', JSON.stringify(this.appState.daemon));\n    this.ipc = electronService.ipcRenderer;\n    this.ipc.on('choose-data-folder', function (event, path) {\n      // notificationService.show({ title: 'Checking for update...', body: JSON.stringify(info) });\n      console.log('choose-data-folder: ', path);\n      _this.appState.daemon.datafolder = path; // We must force a detection here to make it update immediately.\n\n      _this.cd.detectChanges();\n    });\n    this.ipc.on('choose-node-path', function (event, path) {\n      // notificationService.show({ title: 'Checking for update...', body: JSON.stringify(info) });\n      console.log('choose-node-path: ', path); // this.nodePath = path;\n\n      _this.appState.daemon.path = path; // We must force a detection here to make it update immediately.\n\n      _this.cd.detectChanges();\n    });\n    this.ipc.on('download-blockchain-package-finished', function (event, finished, progress, error) {\n      if (error) {\n        console.error('Error during downloading: ' + error);\n      }\n\n      _this.downloadProgress = progress;\n\n      if (finished) {\n        // If finished with error, we won't unpack.\n        if (progress.status == 'Done') {\n          _this.downloading = false;\n\n          _this.unpack(progress.target);\n        } else {\n          _this.downloading = false;\n        } // Clear the download progress.\n\n\n        _this.downloadProgress = null;\n      } // We must force a detection here to make it update immediately.\n\n\n      _this.cd.detectChanges();\n    });\n    this.ipc.on('unpack-blockchain-package-finished', function (error) {\n      _this.unpacking = false;\n      _this.unpacked = true;\n\n      if (error) {\n        console.error('Error during downloading: ' + error);\n      } else {} // We must force a detection here to make it update immediately.\n\n\n      _this.cd.detectChanges();\n    });\n  }\n\n  _createClass(LoadComponent, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.apiService.initialize(); // TODO: Should send the correct network, hard-coded to city main for now.\n      // Do this always now, we need this information in the UI for identity handling.\n      // const network = coininfo('city').toBitcoinJS();\n      // this.appState.networkDefinition = network;\n\n      this.appState.networkParams = {\n        private: this.appState.activeChain.private,\n        public: this.appState.activeChain.public // PubKeyHash\n\n      }; // this.appState.networkParams = {\n      //     private: network.wif,\n      //     public: network.pubKeyHash\n      // };\n\n      console.log('INITILIZE!....', this.appState.daemon);\n      console.log(this.appState); // Update the overlay icon to visualize current chain.\n\n      this.electronService.ipcRenderer.send('update-icon', {\n        icon: '/src/assets/' + this.appState.chain + '/logo.png',\n        title: this.appState.chain\n      });\n\n      if (this.appState.daemon.mode === 'full' || this.appState.daemon.mode === 'local' || this.appState.daemon.mode === 'light') {\n        this.loading = true;\n        this.appState.connected = false;\n        this.cd.detectChanges();\n        this.fullNodeConnect();\n      } else if (this.appState.daemon.mode === 'manual') {\n        this.loading = false;\n        this.appState.connected = true;\n        this.cd.detectChanges();\n        this.fullNodeConnect();\n      } else if (this.appState.daemon.mode === 'simple') {\n        // TODO: Should send the correct network, hard-coded to city main for now.\n        // const network = coininfo('city').toBitcoinJS();\n        // this.appState.networkDefinition = network;\n        // this.appState.networkParams = {\n        //     private: network.wif,\n        //     public: network.pubKeyHash\n        // };\n        this.loading = false;\n        this.appState.connected = true;\n        this.router.navigateByUrl('/login');\n      }\n    }\n  }, {\n    key: \"listTestNetworks\",\n    get: function get() {\n      return this.storage.getValue('Network:ListTestNetworks') === 'true';\n    },\n    set: function set(value) {\n      this.storage.setValue('Network:ListTestNetworks', value.toString());\n    }\n  }, {\n    key: \"filteredAvailableChains\",\n    get: function get() {\n      return this.listTestNetworks ? this.chains.availableChains : this.chains.availableChains.filter(function (language) {\n        return !language.test;\n      });\n    }\n  }, {\n    key: \"onDaemonFolderChange\",\n    value: function onDaemonFolderChange(event) {\n      this.log.info('Daemon folder changed:', event);\n\n      if (event.target.files.length > 0) {\n        this.appState.daemon.path = event.target.files[0].path;\n      } else {\n        this.appState.daemon.path = '';\n      }\n    }\n  }, {\n    key: \"chooseNodeExecutable\",\n    value: function chooseNodeExecutable() {\n      this.electronService.ipcRenderer.send('choose-node-path');\n    }\n  }, {\n    key: \"clearNodePath\",\n    value: function clearNodePath() {\n      this.appState.daemon.path = '';\n    }\n  }, {\n    key: \"chooseDataFolder\",\n    value: function chooseDataFolder() {\n      this.electronService.ipcRenderer.send('choose-data-folder');\n    }\n  }, {\n    key: \"clearDataFolder\",\n    value: function clearDataFolder() {\n      this.appState.daemon.datafolder = '';\n    }\n  }, {\n    key: \"onDataFolderChange\",\n    value: function onDataFolderChange(event) {\n      this.log.info('Data folder changed:', event);\n\n      if (event.target.files.length > 0) {\n        this.appState.daemon.datafolder = event.target.files[0].path;\n      } else {\n        this.appState.daemon.datafolder = '';\n      }\n    }\n  }, {\n    key: \"launch\",\n    value: function launch() {\n      this.appState.updateNetworkSelection(this.remember, this.selectedMode.id, this.appState.activeChain.network, this.appState.daemon.path, this.appState.daemon.datafolder); // If the selected mode is not 'local', we'll reset the path and data folder.\n\n      if (this.appState.daemon.mode !== 'local') {\n        localStorage.removeItem('Network:Path');\n        localStorage.removeItem('Network:DataFolder');\n      }\n\n      this.initialize();\n    }\n  }, {\n    key: \"fullNodeConnect\",\n    value: function fullNodeConnect() {\n      var _this2 = this;\n\n      // Do we need to keep a pointer to this timeout and remove it, or does the zone handle that?\n      this.zone.run(function () {\n        setTimeout(function () {\n          _this2.delayed = true;\n        }, 60000); // 60000 Make sure it is fairly high, we don't want users to immediatly perform advanced reset options when they don't need to.\n      });\n      this.tryStart();\n    }\n  }, {\n    key: \"downloadAndUnpack\",\n    value: function downloadAndUnpack(url) {\n      // If user does \"Copy as path\" we must ensure we replace the quotes.\n      url = url.replaceAll('\"', ''); // replaceAll is a very recent addition to ECMAScript, so we had to make url the type of any.\n\n      var isAbsolute = new RegExp('^([a-z]+://|//)', 'i');\n\n      if (isAbsolute.test(url)) {\n        console.log('Download: ' + url);\n        this.downloading = true; // Send array of path information to be used in path.join to get native full path in the main process.\n\n        var pathInfo = [this.appState.daemon.datafolder, this.appState.activeChain.rootFolderName, this.appState.activeChain.network];\n        var downloadInfo = {\n          url: url,\n          path: pathInfo\n        };\n        this.log.info('Target Folder...', downloadInfo);\n        this.electronService.ipcRenderer.sendSync('download-blockchain-package', downloadInfo); // this.appState.daemon.datafolder\n      } else {\n        // If the user supplies an relative / local path, we'll go ahead and unpack directly.\n        this.unpack(url);\n      }\n    }\n  }, {\n    key: \"openFolder\",\n    value: function openFolder(directory) {\n      this.electronService.shell.openPath(directory);\n    }\n  }, {\n    key: \"unpack\",\n    value: function unpack(source) {\n      // Send array of path information to be used in path.join to get native full path in the main process.\n      var pathInfo = [this.appState.daemon.datafolder, this.appState.activeChain.rootFolderName, this.appState.activeChain.network];\n      var downloadInfo = {\n        source: source,\n        path: pathInfo\n      };\n      this.unpacking = true; // unpack-blockchain-package\n\n      this.electronService.ipcRenderer.sendSync('unpack-blockchain-package', downloadInfo);\n    }\n  }, {\n    key: \"cancelDownload\",\n    value: function cancelDownload() {\n      this.electronService.ipcRenderer.sendSync('download-blockchain-package-abort');\n      this.downloading = false;\n    } // Attempts to initialise the wallet by contacting the daemon.  Will try to do this MaxRetryCount times.\n\n  }, {\n    key: \"tryStart\",\n    value: function tryStart() {\n      var _this3 = this;\n\n      var retry = 0;\n      var stream$ = this.apiService.getNodeStatus().pipe(retryWhen(function (errors) {\n        return errors.pipe(delay(_this3.TryDelayMilliseconds)).pipe(tap(function (errorStatus) {\n          if (retry++ === _this3.MaxRetryCount) {\n            throw errorStatus;\n          }\n\n          _this3.log.info(\"Retrying \".concat(retry, \"...\"));\n        }));\n      }));\n      this.subscription = stream$.subscribe(function (data) {\n        _this3.apiConnected = true;\n        _this3.statusIntervalSubscription = _this3.apiService.getNodeStatusCustomInterval(350) // Get status quickly during initial load.\n        .subscribe(function (response) {\n          _this3.featureStatus = response.featuresData.map(function (d) {\n            return {\n              name: d.namespace.split('.').pop(),\n              state: d.state,\n              initialized: d.state === 'Initialized'\n            };\n          });\n\n          var loadingStatus = _this3.featureStatus.filter(function (x) {\n            return x.name == 'WalletFeature';\n          });\n\n          if (loadingStatus.length > 0 && loadingStatus[0].initialized) {\n            _this3.statusIntervalSubscription.unsubscribe();\n\n            _this3.start();\n          }\n        });\n      }, function (error) {\n        _this3.log.info('Failed to start wallet');\n\n        _this3.loading = false;\n        _this3.loadingFailed = true;\n      });\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      // this.simpleWalletConnect();\n      // We have successful connection with daemon, make sure we inform the main process of |.\n      this.electronService.ipcRenderer.send('daemon-started');\n      this.loading = false;\n      this.appState.connected = true;\n      this.router.navigateByUrl('/login');\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this4 = this;\n\n      this.routingSubscription = this.route.queryParams.subscribe(function (params) {\n        if (params.loading == true) {\n          // params will be strings, so can be 'true' or 'false' in this case. So double equal to ensure it triggers on both.\n          _this4.loading = true;\n          _this4.loadingFailed = false;\n          _this4.appState.connected = false;\n        } else {\n          _this4.loading = false;\n        }\n\n        if (params.changing) {// this.initialize();\n        }\n      }); // this.unsubscribe(); // Make sure we unsubscribe existing listeners.\n      // this.launch();\n      // this.initialize();\n      // }\n      // else {\n      //     const existingMode = localStorage.getItem('Network:Mode');\n      //     // If user has choosen to remember mode, we'll redirect directly to login, when connected.\n      //     if (existingMode != null) {\n      //         this.initialize();\n      //     }\n      // }\n\n      if (this.appState.changeToChain && this.appState.isChangingToChain) {\n        this.appState.isChangingToChain = false;\n        this.initialize();\n      }\n\n      var existingMode = localStorage.getItem('Network:Mode'); // If user has choosen to remember mode, we'll redirect directly to login, when connected.\n\n      if (existingMode != null) {\n        this.initialize();\n      }\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.unsubscribe();\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (this.routingSubscription) {\n        this.routingSubscription.unsubscribe();\n      }\n\n      if (this.apiSubscription) {\n        this.apiSubscription.unsubscribe();\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.unsubscribe();\n      this.appState.connected = false;\n      this.loading = false;\n      this.delayed = false;\n      this.appState.daemon.mode = null;\n    }\n  }, {\n    key: \"simpleWalletConnect\",\n    value: function simpleWalletConnect() {\n      this.connection = new signalR.HubConnectionBuilder().withUrl('http://localhost:4337/node').build();\n      this.connection.on('BlockConnected', function (block) {\n        console.log('BlockConnected:' + block);\n      });\n      this.connection.on('TransactionReceived', function (trx) {\n        console.log('TransactionReceived:' + trx);\n      });\n      this.connection.on('txs', function (transactions) {\n        console.log(transactions); // TODO: Update a bitcore-lib fork to add support for Stratis/City Chain.\n        // var tx1 = transactions[0];\n        // var tx = bitcoin.Transaction.fromHex(tx1.value.hex);\n      });\n      var self = this; // Transport fallback functionality is now built into start.\n\n      this.connection.start().then(function () {\n        console.log('connection started');\n        self.connection.send('Subscribe', {\n          events: ['TransactionReceived', 'BlockConnected']\n        });\n      }).catch(function (error) {\n        console.error(error.message);\n      });\n    }\n  }]);\n\n  return LoadComponent;\n}();\n\n__decorate([HostBinding('class.load'), __metadata(\"design:type\", Object)], LoadComponent.prototype, \"hostClass\", void 0);\n\nLoadComponent = __decorate([Component({\n  selector: 'app-load',\n  templateUrl: './load.component.html',\n  styleUrls: ['./load.component.scss'],\n  encapsulation: ViewEncapsulation.None\n}), __metadata(\"design:paramtypes\", [ActivatedRoute, HttpClient, AuthenticationService, ElectronService, Router, typeof (_a = typeof ChainService !== \"undefined\" && ChainService) === \"function\" ? _a : Object, Logger, NgZone, ChangeDetectorRef, ApiService, typeof (_b = typeof StorageService !== \"undefined\" && StorageService) === \"function\" ? _b : Object, ApplicationStateService])], LoadComponent);\nexport { LoadComponent };","map":null,"metadata":{},"sourceType":"module"}