{"ast":null,"code":"const bip66 = require('bip66');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst typeforce = require('typeforce');\n\nconst types = require('./types');\n\nconst ZERO = Buffer.alloc(1, 0);\n\nfunction toDER(x) {\n  let i = 0;\n\n  while (x[i] === 0) ++i;\n\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n} // BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n\n\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  const decode = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decode.r);\n  const s = fromDER(decode.s);\n  return {\n    signature: Buffer.concat([r, s], 64),\n    hashType: hashType\n  };\n}\n\nfunction encode(signature, hashType) {\n  typeforce({\n    signature: types.BufferN(64),\n    hashType: types.UInt8\n  }, {\n    signature,\n    hashType\n  });\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode\n};","map":null,"metadata":{},"sourceType":"script"}