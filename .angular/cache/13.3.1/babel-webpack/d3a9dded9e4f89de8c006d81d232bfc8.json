{"ast":null,"code":"import { isNumberFinite, isPositive, isInteger, toDecimal } from './utils';\nimport * as i0 from \"@angular/core\";\nexport class BytesPipe {\n  static formats = {\n    B: {\n      max: 1024\n    },\n    kB: {\n      max: Math.pow(1024, 2),\n      prev: 'B'\n    },\n    KB: {\n      max: Math.pow(1024, 2),\n      prev: 'B'\n    },\n    MB: {\n      max: Math.pow(1024, 3),\n      prev: 'kB'\n    },\n    GB: {\n      max: Math.pow(1024, 4),\n      prev: 'MB'\n    },\n    TB: {\n      max: Number.MAX_SAFE_INTEGER,\n      prev: 'GB'\n    }\n  };\n\n  transform(input, decimal = 0, from = 'B', to) {\n    if (!(isNumberFinite(input) && isNumberFinite(decimal) && isInteger(decimal) && isPositive(decimal))) {\n      return input;\n    }\n\n    let bytes = input;\n    let unit = from;\n\n    while (unit !== 'B') {\n      bytes *= 1024;\n      unit = BytesPipe.formats[unit].prev;\n    }\n\n    if (to) {\n      const format = BytesPipe.formats[to];\n      const result = toDecimal(BytesPipe.calculateResult(format, bytes), decimal);\n      return BytesPipe.formatResult(result, to);\n    }\n\n    for (const key in BytesPipe.formats) {\n      if (BytesPipe.formats.hasOwnProperty(key)) {\n        const format = BytesPipe.formats[key];\n\n        if (bytes < format.max) {\n          const result = toDecimal(BytesPipe.calculateResult(format, bytes), decimal);\n          return BytesPipe.formatResult(result, key);\n        }\n      }\n    }\n  }\n\n  static formatResult(result, unit) {\n    return `${result} ${unit}`;\n  }\n\n  static calculateResult(format, bytes) {\n    const prev = format.prev ? BytesPipe.formats[format.prev] : undefined;\n    return prev ? bytes / prev.max : bytes;\n  }\n\n  static ɵfac = function BytesPipe_Factory(t) {\n    return new (t || BytesPipe)();\n  };\n  static ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n    name: \"bytes\",\n    type: BytesPipe,\n    pure: true\n  });\n}","map":null,"metadata":{},"sourceType":"module"}