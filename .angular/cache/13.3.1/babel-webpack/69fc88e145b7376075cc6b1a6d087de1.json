{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { __awaiter } from \"tslib\";\nimport { Identity, IdentityContainer } from '@models/identity';\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as bip32 from 'bip32';\nimport * as bip38 from '../../libs/bip38';\nimport * as city from 'city-lib';\nimport { Jws } from '../shared/jose';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./application-state.service\";\nimport * as i2 from \"./hub.service\";\nimport * as i3 from \"./authentication.service\";\nimport * as i4 from \"ngx-electron\";\nimport * as i5 from \"./storage.service\";\nexport var IdentityService = /*#__PURE__*/(function () {\n  var IdentityService = /*#__PURE__*/function () {\n    function IdentityService(appState, hubService, authentication, electronService, storage) {\n      _classCallCheck(this, IdentityService);\n\n      this.appState = appState;\n      this.hubService = hubService;\n      this.authentication = authentication;\n      this.electronService = electronService;\n      this.storage = storage; // Initialize the BehaviorSubject with data from the localStorage. The subject holds the internal state of the identities.\n\n      this.identitiesSubject = new BehaviorSubject([]);\n      this.identitySubject = new BehaviorSubject(null);\n      this.identityNetwork = {\n        pubKeyHash: 55,\n        scriptHash: 117\n      };\n      this.identity$ = this.identitySubject.asObservable();\n      this.identities$ = this.identitiesSubject.asObservable();\n      this.lockedIdentities$ = this.identities$.pipe(map(function (items) {\n        return items.filter(function (item) {\n          return item.locked;\n        });\n      }));\n      this.publishedIdentities$ = this.identities$.pipe(map(function (items) {\n        return items.filter(function (item) {\n          return item.published;\n        });\n      }));\n      console.log('IdentityService created.');\n    }\n\n    _createClass(IdentityService, [{\n      key: \"identityIndex\",\n      get: function get() {\n        return this.storage.getNumber('Identity:Index', -1, true);\n      },\n      set: function set(value) {\n        this.storage.setValue('Identity:Index', value.toString(), true);\n      }\n    }, {\n      key: \"identities\",\n      get: function get() {\n        return this.identitiesSubject.getValue();\n      },\n      set: function set(val) {\n        this.identitiesSubject.next(val);\n      }\n    }, {\n      key: \"identity\",\n      get: function get() {\n        return this.identitySubject.getValue();\n      },\n      set: function set(val) {\n        this.identitySubject.next(val); // Persist the set identity as active identity.\n\n        this.storage.setValue('Identity', val.content.identifier, true);\n      }\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        this.identitiesSubject.next(this.identities);\n      }\n    }, {\n      key: \"load\",\n      value: function load() {\n        this.identities = this.loadIdentities();\n        this.identitySubject.next(this.loadIdentity()); // Make sure we set the current identity index, and simply use the current length if value is missing from before.\n        // this.identityIndex = this.storage.getNumber('Identity:Index', this.identities.length, true);\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        console.log('IdentityService instance destroyed.');\n      }\n    }, {\n      key: \"toBuffer\",\n      value: function toBuffer(ab) {\n        var buf = Buffer.alloc(ab.byteLength);\n        var view = new Uint8Array(ab);\n\n        for (var i = 0; i < buf.length; ++i) {\n          buf[i] = view[i];\n        }\n\n        return buf;\n      }\n    }, {\n      key: \"verifyPassword\",\n      value: function verifyPassword(password) {\n        var decryptedKey = bip38.decrypt(this.seed.encryptedSeed, password, null, null, this.appState.networkParams);\n        console.log(decryptedKey);\n      }\n    }, {\n      key: \"unlock\",\n      value: function unlock(path, password) {\n        // Read the seed from the file on disk.\n        var seed = this.electronService.ipcRenderer.sendSync('get-wallet-seed', path); // Keep a copy of the encrypted seed. For mobile mode, this will be available in the local storage / indexeddb.\n\n        this.seed = seed; // Descrypt the seed with the password provided on unlock (login).\n        // bip38.decryptAsync(seed.encryptedSeed, password, (decryptedKey) => {\n        // }, null, this.appState.networkParams);\n\n        var decryptedKey = bip38.decrypt(seed.encryptedSeed, password, null, null, this.appState.networkParams);\n        var chainCode = Buffer.from(seed.chainCode, 'base64'); // Dispose of this object, we don't want to keep the root extkey after initial login.\n\n        var masterNode = bip32.fromPrivateKey(decryptedKey.privateKey, chainCode, this.appState.networkDefinition); // eslint-disable-next-line @typescript-eslint/quotes\n\n        var identityRoot = masterNode.derivePath(\"m/302'\"); // Persist the identity node that we need to generate identities and keys for them.\n\n        this.identityRoot = identityRoot;\n        this.identityExtPubKey = identityRoot.neutered(); // Load identities after unlocking.\n\n        this.load();\n      }\n    }, {\n      key: \"getIdentityNode\",\n      value: function getIdentityNode(index) {\n        return this.identityRoot.deriveHardened(index);\n      }\n    }, {\n      key: \"getKey\",\n      value: function getKey(index) {\n        return this.identityRoot.deriveHardened(index);\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(document, index) {\n        var identity = this.getIdentityNode(index);\n        var jwt = Jws.encode(document, identity);\n        return jwt;\n      }\n    }, {\n      key: \"create\",\n      value: function create() {\n        // Get the next identity in line, based on what we have queries so far;\n        var identityNode = this.getIdentityNode(this.identityIndex + 1);\n        var identityId = this.getAddress(identityNode, this.identityNetwork);\n        var identity = new Identity();\n        identity.identifier = 'did:is:' + identityId;\n        identity.iat = Date.now();\n        var container = new IdentityContainer(identity);\n        container.header = null;\n        container.payload = null;\n        container.signature = null;\n        container.published = false;\n        container.publish = true;\n        container.index = this.identityIndex + 1; // We should not persist this new index until after we actually save it.\n\n        return container;\n      }\n      /** Add the identity locally and publish if both publish parameter is specified, and .publish on the identity. */\n\n    }, {\n      key: \"add\",\n      value: function add(identity) {\n        var publish = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var index = this.identities.findIndex(function (t) {\n          return t.content.identifier === identity.content.identifier;\n        }); // Upgrade the version to what we currently support.\n\n        identity.version = 3;\n\n        if (index === -1) {\n          // Ensure we create a new array and don't modify existing.\n          this.identities = [].concat(_toConsumableArray(this.identities), [identity]); // Increase the spent identity index.\n          // this.identityIndex++;\n        } else {\n          this.identities[index] = identity;\n        } // Now that we have added this new identity to the identities locally, make sure we register that the index is spent.\n\n\n        this.identityIndex = identity.index; // If publish is turned on, ensure we send our updated identity to one of the platform hubs.\n\n        if (publish && identity.publish) {\n          // Get the signature for the entity.\n          var jwt = this.sign(identity.content, identity.index);\n          var jwtValues = jwt.split('.');\n          identity.header = jwtValues[0];\n          identity.payload = jwtValues[1];\n          identity.signature = jwtValues[2];\n          var message = {\n            version: 4,\n            content: jwt\n          };\n          this.hubService.put(message, 'identity');\n        } // try {\n        //     const todo = await this.todosService\n        //         .create({ title, isCompleted: false })\n        //         .toPromise();\n        //     // we swap the local tmp record with the record from the server (id must be updated)\n        //     const index = this.todos.indexOf(this.todos.find(t => t.id === tmpId));\n        //     this.todos[index] = {\n        //         ...todo\n        //     }\n        //     this.todos = [...this.todos];\n        // } catch (e) {\n        //     // is server sends back an error, we revert the changes\n        //     console.error(e);\n        //     this.removeTodo(tmpId, false);\n        // }\n\n\n        this.saveIdentities();\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(id) {\n        var identity = this.identities.find(function (t) {\n          return t.content.identifier === id;\n        });\n        this.identities = this.identities.filter(function (i) {\n          return i.content.identifier !== id;\n        });\n\n        if (identity.published) {\n          // Save to service, then update again.\n          try {\n            // Reset the identity to an empty entity.\n            identity.content = new Identity();\n            identity.content.identifier = id;\n            identity.content.iat = Date.now();\n            identity.content['@state'] = 999; // Get the signature for the entity.\n\n            var jwt = this.sign(identity.content, identity.index);\n            var jwtValues = jwt.split('.');\n            identity.header = jwtValues[0];\n            identity.payload = jwtValues[1];\n            identity.signature = jwtValues[2];\n            var message = {\n              version: 4,\n              content: jwt\n            };\n            this.hubService.put(message, 'identity');\n          } catch (e) {\n            console.error(e); // Add the identity back to the collection again, we did not successfully delete it.\n\n            this.identities = [].concat(_toConsumableArray(this.identities), [identity]);\n          }\n        }\n\n        this.saveIdentities();\n      }\n    }, {\n      key: \"get\",\n      value: function get(id) {\n        var identity = this.identities.find(function (t) {\n          return t.content.identifier === id;\n        });\n        return identity;\n      }\n    }, {\n      key: \"getImage\",\n      value: function getImage(image) {\n        if (!image) {\n          image = 'data:image/png;base64,iVBORw0KGg' + 'oAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAU' + 'AAarVyFEAAAAASUVORK5CYII=';\n        }\n\n        return image;\n      }\n    }, {\n      key: \"find\",\n      value: function find(id) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var baseUrl, identityApiUrl;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  // const identityApiUrl = 'https://identity.city-chain.org/api/identity/' + id;\n                  baseUrl = this.hubService.getHub().content.url;\n                  console.log('baseUrl', baseUrl);\n                  identityApiUrl = baseUrl + '/api/identity/' + id;\n                  console.log('identityApiUrl', identityApiUrl); // const identityApiUrl = 'https://identity.city-chain.org/api/identity/' + id;\n                  // const identityApiUrl = 'http://localhost:4335/api/identity/' + id;\n\n                  _context.next = 6;\n                  return this.api(identityApiUrl);\n\n                case 6:\n                  return _context.abrupt(\"return\", _context.sent);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n      }\n      /** Get identities from localStorage. Only called during object creation. */\n\n    }, {\n      key: \"loadIdentities\",\n      value: function loadIdentities() {\n        // If there are no identities, populate with mock data.\n        var identities = this.storage.getJSON('Identities', '[]', true);\n\n        if (identities.length === 0) {\n          identities = this.initialize();\n        } // Return JSON serialized identities from localStorage.\n\n\n        return identities;\n      }\n      /** Get identity from localStorage. Only called during object creation. */\n\n    }, {\n      key: \"loadIdentity\",\n      value: function loadIdentity(id) {\n        var identityId = id || this.storage.getValue('Identity', null, true);\n        console.log('LOADING IDENTITY', identityId);\n        return this.identitiesSubject.getValue().find(function (i) {\n          return i.content.identifier === identityId;\n        });\n      }\n    }, {\n      key: \"saveIdentities\",\n      value: function saveIdentities() {\n        // Save the latest value from the subject into local storage.\n        this.storage.setJSON('Identities', this.identities, true);\n      } // setIdentity(id: string) {\n      //     this.settings.identity = id;\n      //     const identity = this.getIdentity(id);\n      //     this.identitySubject.next(identity);\n      // }\n      // setIdentities(identities: Identity[]) {\n      //     // Persist the identities.\n      //     this.settings.identities = identities;\n      //     // Call all subscribers with updated identities.\n      //     this.identitiesSubject.next(identities);\n      // }\n\n    }, {\n      key: \"api\",\n      value: function api(url) {\n        return fetch(url).then(function (response) {\n          if (!response.ok) {\n            throw new Error(response.statusText);\n          }\n\n          return response.json();\n        });\n      }\n    }, {\n      key: \"getAddress\",\n      value: function getAddress(node, network) {\n        return city.payments.p2pkh({\n          pubkey: node.publicKey,\n          network: network\n        }).address;\n      }\n    }, {\n      key: \"getId\",\n      value: function getId(index) {\n        var identity = this.getIdentityNode(index);\n        var address = this.getAddress(identity, this.identityNetwork);\n        return address;\n      }\n      /** Performs a query to find identity based on index number */\n\n    }, {\n      key: \"findByIndex\",\n      value: function findByIndex(index) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var identity, identityNode, identityId;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  identity = null;\n                  identityNode = this.getIdentityNode(index);\n                  identityId = this.getAddress(identityNode, this.identityNetwork);\n                  _context2.prev = 3;\n                  _context2.next = 6;\n                  return this.find(identityId);\n\n                case 6:\n                  identity = _context2.sent;\n\n                  if (identity) {\n                    // Update local state fo the container.\n                    identity.published = true;\n                    identity.publish = true;\n                    identity.index = index;\n                    this.add(identity, false);\n                  } // If the last found index is higher than previously known index height, make sure we save it.\n\n\n                  if (index > this.identityIndex) {\n                    this.identityIndex = index;\n                  }\n\n                  _context2.next = 13;\n                  break;\n\n                case 11:\n                  _context2.prev = 11;\n                  _context2.t0 = _context2[\"catch\"](3);\n\n                case 13:\n                  return _context2.abrupt(\"return\", identity);\n\n                case 14:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this, [[3, 11]]);\n        }));\n      }\n      /** Performs a scan of identities from index and number of coint. Returns true if anything is found. */\n      // async scan2(index: number, count: number) {\n      //     // Reset the scan index height.\n      //     // this.identityIndex = -1;\n      //     let found = false;\n      //     let lastFoundIndex = 0;\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      //     for (let i = index; i < count; i++) {\n      //         const identityNode = this.getIdentityNode(i);\n      //         const identityId = this.getAddress(identityNode, this.identityNetwork);\n      //         try {\n      //             const identity = await this.find(identityId);\n      //             if (identity) {\n      //                 this.add(identity);\n      //             }\n      //             console.log('FOUND!!!');\n      //             found = true;\n      //             lastFoundIndex = index;\n      //         }\n      //         catch (err) {\n      //             // console.log('Identity find result: ', err);\n      //         }\n      //     }\n      //     // If the last found index is higher than previously known index height, make sure we save it.\n      //     if (lastFoundIndex > this.identityIndex) {\n      //         this.identityIndex = lastFoundIndex;\n      //     }\n      //     return found;\n      // }\n\n    }, {\n      key: \"initialize\",\n      value: function initialize() {\n        return []; // return [{\n        //     name: 'Sondre Bjellås',\n        //     shortName: 'Sondre Bjellås',\n        //     alias: 'sondreb',\n        //     title: 'Public',\n        //     id: 'PJZZYTPq2Uf6LJRkdgTVZ4xgRBi3vZmpdf',\n        //     published: true,\n        //     locked: false,\n        //     time: new Date()\n        // }, {\n        //     name: 'SondreB',\n        //     shortname: 'SondreB',\n        //     alias: 'sondre',\n        //     title: 'Personal, Gaming',\n        //     id: 'PHnT3Fx1EN5uMBbYBivjDdkke3n2pb5svd',\n        //     published: true,\n        //     locked: false,\n        //     time: new Date()\n        // }, {\n        //     name: 'Sondre Bjellås',\n        //     shortname: 'Sondre Bjellås',\n        //     alias: 'citychainfoundation',\n        //     title: 'CTO, City Chain Foundation',\n        //     id: 'PXdMWVDaG1kmqbQX5JdsE5m4HFnRVxoqHf',\n        //     published: true,\n        //     locked: false,\n        //     time: new Date()\n        // }, {\n        //     name: 'New Identity',\n        //     shortname: 'New Identity',\n        //     alias: null,\n        //     title: 'Random',\n        //     id: 'PH99VjuZKX36CoKkXE4Z87BPKt2c4FyTwZ',\n        //     published: false,\n        //     locked: false,\n        //     time: new Date()\n        // }, {\n        //     name: 'Locked',\n        //     shortname: 'Locked',\n        //     alias: null,\n        //     title: '?',\n        //     id: 'PMzHABeaLVHP7kLDYFeHkE1CZaeS8wXvxv',\n        //     published: true,\n        //     locked: true,\n        //     time: new Date()\n        // }, {\n        //     name: 'Locked',\n        //     shortname: 'Locked',\n        //     alias: null,\n        //     title: '?',\n        //     id: 'PFfMFoJWHmHuQWfxoAmjgq7cqVxC9xTXfr',\n        //     published: false,\n        //     locked: true,\n        //     time: new Date()\n        // }];\n      }\n    }]);\n\n    return IdentityService;\n  }();\n\n  IdentityService.ɵfac = function IdentityService_Factory(t) {\n    return new (t || IdentityService)(i0.ɵɵinject(i1.ApplicationStateService), i0.ɵɵinject(i2.HubService), i0.ɵɵinject(i3.AuthenticationService), i0.ɵɵinject(i4.ElectronService), i0.ɵɵinject(i5.StorageService));\n  };\n\n  IdentityService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: IdentityService,\n    factory: IdentityService.ɵfac,\n    providedIn: 'root'\n  });\n  return IdentityService;\n})();","map":null,"metadata":{},"sourceType":"module"}