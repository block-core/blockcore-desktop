{"ast":null,"code":"const Buffer = require('safe-buffer').Buffer;\n\nconst bcrypto = require('./crypto');\n\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\n\nconst typeforce = require('typeforce');\n\nconst types = require('./types');\n\nconst varuint = require('varuint-bitcoin');\n\nvar bufferutils = require('./bufferutils');\n\nconst networks = require('./networks');\n\nconst Transaction = require('./transaction');\n\nfunction Block() {\n  this.version = 1;\n  this.prevHash = null;\n  this.merkleRoot = null;\n  this.timestamp = 0;\n  this.bits = 0;\n  this.nonce = 0;\n}\n\nBlock.fromBuffer = function (buffer, network) {\n  network = network || networks.bitcoin;\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n  let offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt32() {\n    const i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    const i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  const block = new Block();\n  block.version = readInt32();\n  block.prevHash = readSlice(32);\n  block.merkleRoot = readSlice(32);\n  block.timestamp = readUInt32();\n  block.bits = readUInt32();\n  block.nonce = readUInt32();\n  if (buffer.length === 80) return block;\n\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readTransaction() {\n    const tx = Transaction.fromBuffer(buffer.slice(offset), true, network);\n    offset += tx.byteLength();\n    return tx;\n  }\n\n  const nTransactions = readVarInt();\n  block.transactions = [];\n\n  for (var i = 0; i < nTransactions; ++i) {\n    const tx = readTransaction();\n    block.transactions.push(tx);\n  } // Read block signature (vchBlockSig) for PoS coins.\n\n\n  block.blockSig = null;\n\n  if (offset < buffer.length) {\n    var blockSigSize = readVarInt();\n    block.blockSig = readSlice(blockSigSize);\n  }\n\n  return block;\n};\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80;\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength();\n  }, 0);\n};\n\nBlock.fromHex = function (hex, network) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true));\n};\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex');\n};\n\nBlock.prototype.getUTCDate = function () {\n  const date = new Date(0); // epoch\n\n  date.setUTCSeconds(this.timestamp);\n  return date;\n}; // TODO: buffer, offset compatibility\n\n\nBlock.prototype.toBuffer = function (headersOnly) {\n  const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n  let offset = 0;\n\n  function writeSlice(slice) {\n    slice.copy(buffer, offset);\n    offset += slice.length;\n  }\n\n  function writeInt32(i) {\n    buffer.writeInt32LE(i, offset);\n    offset += 4;\n  }\n\n  function writeUInt32(i) {\n    buffer.writeUInt32LE(i, offset);\n    offset += 4;\n  }\n\n  writeInt32(this.version);\n  writeSlice(this.prevHash);\n  writeSlice(this.merkleRoot);\n  writeUInt32(this.timestamp);\n  writeUInt32(this.bits);\n  writeUInt32(this.nonce);\n  if (headersOnly || !this.transactions) return buffer;\n  varuint.encode(this.transactions.length, buffer, offset);\n  offset += varuint.encode.bytes;\n  this.transactions.forEach(function (tx) {\n    const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n    tx.toBuffer(buffer, offset);\n    offset += txSize;\n  }); // Block Signature.\n\n  if (this.blockSig) {\n    var blockSigLenBuffer = bufferutils.varIntBuffer(this.blockSig.length);\n    return Buffer.concat([buffer, blockSigLenBuffer, this.blockSig]);\n  }\n\n  return buffer;\n};\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex');\n};\n\nBlock.calculateTarget = function (bits) {\n  const exponent = ((bits & 0xff000000) >> 24) - 3;\n  const mantissa = bits & 0x007fffff;\n  const target = Buffer.alloc(32, 0);\n  target.writeUIntBE(mantissa, 29 - exponent, 3);\n  return target;\n};\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{\n    getHash: types.Function\n  }], transactions);\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions');\n  const hashes = transactions.map(function (transaction) {\n    return transaction.getHash();\n  });\n  return fastMerkleRoot(hashes, bcrypto.hash256);\n};\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false;\n  const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n  return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\n\nBlock.prototype.checkProofOfWork = function () {\n  const hash = this.getHash().reverse();\n  const target = Block.calculateTarget(this.bits);\n  return hash.compare(target) <= 0;\n};\n\nmodule.exports = Block;","map":null,"metadata":{},"sourceType":"script"}