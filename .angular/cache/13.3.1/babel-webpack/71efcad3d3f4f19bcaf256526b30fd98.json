{"ast":null,"code":"import _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _toConsumableArray from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\n\n/* eslint-disable */\nexport function isUndefined(value) {\n  return typeof value === 'undefined';\n}\nexport function isNull(value) {\n  return value === null;\n}\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\nexport function isNumberFinite(value) {\n  return isNumber(value) && isFinite(value);\n} // Not strict positive\n\nexport function isPositive(value) {\n  return value >= 0;\n}\nexport function isInteger(value) {\n  // No rest, is an integer\n  return value % 1 === 0;\n}\nexport function isNil(value) {\n  return value === null || typeof value === 'undefined';\n}\nexport function isString(value) {\n  return typeof value === 'string';\n}\nexport function isObject(value) {\n  return value !== null && typeof value === 'object';\n}\nexport function isArray(value) {\n  return Array.isArray(value);\n}\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\nexport function toDecimal(value, decimal) {\n  return Math.round(value * Math.pow(10, decimal)) / Math.pow(10, decimal);\n}\nexport function upperFirst(value) {\n  return value.slice(0, 1).toUpperCase() + value.slice(1);\n}\nexport function createRound(method) {\n  // <any>Math to suppress error\n  var func = Math[method];\n  return function (value) {\n    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (typeof value === 'string') {\n      throw new TypeError('Rounding method needs a number');\n    }\n\n    if (typeof precision !== 'number' || isNaN(precision)) {\n      precision = 0;\n    }\n\n    if (precision) {\n      var pair = \"\".concat(value, \"e\").split('e');\n      var val = func(\"\".concat(pair[0], \"e\") + (+pair[1] + precision));\n      pair = \"\".concat(val, \"e\").split('e');\n      return +(pair[0] + 'e' + (+pair[1] - precision));\n    }\n\n    return func(value);\n  };\n}\nexport function leftPad(str) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';\n  str = String(str);\n  ch = toString(ch);\n  var i = -1;\n  var length = len - str.length;\n\n  while (++i < length && str.length + ch.length <= len) {\n    str = ch + str;\n  }\n\n  return str;\n}\nexport function rightPad(str) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';\n  str = String(str);\n  ch = toString(ch);\n  var i = -1;\n  var length = len - str.length;\n\n  while (++i < length && str.length + ch.length <= len) {\n    str += ch;\n  }\n\n  return str;\n}\nexport function toString(value) {\n  return \"\".concat(value);\n}\nexport function pad(str) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';\n  str = String(str);\n  ch = toString(ch);\n  var i = -1;\n  var length = len - str.length;\n  var left = true;\n\n  while (++i < length) {\n    var l = str.length + ch.length <= len ? str.length + ch.length : str.length + 1;\n\n    if (left) {\n      str = leftPad(str, l, ch);\n    } else {\n      str = rightPad(str, l, ch);\n    }\n\n    left = !left;\n  }\n\n  return str;\n}\nexport function flatten(input) {\n  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (index >= input.length) {\n    return input;\n  }\n\n  if (isArray(input[index])) {\n    return flatten(input.slice(0, index).concat(input[index], input.slice(index + 1)), index);\n  }\n\n  return flatten(input, index + 1);\n}\nexport function getProperty(value, key) {\n  if (isNil(value) || !isObject(value)) {\n    return undefined;\n  }\n\n  var keys = key.split('.');\n  var result = value[keys.shift()];\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _key = _step.value;\n\n      if (isNil(result) || !isObject(result)) {\n        return undefined;\n      }\n\n      result = result[_key];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n}\nexport function sum(input) {\n  var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return input.reduce(function (previous, current) {\n    return previous + current;\n  }, initial);\n} // http://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array-in-javascript\n\nexport function shuffle(input) {\n  if (!isArray(input)) {\n    return input;\n  }\n\n  var copy = _toConsumableArray(input);\n\n  for (var i = copy.length; i; --i) {\n    var j = Math.floor(Math.random() * i);\n    var x = copy[i - 1];\n    copy[i - 1] = copy[j];\n    copy[j] = x;\n  }\n\n  return copy;\n}\nexport function deepIndexOf(collection, value) {\n  var index = -1;\n  var length = collection.length;\n\n  while (++index < length) {\n    if (deepEqual(value, collection[index])) {\n      return index;\n    }\n  }\n\n  return -1;\n}\nexport function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!(typeof a === 'object' && typeof b === 'object')) {\n    return a === b;\n  }\n\n  var keysA = Object.keys(a);\n  var keysB = Object.keys(b);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  for (var i = 0; i < keysA.length; i++) {\n    var key = keysA[i];\n\n    if (!hasOwn.call(b, keysA[i]) || !deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function isDeepObject(object) {\n  return object.__isDeepObject__;\n}\nexport function wrapDeep(object) {\n  return new DeepWrapper(object);\n}\nexport function unwrapDeep(object) {\n  if (isDeepObject(object)) {\n    return object.data;\n  }\n\n  return object;\n}\nexport var DeepWrapper = /*#__PURE__*/_createClass(function DeepWrapper(data) {\n  _classCallCheck(this, DeepWrapper);\n\n  this.data = data;\n  this.__isDeepObject__ = true;\n});\nexport function count(input) {\n  if (!isArray(input) && !isObject(input) && !isString(input)) {\n    return input;\n  }\n\n  if (isObject(input)) {\n    return Object.keys(input).map(function (value) {\n      return input[value];\n    }).length;\n  }\n\n  return input.length;\n}\nexport function empty(input) {\n  if (!isArray(input)) {\n    return input;\n  }\n\n  return input.length === 0;\n}\nexport function every(input, predicate) {\n  if (!isArray(input) || !predicate) {\n    return input;\n  }\n\n  var result = true;\n  var i = -1;\n\n  while (++i < input.length && result) {\n    result = predicate(input[i], i, input);\n  }\n\n  return result;\n}\nexport function takeUntil(input, predicate) {\n  var i = -1;\n  var result = [];\n\n  while (++i < input.length && !predicate(input[i], i, input)) {\n    result[i] = input[i];\n  }\n\n  return result;\n}\nexport function takeWhile(input, predicate) {\n  return takeUntil(input, function (item, index, collection) {\n    return !predicate(item, index, collection);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}