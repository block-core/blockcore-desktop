{"ast":null,"code":"var lazy = require('./lazy');\n\nvar typef = require('typeforce');\n\nvar OPS = require('bitcoin-ops');\n\nvar bscript = require('../script');\n\nvar BITCOIN_NETWORK = require('../networks').bitcoin;\n\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every(function (x, i) {\n    return x.equals(b[i]);\n  });\n} // output: OP_RETURN ...\n\n\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({\n    validate: true\n  }, opts || {});\n  typef({\n    network: typef.maybe(typef.Object),\n    output: typef.maybe(typef.Buffer),\n    data: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a);\n  var network = a.network || BITCOIN_NETWORK;\n  var o = {\n    network: network\n  };\n  lazy.prop(o, 'output', function () {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', function () {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  }); // extended validation\n\n  if (opts.validate) {\n    if (a.output) {\n      var chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer)) throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data)) throw new TypeError('Data mismatch');\n    }\n  }\n\n  return Object.assign(o, a);\n}\n\nmodule.exports = p2data;","map":null,"metadata":{},"sourceType":"script"}