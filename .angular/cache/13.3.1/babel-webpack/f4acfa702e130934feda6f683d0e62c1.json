{"ast":null,"code":"import _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport base64url from 'base64url'; // Should we replicate this code to avoid dependency? It's a very simple utility.\n\nimport utf8 from 'utf8';\nimport * as city from 'city-lib';\nimport * as blockcoreMessage from '@blockcore/message';\n/*\r\n    Blockcore-Jose-JS\r\n    Blockcore Javascript Object Signing and Encryption (JOSE) for JavaScript\r\n\r\n    NOTE: Currently only supports ES256K, refer to other implementations (e.g. jsrsasign) for additional algorithms.\r\n\r\n    - Encodes either a JavaScript object or string into a JWT.\r\n    - Supports requirement of signature, and reading the key from \"kid\" in header.\r\n\r\n    Future improvements:\r\n\r\n    - JSON Web Encryption (JWE)\r\n    - JSON Web Key (JWK)\r\n    - JSON Web Key Set (JWKS)\r\n    - JSON Web Signature (JWS) (DONE)\r\n    - JSON Web Token (JWT)\r\n\r\n    .NET version: https://github.com/block-core/blockcore-jose\r\n*/\n\nexport var Jws = /*#__PURE__*/(function () {\n  var Jws = /*#__PURE__*/function () {\n    function Jws() {\n      _classCallCheck(this, Jws);\n    }\n\n    _createClass(Jws, null, [{\n      key: \"encode\",\n      value: function encode(payload, identity) {\n        var payloadText;\n\n        if (typeof payload === 'string' || payload instanceof String) {\n          payloadText = payload;\n        } else {\n          payloadText = JSON.stringify(payload);\n        }\n\n        var publicKey = this.getAddress(identity, this.identityNetwork);\n        var header = {\n          alg: 'ES256K',\n          typ: 'JWT',\n          kid: publicKey\n        };\n        var headerText = JSON.stringify(header); // Header is first encoded to UTF-8 then base64url encoded, while payload is encoded directly to base64url. This is according to the specification.\n\n        var message = base64url.encode(utf8.encode(headerText)) + '.' + base64url.encode(payloadText);\n        var signature = blockcoreMessage.sign(message, identity.privateKey, true, '');\n        message += '.' + base64url.encode(signature);\n        return message;\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(payload, secret) {\n        var payloadText;\n\n        if (typeof payload === 'string' || payload instanceof String) {\n          payloadText = payload;\n        } else {\n          payloadText = JSON.stringify(payload);\n        }\n\n        var header = {\n          alg: 'ES256K',\n          typ: 'JWT',\n          kid: secret\n        };\n        var headerText = JSON.stringify(header); // Header is first encoded to UTF-8 then base64url encoded, while payload is encoded directly to base64url. This is according to the specification.\n\n        var message = base64url.encode(utf8.encode(headerText)) + '.' + base64url.encode(payloadText) + '.';\n        return message;\n      }\n    }, {\n      key: \"decode\",\n      value: function decode(payload) {\n        var header = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var requireSignature = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var matchResult = payload.match(/^([^.]+)\\.([^.]+)\\.([^.]+)$/);\n\n        if (matchResult == null) {\n          throw new Error('JWS payload is not in correct format of \\'Header.Payload.Signature\\'.');\n        }\n\n        var values = payload.split('.'); // Validate that there is a signature and that it's valid.\n\n        if (requireSignature === true) {}\n\n        if (header === true) {\n          var decoded = base64url.decode(utf8.decode(values[0]));\n          var json = JSON.parse(decoded);\n          return json;\n        } else {\n          var _decoded = base64url.decode(values[1]);\n\n          var _json = JSON.parse(_decoded);\n\n          return _json;\n        }\n      }\n    }, {\n      key: \"getAddress\",\n      value: function getAddress(node, network) {\n        return city.payments.p2pkh({\n          pubkey: node.publicKey,\n          network: network\n        }).address;\n      }\n    }]);\n\n    return Jws;\n  }();\n\n  Jws.identityNetwork = {\n    pubKeyHash: 55,\n    scriptHash: 117\n  };\n  return Jws;\n})();","map":null,"metadata":{},"sourceType":"module"}