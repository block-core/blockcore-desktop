{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst createHash = require(\"create-hash\");\n\nconst pbkdf2_1 = require(\"pbkdf2\");\n\nconst randomBytes = require(\"randombytes\");\n\nconst _wordlists_1 = require(\"./_wordlists\");\n\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please pass a 2048 word array explicitly.';\n\nfunction pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {\n  return Promise.resolve().then(() => new Promise((resolve, reject) => {\n    const callback = (err, derivedKey) => {\n      if (err) {\n        return reject(err);\n      } else {\n        return resolve(derivedKey);\n      }\n    };\n\n    pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);\n  }));\n}\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction lpad(str, padString, length) {\n  while (str.length < length) {\n    str = padString + str;\n  }\n\n  return str;\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\n\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\n\nfunction mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n  const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n  return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\n\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n\nfunction mnemonicToSeed(mnemonic, password) {\n  return Promise.resolve().then(() => {\n    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n    return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n  });\n}\n\nexports.mnemonicToSeed = mnemonicToSeed;\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n\n  const words = normalize(mnemonic).split(' ');\n\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  } // convert word indices to 11 bit binary strings\n\n\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n\n    return lpad(index.toString(2), '0', 11);\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n\n  if (entropyBytes.length < 16) {\n    throw new Error(INVALID_ENTROPY);\n  }\n\n  if (entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n\n  if (entropyBytes.length % 4 !== 0) {\n    throw new Error(INVALID_ENTROPY);\n  }\n\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n\n  if (newChecksum !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n\n  return entropy.toString('hex');\n}\n\nexports.mnemonicToEntropy = mnemonicToEntropy;\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) {\n    entropy = Buffer.from(entropy, 'hex');\n  }\n\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  } // 128 <= ENT <= 256\n\n\n  if (entropy.length < 16) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  if (entropy.length > 32) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  if (entropy.length % 4 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy);\n  const bits = entropyBits + checksumBits;\n  const chunks = bits.match(/(.{1,11})/g);\n  const words = chunks.map(binary => {\n    const index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n  ? words.join('\\u3000') : words.join(' ');\n}\n\nexports.entropyToMnemonic = entropyToMnemonic;\n\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n\n  if (strength % 32 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\n\nexports.generateMnemonic = generateMnemonic;\n\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.validateMnemonic = validateMnemonic;\n\nfunction setDefaultWordlist(language) {\n  const result = _wordlists_1.wordlists[language];\n\n  if (result) {\n    DEFAULT_WORDLIST = result;\n  } else {\n    throw new Error('Could not find wordlist for language \"' + language + '\"');\n  }\n}\n\nexports.setDefaultWordlist = setDefaultWordlist;\n\nfunction getDefaultWordlist() {\n  if (!DEFAULT_WORDLIST) {\n    throw new Error('No Default Wordlist set');\n  }\n\n  return Object.keys(_wordlists_1.wordlists).filter(lang => {\n    if (lang === 'JA' || lang === 'EN') {\n      return false;\n    }\n\n    return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n  })[0];\n}\n\nexports.getDefaultWordlist = getDefaultWordlist;\n\nvar _wordlists_2 = require(\"./_wordlists\");\n\nexports.wordlists = _wordlists_2.wordlists;","map":null,"metadata":{},"sourceType":"script"}