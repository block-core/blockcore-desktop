{"ast":null,"code":"const bs58check = require('bs58check');\n\nconst bech32 = require('bech32');\n\nconst bufferEquals = require('buffer-equals');\n\nconst createHash = require('create-hash');\n\nconst secp256k1 = require('secp256k1');\n\nconst varuint = require('varuint-bitcoin');\n\nconst SEGWIT_TYPES = {\n  P2WPKH: 'p2wpkh',\n  P2SH_P2WPKH: 'p2sh(p2wpkh)'\n};\n\nfunction sha256(b) {\n  return createHash('sha256').update(b).digest();\n}\n\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\n\nfunction hash160(buffer) {\n  return createHash('ripemd160').update(sha256(buffer)).digest();\n}\n\nfunction encodeSignature(signature, recovery, compressed, segwitType) {\n  if (segwitType !== undefined) {\n    recovery += 8;\n    if (segwitType === SEGWIT_TYPES.P2WPKH) recovery += 4;\n  } else {\n    if (compressed) recovery += 4;\n  }\n\n  return Buffer.concat([Buffer.alloc(1, recovery + 27), signature]);\n}\n\nfunction decodeSignature(buffer) {\n  if (buffer.length !== 65) throw new Error('Invalid signature length');\n  const flagByte = buffer.readUInt8(0) - 27;\n\n  if (flagByte > 15 || flagByte < 0) {\n    throw new Error('Invalid signature parameter');\n  }\n\n  return {\n    compressed: !!(flagByte & 12),\n    segwitType: !(flagByte & 8) ? null : !(flagByte & 4) ? SEGWIT_TYPES.P2SH_P2WPKH : SEGWIT_TYPES.P2WPKH,\n    recovery: flagByte & 3,\n    signature: buffer.slice(1)\n  };\n}\n\nfunction magicHash(message, messagePrefix) {\n  if (!Buffer.isBuffer(message)) {\n    message = Buffer.from(message, 'utf8');\n  }\n\n  if (messagePrefix !== '') {\n    messagePrefix = messagePrefix || '\\u0018Bitcoin Signed Message:\\n';\n\n    if (!Buffer.isBuffer(messagePrefix)) {\n      messagePrefix = Buffer.from(messagePrefix, 'utf8');\n    }\n\n    const messageVISize = varuint.encodingLength(message.length);\n    const buffer = Buffer.allocUnsafe(messagePrefix.length + messageVISize + message.length);\n    messagePrefix.copy(buffer, 0);\n    varuint.encode(message.length, buffer, messagePrefix.length);\n    message.copy(buffer, messagePrefix.length + messageVISize);\n    return hash256(buffer);\n  } else {\n    return hash256(message);\n  }\n}\n\nfunction sign(message, privateKey, compressed, messagePrefix, sigOptions) {\n  if (typeof messagePrefix === 'object' && sigOptions === undefined) {\n    sigOptions = messagePrefix;\n    messagePrefix = undefined;\n  }\n\n  let {\n    segwitType,\n    extraEntropy\n  } = sigOptions || {};\n\n  if (segwitType && (typeof segwitType === 'string' || segwitType instanceof String)) {\n    segwitType = segwitType.toLowerCase();\n  }\n\n  if (segwitType && segwitType !== SEGWIT_TYPES.P2SH_P2WPKH && segwitType !== SEGWIT_TYPES.P2WPKH) {\n    throw new Error('Unrecognized segwitType: use \"' + SEGWIT_TYPES.P2SH_P2WPKH + '\" or \"' + SEGWIT_TYPES.P2WPKH + '\"');\n  }\n\n  const hash = magicHash(message, messagePrefix);\n  const sigObj = secp256k1.sign(hash, privateKey, {\n    data: extraEntropy\n  });\n  return encodeSignature(sigObj.signature, sigObj.recovery, compressed, segwitType);\n}\n\nfunction verify(message, address, signature, messagePrefix) {\n  if (!Buffer.isBuffer(signature)) signature = Buffer.from(signature, 'base64');\n  const parsed = decodeSignature(signature);\n  const hash = magicHash(message, messagePrefix);\n  const publicKey = secp256k1.recover(hash, parsed.signature, parsed.recovery, parsed.compressed);\n  const publicKeyHash = hash160(publicKey);\n  let actual, expected;\n\n  if (parsed.segwitType) {\n    if (parsed.segwitType === SEGWIT_TYPES.P2SH_P2WPKH) {\n      const redeemScript = Buffer.concat([Buffer.from('0014', 'hex'), publicKeyHash]);\n      const redeemScriptHash = hash160(redeemScript);\n      actual = redeemScriptHash;\n      expected = bs58check.decode(address).slice(1);\n    } else if (parsed.segwitType === SEGWIT_TYPES.P2WPKH) {\n      const result = bech32.decode(address);\n      const data = bech32.fromWords(result.words.slice(1));\n      actual = publicKeyHash;\n      expected = Buffer.from(data);\n    }\n  } else {\n    actual = publicKeyHash;\n    expected = bs58check.decode(address).slice(1);\n  }\n\n  return bufferEquals(actual, expected);\n}\n\nmodule.exports = {\n  magicHash: magicHash,\n  sign: sign,\n  verify: verify\n};","map":null,"metadata":{},"sourceType":"script"}