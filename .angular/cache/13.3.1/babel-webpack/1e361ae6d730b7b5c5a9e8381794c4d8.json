{"ast":null,"code":"import _assertThisInitialized from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\assertThisInitialized.js\";\nimport _inherits from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _classCallCheck from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Github\\\\Miladsoft\\\\blockcore-hub-1\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport * as i0 from '@angular/core';\nimport { Component, Optional, Self, Input, HostBinding, HostListener, InjectionToken, Pipe, Inject, NgModule } from '@angular/core';\nimport * as i1 from '@angular/cdk/a11y';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i2 from '@angular/material/core';\nimport { mixinErrorState } from '@angular/material/core';\nimport * as i3 from '@angular/forms';\n/**\n * The files to be uploaded\n */\n\nvar FileInput = /*#__PURE__*/function () {\n  function FileInput(_files) {\n    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ', ';\n\n    _classCallCheck(this, FileInput);\n\n    this._files = _files;\n    this.delimiter = delimiter;\n    this._fileNames = (this._files || []).map(function (f) {\n      return f.name;\n    }).join(delimiter);\n  }\n\n  _createClass(FileInput, [{\n    key: \"files\",\n    get: function get() {\n      return this._files || [];\n    }\n  }, {\n    key: \"fileNames\",\n    get: function get() {\n      return this._fileNames;\n    }\n  }]);\n\n  return FileInput;\n}(); // Boilerplate for applying mixins to FileInput\n\n/** @docs-private */\n\n\nvar FileInputBase = /*#__PURE__*/_createClass(function FileInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n  _classCallCheck(this, FileInputBase);\n\n  this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n  this._parentForm = _parentForm;\n  this._parentFormGroup = _parentFormGroup;\n  this.ngControl = ngControl;\n});\n/**\n * Allows to use a custom ErrorStateMatcher with the file-input component\n */\n\n\nvar FileInputMixinBase = mixinErrorState(FileInputBase);\nvar FileInputComponent = /*#__PURE__*/(function () {\n  var FileInputComponent = /*#__PURE__*/function (_FileInputMixinBase) {\n    _inherits(FileInputComponent, _FileInputMixinBase);\n\n    var _super = _createSuper(FileInputComponent);\n\n    /**\n     * @see https://angular.io/api/forms/ControlValueAccessor\n     */\n    function FileInputComponent(fm, _elementRef, _renderer, _defaultErrorStateMatcher, ngControl, _parentForm, _parentFormGroup) {\n      var _this;\n\n      _classCallCheck(this, FileInputComponent);\n\n      _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n      _this.fm = fm;\n      _this._elementRef = _elementRef;\n      _this._renderer = _renderer;\n      _this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n      _this.ngControl = ngControl;\n      _this._parentForm = _parentForm;\n      _this._parentFormGroup = _parentFormGroup;\n      _this.focused = false;\n      _this.controlType = 'file-input';\n      _this.autofilled = false;\n      _this._required = false;\n      _this.accept = null;\n      _this.id = \"ngx-mat-file-input-\".concat(FileInputComponent.nextId++);\n      _this.describedBy = '';\n\n      _this._onChange = function (_) {};\n\n      _this._onTouched = function () {};\n\n      if (_this.ngControl != null) {\n        _this.ngControl.valueAccessor = _assertThisInitialized(_this);\n      }\n\n      fm.monitor(_elementRef.nativeElement, true).subscribe(function (origin) {\n        _this.focused = !!origin;\n\n        _this.stateChanges.next();\n      });\n      return _this;\n    }\n\n    _createClass(FileInputComponent, [{\n      key: \"setDescribedByIds\",\n      value: function setDescribedByIds(ids) {\n        this.describedBy = ids.join(' ');\n      }\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this.empty ? null : new FileInput(this._elementRef.nativeElement.value || []);\n      },\n      set: function set(fileInput) {\n        if (fileInput) {\n          this.writeValue(fileInput);\n          this.stateChanges.next();\n        }\n      }\n    }, {\n      key: \"multiple\",\n      get: function get() {\n        return this._multiple;\n      },\n      set: function set(value) {\n        this._multiple = coerceBooleanProperty(value);\n        this.stateChanges.next();\n      }\n    }, {\n      key: \"placeholder\",\n      get: function get() {\n        return this._placeholder;\n      },\n      set: function set(plh) {\n        this._placeholder = plh;\n        this.stateChanges.next();\n      }\n      /**\n       * Whether the current input has files\n       */\n\n    }, {\n      key: \"empty\",\n      get: function get() {\n        return !this._elementRef.nativeElement.value || this._elementRef.nativeElement.value.length === 0;\n      }\n    }, {\n      key: \"shouldLabelFloat\",\n      get: function get() {\n        return this.focused || !this.empty || this.valuePlaceholder !== undefined;\n      }\n    }, {\n      key: \"required\",\n      get: function get() {\n        return this._required;\n      },\n      set: function set(req) {\n        this._required = coerceBooleanProperty(req);\n        this.stateChanges.next();\n      }\n    }, {\n      key: \"isDisabled\",\n      get: function get() {\n        return this.disabled;\n      }\n    }, {\n      key: \"disabled\",\n      get: function get() {\n        return this._elementRef.nativeElement.disabled;\n      },\n      set: function set(dis) {\n        this.setDisabledState(coerceBooleanProperty(dis));\n        this.stateChanges.next();\n      }\n    }, {\n      key: \"onContainerClick\",\n      value: function onContainerClick(event) {\n        if (event.target.tagName.toLowerCase() !== 'input' && !this.disabled) {\n          this._elementRef.nativeElement.querySelector('input').focus();\n\n          this.focused = true;\n          this.open();\n        }\n      }\n    }, {\n      key: \"fileNames\",\n      get: function get() {\n        return this.value ? this.value.fileNames : this.valuePlaceholder;\n      }\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(obj) {\n        this._renderer.setProperty(this._elementRef.nativeElement, 'value', obj instanceof FileInput ? obj.files : null);\n      }\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this._onChange = fn;\n      }\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this._onTouched = fn;\n      }\n      /**\n       * Remove all files from the file input component\n       * @param [event] optional event that may have triggered the clear action\n       */\n\n    }, {\n      key: \"clear\",\n      value: function clear(event) {\n        if (event) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n\n        this.value = new FileInput([]);\n        this._elementRef.nativeElement.querySelector('input').value = null;\n\n        this._onChange(this.value);\n      }\n    }, {\n      key: \"change\",\n      value: function change(event) {\n        var fileList = event.target.files;\n        var fileArray = [];\n\n        if (fileList) {\n          for (var i = 0; i < fileList.length; i++) {\n            fileArray.push(fileList[i]);\n          }\n        }\n\n        this.value = new FileInput(fileArray);\n\n        this._onChange(this.value);\n      }\n    }, {\n      key: \"blur\",\n      value: function blur() {\n        this.focused = false;\n\n        this._onTouched();\n      }\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.multiple = coerceBooleanProperty(this.multiple);\n      }\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (!this.disabled) {\n          this._elementRef.nativeElement.querySelector('input').click();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stateChanges.complete();\n        this.fm.stopMonitoring(this._elementRef.nativeElement);\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        if (this.ngControl) {\n          // We need to re-evaluate this on every change detection cycle, because there are some\n          // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n          // that whatever logic is in here has to be super lean or we risk destroying the performance.\n          this.updateErrorState();\n        }\n      }\n    }]);\n\n    return FileInputComponent;\n  }(FileInputMixinBase);\n\n  FileInputComponent.nextId = 0;\n\n  FileInputComponent.ɵfac = function FileInputComponent_Factory(t) {\n    return new (t || FileInputComponent)(i0.ɵɵdirectiveInject(i1.FocusMonitor), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i2.ErrorStateMatcher), i0.ɵɵdirectiveInject(i3.NgControl, 10), i0.ɵɵdirectiveInject(i3.NgForm, 8), i0.ɵɵdirectiveInject(i3.FormGroupDirective, 8));\n  };\n\n  FileInputComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FileInputComponent,\n    selectors: [[\"ngx-mat-file-input\"]],\n    hostVars: 6,\n    hostBindings: function FileInputComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"change\", function FileInputComponent_change_HostBindingHandler($event) {\n          return ctx.change($event);\n        })(\"focusout\", function FileInputComponent_focusout_HostBindingHandler() {\n          return ctx.blur();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.id);\n        i0.ɵɵattribute(\"aria-describedby\", ctx.describedBy);\n        i0.ɵɵclassProp(\"mat-form-field-should-float\", ctx.shouldLabelFloat)(\"file-input-disabled\", ctx.isDisabled);\n      }\n    },\n    inputs: {\n      autofilled: \"autofilled\",\n      valuePlaceholder: \"valuePlaceholder\",\n      accept: \"accept\",\n      errorStateMatcher: \"errorStateMatcher\",\n      value: \"value\",\n      multiple: \"multiple\",\n      placeholder: \"placeholder\",\n      required: \"required\",\n      disabled: \"disabled\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: MatFormFieldControl,\n      useExisting: FileInputComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 4,\n    consts: [[\"type\", \"file\"], [\"input\", \"\"], [1, \"filename\", 3, \"title\"]],\n    template: function FileInputComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"input\", 0, 1);\n        i0.ɵɵelementStart(2, \"span\", 2);\n        i0.ɵɵtext(3);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"multiple\", ctx.multiple ? \"\" : null)(\"accept\", ctx.accept);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"title\", ctx.fileNames);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.fileNames);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:inline-block;width:100%}[_nghost-%COMP%]:not(.file-input-disabled){cursor:pointer}input[_ngcontent-%COMP%]{width:0px;height:0px;opacity:0;overflow:hidden;position:absolute;z-index:-1}.filename[_ngcontent-%COMP%]{display:inline-block;text-overflow:ellipsis;overflow:hidden;width:100%}\"]\n  });\n  return FileInputComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Optional token to provide custom configuration to the module\n */\n\n\nvar NGX_MAT_FILE_INPUT_CONFIG = new InjectionToken('ngx-mat-file-input.config');\nvar ByteFormatPipe = /*#__PURE__*/(function () {\n  var ByteFormatPipe = /*#__PURE__*/function () {\n    function ByteFormatPipe(config) {\n      _classCallCheck(this, ByteFormatPipe);\n\n      this.config = config;\n      this.unit = config ? config.sizeUnit : 'Byte';\n    }\n\n    _createClass(ByteFormatPipe, [{\n      key: \"transform\",\n      value: function transform(value, args) {\n        if (parseInt(value, 10) >= 0) {\n          value = this.formatBytes(+value, +args);\n        }\n\n        return value;\n      }\n    }, {\n      key: \"formatBytes\",\n      value: function formatBytes(bytes, decimals) {\n        if (bytes === 0) {\n          return '0 ' + this.unit;\n        }\n\n        var B = this.unit.charAt(0);\n        var k = 1024;\n        var dm = decimals || 2;\n        var sizes = [this.unit, 'K' + B, 'M' + B, 'G' + B, 'T' + B, 'P' + B, 'E' + B, 'Z' + B, 'Y' + B];\n        var i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n      }\n    }]);\n\n    return ByteFormatPipe;\n  }();\n\n  ByteFormatPipe.ɵfac = function ByteFormatPipe_Factory(t) {\n    return new (t || ByteFormatPipe)(i0.ɵɵdirectiveInject(NGX_MAT_FILE_INPUT_CONFIG, 24));\n  };\n\n  ByteFormatPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"byteFormat\",\n    type: ByteFormatPipe,\n    pure: true\n  });\n  return ByteFormatPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar MaterialFileInputModule = /*#__PURE__*/(function () {\n  var MaterialFileInputModule = /*#__PURE__*/_createClass(function MaterialFileInputModule() {\n    _classCallCheck(this, MaterialFileInputModule);\n  });\n\n  MaterialFileInputModule.ɵfac = function MaterialFileInputModule_Factory(t) {\n    return new (t || MaterialFileInputModule)();\n  };\n\n  MaterialFileInputModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MaterialFileInputModule\n  });\n  MaterialFileInputModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [FocusMonitor]\n  });\n  return MaterialFileInputModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar FileValidator = /*#__PURE__*/function () {\n  function FileValidator() {\n    _classCallCheck(this, FileValidator);\n  }\n\n  _createClass(FileValidator, null, [{\n    key: \"maxContentSize\",\n    value:\n    /**\n     * Function to control content of files\n     *\n     * @param bytes max number of bytes allowed\n     *\n     * @returns\n     */\n    function maxContentSize(bytes) {\n      return function (control) {\n        var size = control && control.value ? control.value.files.map(function (f) {\n          return f.size;\n        }).reduce(function (acc, i) {\n          return acc + i;\n        }, 0) : 0;\n        var condition = bytes >= size;\n        return condition ? null : {\n          maxContentSize: {\n            actualSize: size,\n            maxSize: bytes\n          }\n        };\n      };\n    }\n  }]);\n\n  return FileValidator;\n}(); // Module\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ByteFormatPipe, FileInput, FileInputComponent, FileValidator, MaterialFileInputModule, NGX_MAT_FILE_INPUT_CONFIG };","map":null,"metadata":{},"sourceType":"module"}