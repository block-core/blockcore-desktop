{"ast":null,"code":"const ecc = require('tiny-secp256k1');\n\nconst randomBytes = require('randombytes');\n\nconst typeforce = require('typeforce');\n\nconst types = require('./types');\n\nconst wif = require('wif');\n\nconst NETWORKS = require('./networks');\n\nconst isOptions = typeforce.maybe(typeforce.compile({\n  compressed: types.maybe(types.Boolean),\n  network: types.maybe(types.Network)\n}));\n\nfunction ECPair(d, Q, options) {\n  options = options || {};\n  this.compressed = options.compressed === undefined ? true : options.compressed;\n  this.network = options.network || NETWORKS.bitcoin;\n  this.__d = d || null;\n  this.__Q = null;\n  if (Q) this.__Q = ecc.pointCompress(Q, this.compressed);\n}\n\nObject.defineProperty(ECPair.prototype, 'privateKey', {\n  enumerable: false,\n  get: function () {\n    return this.__d;\n  }\n});\nObject.defineProperty(ECPair.prototype, 'publicKey', {\n  get: function () {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__d, this.compressed);\n    return this.__Q;\n  }\n});\n\nECPair.prototype.toWIF = function () {\n  if (!this.__d) throw new Error('Missing private key');\n  return wif.encode(this.network.wif, this.__d, this.compressed);\n};\n\nECPair.prototype.sign = function (hash) {\n  if (!this.__d) throw new Error('Missing private key');\n  return ecc.sign(hash, this.__d);\n};\n\nECPair.prototype.verify = function (hash, signature) {\n  return ecc.verify(hash, this.publicKey, signature);\n};\n\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer)) throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, null, options);\n}\n\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(null, buffer, options);\n}\n\nfunction fromWIF(string, network) {\n  const decoded = wif.decode(string);\n  const version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network\n  });\n}\n\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  options = options || {};\n  const rng = options.rng || randomBytes;\n  let d;\n\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n\n  return fromPrivateKey(d, options);\n}\n\nmodule.exports = {\n  makeRandom,\n  fromPrivateKey,\n  fromPublicKey,\n  fromWIF\n};","map":null,"metadata":{},"sourceType":"script"}